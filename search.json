[{"title":"系统调用","path":"/p/4f5d4e8d/","content":"API函数的调用过程（3环部分）1、Windows API1.1 Application Programming Interface，简称 API 函数。1.2 Windows有多少个API?主要是存放在 C:\\WINDOWS\\system32 下面所有的dll 1.3 几个重要的DLLKernel32.dll：最核心的功能模块，比如管理内存、进程和线程相关的函数等 User32.dll：是Windows用户界面相关应用程序接口,如创建窗口和发送消息等 GDI32.dll：全称是Graphical Device Interface(图形设备接口),包含用于画图和显示文本的函数.比如要显示一个程序窗口，就调用了其中的函数来画这个窗口 Ntdll.dll：大多数API都会通过这个DLL进入内核(0环) kernelbase：函数api作中转的 2、分析ReadProcessMemory用IDA打开Kernel32.dll，找到ReadProcessMemory函数。win7为例 整个路线是： 用户程序.exe&amp;ReadProcessMemory -&gt;kernel32&amp;ReadProcessMemory -&gt;kernelbase&amp;ReadProcessMemory -&gt;ntdll&amp;NtReadVirtualMemory -&gt;ntdll&amp;KiFastSystemCall—sysenter 最后这里进入0环老系统走中断门int 2e，在新系统里这里进入后则是KiFastCallEntry [!NOTE] 注意：当前的ntdll函数是nt前缀开头，如果是zw开头，则会先走KiSystemService函数，然后在进入KiFastCallEntry2 API函数的调用过程(3环进0环)1、_KUSER_SHARED_DATA 在 User 层和 Kernel 层分别定义了一个 KUSER_SHARED_DATA 结构区域，用于 User 层和 Kernel 层共享某些数据 它们使用固定的地址值映射，_KUSER_SHARED_DATA 结构区域在 User 和 Kernel 层地址分别为 12User 层地址为：0x7ffe0000Kernnel 层地址为：0xffdf0000 [!NOTE] 特别说明：虽然指向的是同一个物理页，但在User 层是只读的，在Kernnel层是可写的. 2、0x7FFE0300当通过eax&#x3D;1来执行cpuid指令时，处理器的特征信息被放在ecx和edx寄存器中，其中edx包含了一个SEP位（11位），该位指明了当前处理器知否支持 sysenter&#x2F;sysexit指令 支持：ntdll.dll!KiFastSystemCall() 不支持：ntdll.dll!KiIntSystemCall() 3、进0环需要更改哪些寄存器？ CS的权限由3变为0 意味着需要新的CS SS与CS的权限永远一致 需要新的SS 权限发生切换的时候，堆栈也一定会切换，需要新的ESP 进0环后代码的位置，需要EIP 4、中断门进0环 4.1 INT 0x2E进0环步骤一：在IDT表中找到0x2E号门描述符 步骤二：分析CS&#x2F;SS&#x2F;ESP&#x2F;EIP的来源 步骤三：分析EIP是什么 5、快速调用进0环 中断门进0环，需要的CS、EIP在IDT表中，需要查内存(SS与ESP由TSS提供) CPU如果支持sysenter指令时，操作系统会提前将CS&#x2F;SS&#x2F;ESP&#x2F;EIP的值存储在MSR寄存器中，sysenter指令执行时，CPU会将MSR寄存器中的值直接写入相关寄存器，没有读内存的过程，所以叫快速调用 5.1 sysenter进0环在执行sysenter指令之前，操作系统必须指定0环的CS段、SS段、EIP以及ESP MSR 地址 IA32_SYSENTER_CS 174H IA32_SYSENTER_ESP 175H IA32_SYSENTER_EIP 176H 12345RDMSR/WRMST来进行读写（操作系统使用WRMST写该寄存器）:kd&gt; rdmsr 174 //查看CSkd&gt; rdmsr 175 //查看ESPkd&gt; rdmsr 176 //查看EIP 具体参考intel白皮书：第二卷 6、总结6.1 API通过中断门进0环 固定中断号为0x2E CS&#x2F;EIP由门描述符提供 ESP&#x2F;SS由TSS提供 进入0环后执行的内核函数：NT!KiSystemService 6.2 API通过sysenter指令进0环 CS&#x2F;ESP&#x2F;EIP由MSR寄存器提供(SS是算出来的) 进入0环后执行的内核函数：NT!KiFastCallEntry 内核模块：ntoskrnl.exe&#x2F;ntkrnlpa.exe 进0环前保存现场_Trap_Frame结构 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394typedef struct _KTRAP_FRAME &#123;//// Following 4 values are only used and defined for DBG systems,// but are always allocated to make switching from DBG to non-DBG// and back quicker. They are not DEVL because they have a non-0// performance impact.//0x000 ULONG DbgEbp; // Copy of User EBP set up so KB will work.0x004 ULONG DbgEip; // EIP of caller to system call, again, for KB.0x008 ULONG DbgArgMark; // Marker to show no args here.0x00c ULONG DbgArgPointer; // Pointer to the actual args//// Temporary values used when frames are edited.////// NOTE: Any code that want&#x27;s ESP must materialize it, since it// is not stored in the frame for kernel mode callers.//// And code that sets ESP in a KERNEL mode frame, must put// the new value in TempEsp, make sure that TempSegCs holds// the real SegCs value, and put a special marker value into SegCs.//0x010 ULONG TempSegCs;0x014 ULONG TempEsp;//// Debug registers.//0x018 ULONG Dr0;0x01c ULONG Dr1;0x020 ULONG Dr2;0x024 ULONG Dr3;0x028 ULONG Dr6;0x02c ULONG Dr7;//// Segment registers//0x030 ULONG SegGs;0x034 ULONG SegEs;0x038 ULONG SegDs;//// Volatile registers//0x03c ULONG Edx;0x040 ULONG Ecx;0x044 ULONG Eax;//// Nesting state, not part of context record//0x048 ULONG PreviousPreviousMode;0x04c PEXCEPTION_REGISTRATION_RECORD ExceptionList; // Trash if caller was user mode. // Saved exception list if caller // was kernel mode or we&#x27;re in // an interrupt.//// FS is TIB/PCR pointer, is here to make save sequence easy//0x050 ULONG SegFs;//// Non-volatile registers//0x054 ULONG Edi;0x058 ULONG Esi;0x05c ULONG Ebx;0x060 ULONG Ebp;//// Control registers//0x064 ULONG ErrCode;0x068 ULONG Eip;0x06c ULONG SegCs;0x070 ULONG EFlags;0x074 ULONG HardwareEsp; // WARNING - segSS:esp are only here for stacks0x078 ULONG HardwareSegSs; // that involve a ring transition.0x07c ULONG V86Es; // these will be present for all transitions from0x080 ULONG V86Ds; // V86 mode0x084 ULONG V86Fs;0x08c ULONG V86Gs;&#125; KTRAP_FRAME; 其中0x064 ULONG ErrCode;参考白皮书第三卷 _ETHREAD结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889nt!_ETHREAD +0x000 Tcb : _KTHREAD +0x200 CreateTime : _LARGE_INTEGER +0x208 ExitTime : _LARGE_INTEGER +0x208 KeyedWaitChain : _LIST_ENTRY +0x210 ExitStatus : Int4B +0x214 PostBlockList : _LIST_ENTRY +0x214 ForwardLinkShadow : Ptr32 Void +0x218 StartAddress : Ptr32 Void +0x21c TerminationPort : Ptr32 _TERMINATION_PORT +0x21c ReaperLink : Ptr32 _ETHREAD +0x21c KeyedWaitValue : Ptr32 Void +0x220 ActiveTimerListLock : Uint4B +0x224 ActiveTimerListHead : _LIST_ENTRY +0x22c Cid : _CLIENT_ID +0x234 KeyedWaitSemaphore : _KSEMAPHORE +0x234 AlpcWaitSemaphore : _KSEMAPHORE +0x248 ClientSecurity : _PS_CLIENT_SECURITY_CONTEXT +0x24c IrpList : _LIST_ENTRY +0x254 TopLevelIrp : Uint4B +0x258 DeviceToVerify : Ptr32 _DEVICE_OBJECT +0x25c CpuQuotaApc : Ptr32 _PSP_CPU_QUOTA_APC +0x260 Win32StartAddress : Ptr32 Void +0x264 LegacyPowerObject : Ptr32 Void +0x268 ThreadListEntry : _LIST_ENTRY +0x270 RundownProtect : _EX_RUNDOWN_REF +0x274 ThreadLock : _EX_PUSH_LOCK +0x278 ReadClusterSize : Uint4B +0x27c MmLockOrdering : Int4B +0x280 CrossThreadFlags : Uint4B +0x280 Terminated : Pos 0, 1 Bit +0x280 ThreadInserted : Pos 1, 1 Bit +0x280 HideFromDebugger : Pos 2, 1 Bit +0x280 ActiveImpersonationInfo : Pos 3, 1 Bit +0x280 Reserved : Pos 4, 1 Bit +0x280 HardErrorsAreDisabled : Pos 5, 1 Bit +0x280 BreakOnTermination : Pos 6, 1 Bit +0x280 SkipCreationMsg : Pos 7, 1 Bit +0x280 SkipTerminationMsg : Pos 8, 1 Bit +0x280 CopyTokenOnOpen : Pos 9, 1 Bit +0x280 ThreadIoPriority : Pos 10, 3 Bits +0x280 ThreadPagePriority : Pos 13, 3 Bits +0x280 RundownFail : Pos 16, 1 Bit +0x280 NeedsWorkingSetAging : Pos 17, 1 Bit +0x284 SameThreadPassiveFlags : Uint4B +0x284 ActiveExWorker : Pos 0, 1 Bit +0x284 ExWorkerCanWaitUser : Pos 1, 1 Bit +0x284 MemoryMaker : Pos 2, 1 Bit +0x284 ClonedThread : Pos 3, 1 Bit +0x284 KeyedEventInUse : Pos 4, 1 Bit +0x284 RateApcState : Pos 5, 2 Bits +0x284 SelfTerminate : Pos 7, 1 Bit +0x288 SameThreadApcFlags : Uint4B +0x288 Spare : Pos 0, 1 Bit +0x288 StartAddressInvalid : Pos 1, 1 Bit +0x288 EtwPageFaultCalloutActive : Pos 2, 1 Bit +0x288 OwnsProcessWorkingSetExclusive : Pos 3, 1 Bit +0x288 OwnsProcessWorkingSetShared : Pos 4, 1 Bit +0x288 OwnsSystemCacheWorkingSetExclusive : Pos 5, 1 Bit +0x288 OwnsSystemCacheWorkingSetShared : Pos 6, 1 Bit +0x288 OwnsSessionWorkingSetExclusive : Pos 7, 1 Bit +0x289 OwnsSessionWorkingSetShared : Pos 0, 1 Bit +0x289 OwnsProcessAddressSpaceExclusive : Pos 1, 1 Bit +0x289 OwnsProcessAddressSpaceShared : Pos 2, 1 Bit +0x289 SuppressSymbolLoad : Pos 3, 1 Bit +0x289 Prefetching : Pos 4, 1 Bit +0x289 OwnsDynamicMemoryShared : Pos 5, 1 Bit +0x289 OwnsChangeControlAreaExclusive : Pos 6, 1 Bit +0x289 OwnsChangeControlAreaShared : Pos 7, 1 Bit +0x28a OwnsPagedPoolWorkingSetExclusive : Pos 0, 1 Bit +0x28a OwnsPagedPoolWorkingSetShared : Pos 1, 1 Bit +0x28a OwnsSystemPtesWorkingSetExclusive : Pos 2, 1 Bit +0x28a OwnsSystemPtesWorkingSetShared : Pos 3, 1 Bit +0x28a TrimTrigger : Pos 4, 2 Bits +0x28a Spare1 : Pos 6, 2 Bits +0x28b PriorityRegionActive : UChar +0x28c CacheManagerActive : UChar +0x28d DisablePageFaultClustering : UChar +0x28e ActiveFaultCount : UChar +0x28f LockOrderState : UChar +0x290 AlpcMessageId : Uint4B +0x294 AlpcMessage : Ptr32 Void +0x294 AlpcReceiveAttributeSet : Uint4B +0x298 AlpcWaitListEntry : _LIST_ENTRY +0x2a0 CacheManagerCount : Uint4B +0x2a4 IoBoostCount : Uint4B +0x2a8 IrpListLock : Uint4B +0x2ac ReservedForSynchTracking : Ptr32 Void +0x2b0 CmCallbackListHead : _SINGLE_LIST_ENTRY _KTHREAD结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119kd&gt; dt _KTHREADnt!_KTHREAD +0x000 Header : _DISPATCHER_HEADER +0x010 CycleTime : Uint8B +0x018 HighCycleTime : Uint4B +0x020 QuantumTarget : Uint8B +0x028 InitialStack : Ptr32 Void +0x02c StackLimit : Ptr32 Void +0x030 KernelStack : Ptr32 Void +0x034 ThreadLock : Uint4B +0x038 WaitRegister : _KWAIT_STATUS_REGISTER +0x039 Running : UChar +0x03a Alerted : [2] UChar +0x03c KernelStackResident : Pos 0, 1 Bit +0x03c ReadyTransition : Pos 1, 1 Bit +0x03c ProcessReadyQueue : Pos 2, 1 Bit +0x03c WaitNext : Pos 3, 1 Bit +0x03c SystemAffinityActive : Pos 4, 1 Bit +0x03c Alertable : Pos 5, 1 Bit +0x03c GdiFlushActive : Pos 6, 1 Bit +0x03c UserStackWalkActive : Pos 7, 1 Bit +0x03c ApcInterruptRequest : Pos 8, 1 Bit +0x03c ForceDeferSchedule : Pos 9, 1 Bit +0x03c QuantumEndMigrate : Pos 10, 1 Bit +0x03c UmsDirectedSwitchEnable : Pos 11, 1 Bit +0x03c TimerActive : Pos 12, 1 Bit +0x03c SystemThread : Pos 13, 1 Bit +0x03c Reserved : Pos 14, 18 Bits +0x03c MiscFlags : Int4B +0x040 ApcState : _KAPC_STATE +0x040 ApcStateFill : [23] UChar +0x057 Priority : Char +0x058 NextProcessor : Uint4B +0x05c DeferredProcessor : Uint4B +0x060 ApcQueueLock : Uint4B +0x064 ContextSwitches : Uint4B +0x068 State : UChar +0x069 NpxState : Char +0x06a WaitIrql : UChar +0x06b WaitMode : Char +0x06c WaitStatus : Int4B +0x070 WaitBlockList : Ptr32 _KWAIT_BLOCK +0x074 WaitListEntry : _LIST_ENTRY +0x074 SwapListEntry : _SINGLE_LIST_ENTRY +0x07c Queue : Ptr32 _KQUEUE +0x080 WaitTime : Uint4B +0x084 KernelApcDisable : Int2B +0x086 SpecialApcDisable : Int2B +0x084 CombinedApcDisable : Uint4B +0x088 Teb : Ptr32 Void +0x090 Timer : _KTIMER +0x0b8 AutoAlignment : Pos 0, 1 Bit +0x0b8 DisableBoost : Pos 1, 1 Bit +0x0b8 EtwStackTraceApc1Inserted : Pos 2, 1 Bit +0x0b8 EtwStackTraceApc2Inserted : Pos 3, 1 Bit +0x0b8 CalloutActive : Pos 4, 1 Bit +0x0b8 ApcQueueable : Pos 5, 1 Bit +0x0b8 EnableStackSwap : Pos 6, 1 Bit +0x0b8 GuiThread : Pos 7, 1 Bit +0x0b8 UmsPerformingSyscall : Pos 8, 1 Bit +0x0b8 VdmSafe : Pos 9, 1 Bit +0x0b8 UmsDispatched : Pos 10, 1 Bit +0x0b8 ReservedFlags : Pos 11, 21 Bits +0x0b8 ThreadFlags : Int4B +0x0bc ServiceTable : Ptr32 Void +0x0c0 WaitBlock : [4] _KWAIT_BLOCK +0x120 QueueListEntry : _LIST_ENTRY +0x128 TrapFrame : Ptr32 _KTRAP_FRAME +0x12c FirstArgument : Ptr32 Void +0x130 CallbackStack : Ptr32 Void +0x130 CallbackDepth : Uint4B +0x134 ApcStateIndex : UChar +0x135 BasePriority : Char +0x136 PriorityDecrement : Char +0x136 ForegroundBoost : Pos 0, 4 Bits +0x136 UnusualBoost : Pos 4, 4 Bits +0x137 Preempted : UChar +0x138 AdjustReason : UChar +0x139 AdjustIncrement : Char +0x13a PreviousMode : Char +0x13b Saturation : Char +0x13c SystemCallNumber : Uint4B +0x140 FreezeCount : Uint4B +0x144 UserAffinity : _GROUP_AFFINITY +0x150 Process : Ptr32 _KPROCESS +0x154 Affinity : _GROUP_AFFINITY +0x160 IdealProcessor : Uint4B +0x164 UserIdealProcessor : Uint4B +0x168 ApcStatePointer : [2] Ptr32 _KAPC_STATE +0x170 SavedApcState : _KAPC_STATE +0x170 SavedApcStateFill : [23] UChar +0x187 WaitReason : UChar +0x188 SuspendCount : Char +0x189 Spare1 : Char +0x18a OtherPlatformFill : UChar +0x18c Win32Thread : Ptr32 Void +0x190 StackBase : Ptr32 Void +0x194 SuspendApc : _KAPC +0x194 SuspendApcFill0 : [1] UChar +0x195 ResourceIndex : UChar +0x194 SuspendApcFill1 : [3] UChar +0x197 QuantumReset : UChar +0x194 SuspendApcFill2 : [4] UChar +0x198 KernelTime : Uint4B +0x194 SuspendApcFill3 : [36] UChar +0x1b8 WaitPrcb : Ptr32 _KPRCB +0x194 SuspendApcFill4 : [40] UChar +0x1bc LegoData : Ptr32 Void +0x194 SuspendApcFill5 : [47] UChar +0x1c3 LargeStack : UChar +0x1c4 UserTime : Uint4B +0x1c8 SuspendSemaphore : _KSEMAPHORE +0x1c8 SuspendSemaphorefill : [20] UChar +0x1dc SListFaultCount : Uint4B +0x1e0 ThreadListEntry : _LIST_ENTRY +0x1e8 MutantListHead : _LIST_ENTRY +0x1f0 SListFaultAddress : Ptr32 Void +0x1f4 ThreadCounters : Ptr32 _KTHREAD_COUNTERS +0x1f8 XStateSave : Ptr32 _XSTATE_SAVE _KPCR结构1234567891011121314151617181920212223242526272829303132333435nt!_KPCR +0x000 NtTib : _NT_TIB +0x000 Used_ExceptionList : Ptr32 _EXCEPTION_REGISTRATION_RECORD +0x004 Used_StackBase : Ptr32 Void +0x008 Spare2 : Ptr32 Void +0x00c TssCopy : Ptr32 Void +0x010 ContextSwitches : Uint4B +0x014 SetMemberCopy : Uint4B +0x018 Used_Self : Ptr32 Void +0x01c SelfPcr : Ptr32 _KPCR +0x020 Prcb : Ptr32 _KPRCB +0x024 Irql : UChar +0x028 IRR : Uint4B +0x02c IrrActive : Uint4B +0x030 IDR : Uint4B +0x034 KdVersionBlock : Ptr32 Void +0x038 IDT : Ptr32 _KIDTENTRY +0x03c GDT : Ptr32 _KGDTENTRY +0x040 TSS : Ptr32 _KTSS +0x044 MajorVersion : Uint2B +0x046 MinorVersion : Uint2B +0x048 SetMember : Uint4B +0x04c StallScaleFactor : Uint4B +0x050 SpareUnused : UChar +0x051 Number : UChar +0x052 Spare0 : UChar +0x053 SecondLevelCacheAssociativity : UChar +0x054 VdmAlert : Uint4B +0x058 KernelReserved : [14] Uint4B +0x090 SecondLevelCacheSize : Uint4B +0x094 HalReserved : [16] Uint4B +0x0d4 InterruptMode : Uint4B +0x0d8 Spare1 : UChar +0x0dc KernelReserved2 : [17] Uint4B +0x120 PrcbData : _KPRCB _NT_TIB结构123456789nt!_NT_TIB +0x000 ExceptionList : Ptr32 _EXCEPTION_REGISTRATION_RECORD +0x004 StackBase : Ptr32 Void +0x008 StackLimit : Ptr32 Void +0x00c SubSystemTib : Ptr32 Void +0x010 FiberData : Ptr32 Void +0x010 Version : Uint4B +0x014 ArbitraryUserPointer : Ptr32 Void +0x018 Self : Ptr32 _NT_TIB _KPRCB结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246nt!_KPRCB +0x000 MinorVersion : Uint2B +0x002 MajorVersion : Uint2B +0x004 CurrentThread : Ptr32 _KTHREAD +0x008 NextThread : Ptr32 _KTHREAD +0x00c IdleThread : Ptr32 _KTHREAD +0x010 LegacyNumber : UChar +0x011 NestingLevel : UChar +0x012 BuildType : Uint2B +0x014 CpuType : Char +0x015 CpuID : Char +0x016 CpuStep : Uint2B +0x016 CpuStepping : UChar +0x017 CpuModel : UChar +0x018 ProcessorState : _KPROCESSOR_STATE +0x338 KernelReserved : [16] Uint4B +0x378 HalReserved : [16] Uint4B +0x3b8 CFlushSize : Uint4B +0x3bc CoresPerPhysicalProcessor : UChar +0x3bd LogicalProcessorsPerCore : UChar +0x3be PrcbPad0 : [2] UChar +0x3c0 MHz : Uint4B +0x3c4 CpuVendor : UChar +0x3c5 GroupIndex : UChar +0x3c6 Group : Uint2B +0x3c8 GroupSetMember : Uint4B +0x3cc Number : Uint4B +0x3d0 PrcbPad1 : [72] UChar +0x418 LockQueue : [17] _KSPIN_LOCK_QUEUE +0x4a0 NpxThread : Ptr32 _KTHREAD +0x4a4 InterruptCount : Uint4B +0x4a8 KernelTime : Uint4B +0x4ac UserTime : Uint4B +0x4b0 DpcTime : Uint4B +0x4b4 DpcTimeCount : Uint4B +0x4b8 InterruptTime : Uint4B +0x4bc AdjustDpcThreshold : Uint4B +0x4c0 PageColor : Uint4B +0x4c4 DebuggerSavedIRQL : UChar +0x4c5 NodeColor : UChar +0x4c6 PrcbPad20 : [2] UChar +0x4c8 NodeShiftedColor : Uint4B +0x4cc ParentNode : Ptr32 _KNODE +0x4d0 SecondaryColorMask : Uint4B +0x4d4 DpcTimeLimit : Uint4B +0x4d8 PrcbPad21 : [2] Uint4B +0x4e0 CcFastReadNoWait : Uint4B +0x4e4 CcFastReadWait : Uint4B +0x4e8 CcFastReadNotPossible : Uint4B +0x4ec CcCopyReadNoWait : Uint4B +0x4f0 CcCopyReadWait : Uint4B +0x4f4 CcCopyReadNoWaitMiss : Uint4B +0x4f8 MmSpinLockOrdering : Int4B +0x4fc IoReadOperationCount : Int4B +0x500 IoWriteOperationCount : Int4B +0x504 IoOtherOperationCount : Int4B +0x508 IoReadTransferCount : _LARGE_INTEGER +0x510 IoWriteTransferCount : _LARGE_INTEGER +0x518 IoOtherTransferCount : _LARGE_INTEGER +0x520 CcFastMdlReadNoWait : Uint4B +0x524 CcFastMdlReadWait : Uint4B +0x528 CcFastMdlReadNotPossible : Uint4B +0x52c CcMapDataNoWait : Uint4B +0x530 CcMapDataWait : Uint4B +0x534 CcPinMappedDataCount : Uint4B +0x538 CcPinReadNoWait : Uint4B +0x53c CcPinReadWait : Uint4B +0x540 CcMdlReadNoWait : Uint4B +0x544 CcMdlReadWait : Uint4B +0x548 CcLazyWriteHotSpots : Uint4B +0x54c CcLazyWriteIos : Uint4B +0x550 CcLazyWritePages : Uint4B +0x554 CcDataFlushes : Uint4B +0x558 CcDataPages : Uint4B +0x55c CcLostDelayedWrites : Uint4B +0x560 CcFastReadResourceMiss : Uint4B +0x564 CcCopyReadWaitMiss : Uint4B +0x568 CcFastMdlReadResourceMiss : Uint4B +0x56c CcMapDataNoWaitMiss : Uint4B +0x570 CcMapDataWaitMiss : Uint4B +0x574 CcPinReadNoWaitMiss : Uint4B +0x578 CcPinReadWaitMiss : Uint4B +0x57c CcMdlReadNoWaitMiss : Uint4B +0x580 CcMdlReadWaitMiss : Uint4B +0x584 CcReadAheadIos : Uint4B +0x588 KeAlignmentFixupCount : Uint4B +0x58c KeExceptionDispatchCount : Uint4B +0x590 KeSystemCalls : Uint4B +0x594 AvailableTime : Uint4B +0x598 PrcbPad22 : [2] Uint4B +0x5a0 PPLookasideList : [16] _PP_LOOKASIDE_LIST +0x620 PPNPagedLookasideList : [32] _GENERAL_LOOKASIDE_POOL +0xf20 PPPagedLookasideList : [32] _GENERAL_LOOKASIDE_POOL +0x1820 PacketBarrier : Uint4B +0x1824 ReverseStall : Int4B +0x1828 IpiFrame : Ptr32 Void +0x182c PrcbPad3 : [52] UChar +0x1860 CurrentPacket : [3] Ptr32 Void +0x186c TargetSet : Uint4B +0x1870 WorkerRoutine : Ptr32 void +0x1874 IpiFrozen : Uint4B +0x1878 PrcbPad4 : [40] UChar +0x18a0 RequestSummary : Uint4B +0x18a4 SignalDone : Ptr32 _KPRCB +0x18a8 PrcbPad50 : [56] UChar +0x18e0 DpcData : [2] _KDPC_DATA +0x1908 DpcStack : Ptr32 Void +0x190c MaximumDpcQueueDepth : Int4B +0x1910 DpcRequestRate : Uint4B +0x1914 MinimumDpcRate : Uint4B +0x1918 DpcLastCount : Uint4B +0x191c PrcbLock : Uint4B +0x1920 DpcGate : _KGATE +0x1930 ThreadDpcEnable : UChar +0x1931 QuantumEnd : UChar +0x1932 DpcRoutineActive : UChar +0x1933 IdleSchedule : UChar +0x1934 DpcRequestSummary : Int4B +0x1934 DpcRequestSlot : [2] Int2B +0x1934 NormalDpcState : Int2B +0x1936 DpcThreadActive : Pos 0, 1 Bit +0x1936 ThreadDpcState : Int2B +0x1938 TimerHand : Uint4B +0x193c LastTick : Uint4B +0x1940 MasterOffset : Int4B +0x1944 PrcbPad41 : [2] Uint4B +0x194c PeriodicCount : Uint4B +0x1950 PeriodicBias : Uint4B +0x1958 TickOffset : Uint8B +0x1960 TimerTable : _KTIMER_TABLE +0x31a0 CallDpc : _KDPC +0x31c0 ClockKeepAlive : Int4B +0x31c4 ClockCheckSlot : UChar +0x31c5 ClockPollCycle : UChar +0x31c6 PrcbPad6 : [2] UChar +0x31c8 DpcWatchdogPeriod : Int4B +0x31cc DpcWatchdogCount : Int4B +0x31d0 ThreadWatchdogPeriod : Int4B +0x31d4 ThreadWatchdogCount : Int4B +0x31d8 KeSpinLockOrdering : Int4B +0x31dc PrcbPad70 : [1] Uint4B +0x31e0 WaitListHead : _LIST_ENTRY +0x31e8 WaitLock : Uint4B +0x31ec ReadySummary : Uint4B +0x31f0 QueueIndex : Uint4B +0x31f4 DeferredReadyListHead : _SINGLE_LIST_ENTRY +0x31f8 StartCycles : Uint8B +0x3200 CycleTime : Uint8B +0x3208 HighCycleTime : Uint4B +0x320c PrcbPad71 : Uint4B +0x3210 PrcbPad72 : [2] Uint8B +0x3220 DispatcherReadyListHead : [32] _LIST_ENTRY +0x3320 ChainedInterruptList : Ptr32 Void +0x3324 LookasideIrpFloat : Int4B +0x3328 MmPageFaultCount : Int4B +0x332c MmCopyOnWriteCount : Int4B +0x3330 MmTransitionCount : Int4B +0x3334 MmCacheTransitionCount : Int4B +0x3338 MmDemandZeroCount : Int4B +0x333c MmPageReadCount : Int4B +0x3340 MmPageReadIoCount : Int4B +0x3344 MmCacheReadCount : Int4B +0x3348 MmCacheIoCount : Int4B +0x334c MmDirtyPagesWriteCount : Int4B +0x3350 MmDirtyWriteIoCount : Int4B +0x3354 MmMappedPagesWriteCount : Int4B +0x3358 MmMappedWriteIoCount : Int4B +0x335c CachedCommit : Uint4B +0x3360 CachedResidentAvailable : Uint4B +0x3364 HyperPte : Ptr32 Void +0x3368 PrcbPad8 : [4] UChar +0x336c VendorString : [13] UChar +0x3379 InitialApicId : UChar +0x337a LogicalProcessorsPerPhysicalProcessor : UChar +0x337b PrcbPad9 : [5] UChar +0x3380 FeatureBits : Uint4B +0x3388 UpdateSignature : _LARGE_INTEGER +0x3390 IsrTime : Uint8B +0x3398 RuntimeAccumulation : Uint8B +0x33a0 PowerState : _PROCESSOR_POWER_STATE +0x3468 DpcWatchdogDpc : _KDPC +0x3488 DpcWatchdogTimer : _KTIMER +0x34b0 WheaInfo : Ptr32 Void +0x34b4 EtwSupport : Ptr32 Void +0x34b8 InterruptObjectPool : _SLIST_HEADER +0x34c0 HypercallPageList : _SLIST_HEADER +0x34c8 HypercallPageVirtual : Ptr32 Void +0x34cc VirtualApicAssist : Ptr32 Void +0x34d0 StatisticsPage : Ptr32 Uint8B +0x34d4 RateControl : Ptr32 Void +0x34d8 Cache : [5] _CACHE_DESCRIPTOR +0x3514 CacheCount : Uint4B +0x3518 CacheProcessorMask : [5] Uint4B +0x352c PackageProcessorSet : _KAFFINITY_EX +0x3538 PrcbPad91 : [1] Uint4B +0x353c CoreProcessorSet : Uint4B +0x3540 TimerExpirationDpc : _KDPC +0x3560 SpinLockAcquireCount : Uint4B +0x3564 SpinLockContentionCount : Uint4B +0x3568 SpinLockSpinCount : Uint4B +0x356c IpiSendRequestBroadcastCount : Uint4B +0x3570 IpiSendRequestRoutineCount : Uint4B +0x3574 IpiSendSoftwareInterruptCount : Uint4B +0x3578 ExInitializeResourceCount : Uint4B +0x357c ExReInitializeResourceCount : Uint4B +0x3580 ExDeleteResourceCount : Uint4B +0x3584 ExecutiveResourceAcquiresCount : Uint4B +0x3588 ExecutiveResourceContentionsCount : Uint4B +0x358c ExecutiveResourceReleaseExclusiveCount : Uint4B +0x3590 ExecutiveResourceReleaseSharedCount : Uint4B +0x3594 ExecutiveResourceConvertsCount : Uint4B +0x3598 ExAcqResExclusiveAttempts : Uint4B +0x359c ExAcqResExclusiveAcquiresExclusive : Uint4B +0x35a0 ExAcqResExclusiveAcquiresExclusiveRecursive : Uint4B +0x35a4 ExAcqResExclusiveWaits : Uint4B +0x35a8 ExAcqResExclusiveNotAcquires : Uint4B +0x35ac ExAcqResSharedAttempts : Uint4B +0x35b0 ExAcqResSharedAcquiresExclusive : Uint4B +0x35b4 ExAcqResSharedAcquiresShared : Uint4B +0x35b8 ExAcqResSharedAcquiresSharedRecursive : Uint4B +0x35bc ExAcqResSharedWaits : Uint4B +0x35c0 ExAcqResSharedNotAcquires : Uint4B +0x35c4 ExAcqResSharedStarveExclusiveAttempts : Uint4B +0x35c8 ExAcqResSharedStarveExclusiveAcquiresExclusive : Uint4B +0x35cc ExAcqResSharedStarveExclusiveAcquiresShared : Uint4B +0x35d0 ExAcqResSharedStarveExclusiveAcquiresSharedRecursive : Uint4B +0x35d4 ExAcqResSharedStarveExclusiveWaits : Uint4B +0x35d8 ExAcqResSharedStarveExclusiveNotAcquires : Uint4B +0x35dc ExAcqResSharedWaitForExclusiveAttempts : Uint4B +0x35e0 ExAcqResSharedWaitForExclusiveAcquiresExclusive : Uint4B +0x35e4 ExAcqResSharedWaitForExclusiveAcquiresShared : Uint4B +0x35e8 ExAcqResSharedWaitForExclusiveAcquiresSharedRecursive : Uint4B +0x35ec ExAcqResSharedWaitForExclusiveWaits : Uint4B +0x35f0 ExAcqResSharedWaitForExclusiveNotAcquires : Uint4B +0x35f4 ExSetResOwnerPointerExclusive : Uint4B +0x35f8 ExSetResOwnerPointerSharedNew : Uint4B +0x35fc ExSetResOwnerPointerSharedOld : Uint4B +0x3600 ExTryToAcqExclusiveAttempts : Uint4B +0x3604 ExTryToAcqExclusiveAcquires : Uint4B +0x3608 ExBoostExclusiveOwner : Uint4B +0x360c ExBoostSharedOwners : Uint4B +0x3610 ExEtwSynchTrackingNotificationsCount : Uint4B +0x3614 ExEtwSynchTrackingNotificationsAccountedCount : Uint4B +0x3618 Context : Ptr32 _CONTEXT +0x361c ContextFlags : Uint4B +0x3620 ExtendedState : Ptr32 _XSAVE_AREA 查看CPU数量 1kd&gt; dd KeNumberProcessors 查看KPCR 123456789101112131415161718192021222324252627282930313233343536373839kd&gt; dd KiProcessorBlock L283fb88c0 83f79d20 00000000kd&gt; dt _kpcr 83f79d20-120nt!_KPCR +0x000 NtTib : _NT_TIB +0x000 Used_ExceptionList : 0x83f760ac _EXCEPTION_REGISTRATION_RECORD +0x004 Used_StackBase : (null) +0x008 Spare2 : (null) +0x00c TssCopy : 0x801e4000 Void +0x010 ContextSwitches : 0xbac4f +0x014 SetMemberCopy : 1 +0x018 Used_Self : (null) +0x01c SelfPcr : 0x83f79c00 _KPCR +0x020 Prcb : 0x83f79d20 _KPRCB +0x024 Irql : 0x1f &#x27;&#x27; +0x028 IRR : 0 +0x02c IrrActive : 0 +0x030 IDR : 0xffffffff +0x034 KdVersionBlock : 0x83f78c00 Void +0x038 IDT : 0x80b99400 _KIDTENTRY +0x03c GDT : 0x80b99000 _KGDTENTRY +0x040 TSS : 0x801e4000 _KTSS +0x044 MajorVersion : 1 +0x046 MinorVersion : 1 +0x048 SetMember : 1 +0x04c StallScaleFactor : 0xa20 +0x050 SpareUnused : 0 &#x27;&#x27; +0x051 Number : 0 &#x27;&#x27; +0x052 Spare0 : 0 &#x27;&#x27; +0x053 SecondLevelCacheAssociativity : 0 &#x27;&#x27; +0x054 VdmAlert : 0 +0x058 KernelReserved : [14] 0 +0x090 SecondLevelCacheSize : 0 +0x094 HalReserved : [16] 0x1000000 +0x0d4 InterruptMode : 0 +0x0d8 Spare1 : 0 &#x27;&#x27; +0x0dc KernelReserved2 : [17] 0 +0x120 PrcbData : _KPRCB 系统服务表1、SystemServiceTable 系统服务表 2、SystemServiceTable 系统服务表位置通过_KTHREAD+0xE0 3、判断要调用的函数在哪个表通过服务号 4、找到要执行的函数与参数个数 SSDT1、SystemServiceTable 系统服务表123456typedef struct _KSERVICE_TABLE_DESCRIPTOR &#123; PULONG_PTR Base; 0x0 函数表 PULONG Count; 0x4 统计这张表调用次数 ULONG Limit; 0x8 函数总个数表 PUCHAR Number; 0xc 函数参数个数表&#125; KSERVICE_TABLE_DESCRIPTOR 2、如何访问系统服务表呢？SSDT 的全称是 System Services Descriptor Table，系统服务描述符表 123kd&gt; dd KeServiceDescriptorTable(SSDT)导出的 声明一下就可以使用了kd&gt; dd KeServiceDescriptorTableShadow(SSDT Shadow)未导出 需要用其他的方式来查找 [!NOTE] KeServiceDescriptorTableShadow &#x3D; KeServiceDescriptorTable + 0x40","tags":["滴水中级","win内核"],"categories":["逆向"]},{"title":"驱动开发","path":"/p/692eb761/","content":"开发环境环境配置1、配置使用的是VS2019 前提条件： VS2019安装正确 安装WDK 安装WDK之前一定要看清楚，对应当前VS2019安装的windows SDK版本 12345678910111213141516171819202122232425次函数可能设置的时间会比较长，虚拟机内存越大，耗时越长vmxPid:虚拟机进程ID vmware-vmx.exe的IDMajorVersion:虚拟机系统的主版本MinorVersion:虚拟机系统的次版本BuildNumber :虚拟机系统的内部版本号例如:WIN7 MajorVersion=6 MinorVersion=1 BuildNumber=7600 或 7601例如:WIN10 MajorVersion=10 MinorVersion=0 BuildNumber=18326 代表1903-----------------------------------------Windows 11（21H2） 22000Windows 10（21H1）\t19043Windows 10（20H2）\t19042Windows 10（2004) 19041Windows 10（1909）\t18363Windows 10（1903）\t18362Windows 10（1809）\t17763Windows 10（1803）\t17134Windows 10（1709）\t16299Windows 10（1703）\t15063Windows 10（1607）\t14393Windows 10（1511）\t10586Windows 10\t(1507)\t10240Windows 8.1（更新1）\tMajorVersion = 6 MinorVersion = 3 BuildNumber = 9600Windows 8.1 MajorVersion = 6 MinorVersion = 3 BuildNumber = 9200Windows 8 MajorVersion = 6 MinorVersion = 2 BuildNumber = 9200 根据对应的小版本号去寻找并且安装WDK，因为我系统是win10部操作系统版本号是1904，比如图中我安装的SDK小版本号是19041，并且我用的VS2019，这个版本号比较特殊，在官网寻找，发现需要用到win10 2004版本的WDK。 之后下载WDK进行安装，默认安装位置即可。 项目配置新建项目选择Empty WDM Driver，新建完成后。配置属性页，如果配置所有平台出现，左侧栏少东西，那你就删掉ARM那几个平台 配置代码片段，方便快速开发 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;CodeSnippets xmlns=&quot;http://schemas.microsoft.com/VisualStudio/2005/CodeSnippet&quot;&gt;\t&lt;CodeSnippet Format=&quot;1.0.0&quot;&gt; &lt;Header&gt; &lt;Title&gt;DriverMain&lt;/Title&gt; &lt;Shortcut&gt;DriverMain&lt;/Shortcut&gt; &lt;Description&gt;DriverMain&lt;/Description&gt; &lt;Author&gt;Microsoft Corporation&lt;/Author&gt; &lt;SnippetTypes&gt; &lt;SnippetType&gt;Expansion&lt;/SnippetType&gt; &lt;SnippetType&gt;SurroundsWith&lt;/SnippetType&gt; &lt;/SnippetTypes&gt; &lt;/Header&gt; &lt;Snippet&gt; &lt;Code Language=&quot;cpp&quot;&gt;&lt;![CDATA[ #include &lt;ntifs.h&gt; VOID DriverUnload(PDRIVER_OBJECT pDriver) &#123; &#125; NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver,PUNICODE_STRING pReg) &#123; pDriver-&gt;DriverUnload = DriverUnload; return STATUS_SUCCESS; &#125; ]]&gt; &lt;/Code&gt; &lt;/Snippet&gt;\t&lt;/CodeSnippet&gt;&lt;/CodeSnippets&gt; 新建一个文件，命名为DriverMain.snippet。然后添加进代码片段管理器 编写第一个驱动程序驱动的话用C开发比较好，因为用C++开发出来的驱动在某些平台会出现蓝屏。 12345678910111213#include &lt;ntifs.h&gt;VOID DriverUnload(PDRIVER_OBJECT pDriver)&#123;\tDbgBreakPoint();&#125;NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg)&#123;\tDbgPrintEx(0,0,&quot;第一个驱动测试程序&quot;);\tDbgBreakPoint();\tpDriver-&gt;DriverUnload = DriverUnload;\treturn STATUS_SUCCESS;&#125; 编译后得到.sys文件放入win7虚拟机测试。 驱动管理程序进行注册，然后运行。 调试驱动程序1、配置调试驱动程序调试不如应用程序调试方便，主要因为驱动程序运行在操作系统内核中，直接调试内核程序难度大。 驱动程序调试需要使用特殊的调试器，如WinDbg，且调试过程通常涉及虚拟机和技术如断点和单步执行。 驱动程序调试时，无法在当前开发环境中直接调试，需要将驱动文件部署到新的操作系统环境中进行 原来我们是手动修改windbg软件的快捷图标信息来配置和虚拟机进行双机调试的，这次我们 VirtualKD来简化配置过程，提升效率。 具体压缩包目录是这样： 其中target目录是分别针对32位和64位系统的，在对应位数的虚拟机，我们把对应位数的target目录复制到虚拟机内，然后在虚拟机内安装vminstall.exe，这样在启动时会多一个引导项名字是含有Redux。 [!NOTE] 其中虚拟机含win7以上需要按F8，强制禁用驱动签名检测 安装完成后就重新启动。进入对应生成的引导项，启动系统。同时vmmon64.exe是主程序，双击打开。 第一次可能需要配置windbg&#x2F;KD debugger Path路径。 2、PDB文件 PDB文件是在我们编译工程的时候产生的，它是和对应的模块(exe或dll)一起生成出来的 每个模块编译的时候都可以生成自己的PDB文件。比如.exe&#x2F;.dll&#x2F;.sys等等 3、windbg如何找到pdb文件对于虚拟机系统的PDB，我们可以通过微软的符号表服务器自动下载。 12SRV*D:\\Symbols\\XP*http://msdl.microsoft.com/download/symbolskd&gt;.reload 但是对于我们自己写的驱动呢，却无法从微软的符号表服务器自动下载 12SRV*D:\\Symbols\\XP*http://msdl.microsoft.com/download/symbols;D:\\Projects\\_01 HelloDriver\\Driverkd&gt;.reload 内核编程基础1、内核API的使用在应用层编程我们可以使用WINDOWS提供的各种API函数，只要导入头文件&lt;windows.h&gt;就可以了，但是在内核编程的时候，我们不能像在Ring3那样直接使用。微软为内核程序提供了专用的API，只要在程序中包含相应的头文件就可以使用了，如：#include &lt;ntddk.h&gt; (假设你已经正确安装了WDK) 其中在Windows Vista 版本的 WDK 开始，使用Ntifs.h作为头文件。Ntifs.h 包含 Ntddk.h，而 Ntddk.h 又包含 Wdm.h 在应用层编程的时候，我们通过MSDN来了解函数的详细信息，在内核编程的时候，要使用WDK自己的帮助文档 [!NOTE] 在老版本WDK中安装完还会自带帮助文档，但是新版的WDK中不会有文档，需要自己去微软官网查询 2、未导出函数的使用WDK说明文档中只包含了内核模块导出的函数，对于未导出的函数，则不能直接使用。 如果要使用未导出的函数，只要自己定义一个函数指针，并且为函数指针提供正确的函数地址就可以使用了。 有两种办法都可以获取为导出的函数地址： 特征码搜索 通过遍历你想要找的这个内核函数，它那个模块在这个模块里边呢，搜索特征码可以找到我们想要找的这个未导出的。 解析内核PDB文件 PDB调试文件，就相当于内核呃的一份完整的说明书。里边不但包含了。导出函数的相关说明也包含了未导出函数的相关说明，我们可以自己解析它的PDB文件，就像windbg解析它的PDB文件的一样，我们也可以这种方式可以更加灵活的得到。 3、基本数据类型在内核编程的时候，强烈建议大家遵守WDK的编码习惯，不要这样写：unsigned long length; 习惯使用WDK自己的类型 WDK 的写法 等同于 ULONG unsigned long UCHAR unsigned char UINT unsigned int VOID void PULONG unsigned long* PUCHAR unsigned char* PUNIT unsigned int* PVOID void* [!NOTE] 1.建议使用WDK定义的数据类型以确保代码可移植性。 2.使用ULONG等类型定义以适应不同编译平台的宽度要求。 4、返回值大部分内核函数的返回值都是NTSTATUS类型，内核API函数通常返回NTSTATUS，用于指示成功或失败 分别表示一下常见几种情况： 宏 返回值 含义 STATUS_SUCCESS 0x00000000 成功 STATUS_INVALID_PARAMETER 0xC000000D 参数无效 STATUS_BUFFER_OVERFLOW 0x80000005 缓冲区长度不够 当你调用的内核函数，如果返回的结果不是STATUS_SUCCESS，就说明函数执行中遇到了问题，具体是什么问题，可以在ntstatus.h文件中查看。 5、内核中的异常处理在内核中，一个小小的错误就可能导致蓝屏，比如：读写一个无效的内存地址。为了让自己的内核程序更加健壮，强烈建议大家在编写内核程序时，使用异常处 Windows提供了结构化异常处理机制，一般的编译器都是支持的 123456__try&#123;\t//可能出错的代码&#125;__except(filter_value) &#123;\t//出错时要执行的代码&#125; 出现异常时，可根据filter_value的值来决定程序该如果执行，当filter_value的值为 宏名称 实际值 含义 EXCEPTION_EXECUTE_HANDLER 1 代码进入except块 EXCEPTION_CONTINUE_SEARCH 0 不处理异常，由上一层调用函数处理 EXCEPTION_CONTINUE_EXECUTION -1 回去继续执行错误处的代码 6、常用的内核内存函数 C语言 内核中 malloc ExAllocatePool memset RtlFillMemory memcpy RtlMoveMemory free ExFreePool 7、内核字符串种类CHAR(char)相当于ANSI_STRING，WCHAR相当于UNICODE_STRING ANSI_STRING字符串的定义如下 123456typedef struct _STRING&#123; USHORT Length; USHORT MaximumLength; PCHAR Buffer;&#125;STRING; UNICODE_STRING字符串的定义如下 123456typedef struct _UNICODE_STRING&#123; USHORT Length; USHORT MaxmumLength; PWSTR Buffer;&#125; UNICODE_STRING; 内核中避免使用传统字符串以防止蓝屏 推荐使用升级版的字符串结构体，如ANSI_STRING和UNICODE_STRING 8、内核字符串常用函数字符串常用的功能无非就是：创建、复制、比较以及转换等 ANSI_STRING字符串 UNICODE_STRING字符串 含义 RtlInitAnsiString RtlInitUnicodeString 创建 RtlCopyString RtlCopyUnicodeString 复制 RtlCompareString RtlCompareUnicoodeString 比较 RtlAnsiStringToUnicodeString RtlUnicodeStringToAnsiString 转换 内核空间与内核模块1、内核空间 内核模块定义全局变量：在不同进程中查看 在2g中所有模块共享一块内存 现在我设置一个全局变量在驱动里，然后注册运行通过dbgview查看 1234567891011121314#include &lt;ntifs.h&gt;ULONG a = 0x12345678;VOID DriverUnload(PDRIVER_OBJECT pDriver)&#123;\tDbgBreakPoint();&#125;NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg)&#123;\tDbgPrint(&quot;%x &quot;, &amp;a);\tpDriver-&gt;DriverUnload = DriverUnload;\treturn STATUS_SUCCESS;&#125; 现在我们随便找一个进程，通过.process来选择进程查看，我们发现在dbgview的内存中存在那个全局变量的值 证实了在4GB的内存空间中高2G是共享的，高2g就是内核空间。 2、内核模块 硬件种类繁多，不可能做一个兼容所有硬件的内核，所以，微软提供规定的接口格式，让硬件驱动人员安装规定的格式编写“驱动程序” 。 这些驱动程序每一个都是一个模块，称为“内核模块”，都可以加载到内核中，都遵守PE结构。但本质上讲，任意一个.sys文件与内核文件没有区别。 3、DRIVER_OBJECT每个内核模块都有一个对应的结构体，来描述这个模块在内核中的：位置、大小、名称等等。 1234567891011121314151617kd&gt; dt _DRIVER_OBJECTnt!_DRIVER_OBJECT +0x000 Type : Int2B +0x002 Size : Int2B +0x004 DeviceObject : Ptr32 _DEVICE_OBJECT +0x008 Flags : Uint4B +0x00c DriverStart : Ptr32 Void +0x010 DriverSize : Uint4B +0x014 DriverSection : Ptr32 Void +0x018 DriverExtension : Ptr32 _DRIVER_EXTENSION +0x01c DriverName : _UNICODE_STRING +0x024 HardwareDatabase : Ptr32 _UNICODE_STRING +0x028 FastIoDispatch : Ptr32 _FAST_IO_DISPATCH +0x02c DriverInit : Ptr32 long +0x030 DriverStartIo : Ptr32 void +0x034 DriverUnload : Ptr32 void +0x038 MajorFunction : [28] Ptr32 long 4、打印DRIVER_OBJECT地址1DbgPrint(&quot;DRIVER_OBJECT对象地址：%x \\r &quot;,driver); 通过DRIVER_OBJECT找到当前模块信息： 123DbgPrint(&quot;驱动名称：%ws \\r &quot;,driver-&gt;DriverName.Buffer);DbgPrint(&quot;模块基址：%x \\r &quot;,driver-&gt;DriverStart);DbgPrint(&quot;模块大小：%x \\r &quot;,driver-&gt;DriverSize); 5、遍历内核模块 dt _DRIVER_OBJECT (地址) dt _LDR_DATA_TABLE_ENTRY (DriverSection)地址 dt _LDR_DATA_TABLE_ENTRY (InLoadOrderLinks.Flink)地址 123456789101112131415161718192021222324252627kd&gt; dt _LDR_DATA_TABLE_ENTRY 0x87ba7430 nt!_LDR_DATA_TABLE_ENTRY +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x83f82850 - 0x87a114c8 ] //双向链表 +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0xffffffff - 0xffffffff ] +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x1c - 0x0 ] +0x018 DllBase : 0x8d600000 Void +0x01c EntryPoint : 0x8d604000 Void +0x020 SizeOfImage : 0x6000 +0x024 FullDllName : _UNICODE_STRING &quot;\\??\\C:\\Users\\Administrator\\Desktop\\MyDriver1.sys&quot; +0x02c BaseDllName : _UNICODE_STRING &quot;MyDriver1.sys&quot; +0x034 Flags : 0x49104000 +0x038 LoadCount : 1 +0x03a TlsIndex : 0x6d +0x03c HashLinks : _LIST_ENTRY [ 0x0 - 0xabfc ] +0x03c SectionPointer : (null) +0x040 CheckSum : 0xabfc +0x044 TimeDateStamp : 0x490057 +0x044 LoadedImports : 0x00490057 Void +0x048 EntryPointActivationContext : (null) +0x04c PatchInformation : 0x86344c99 Void +0x050 ForwarderLinks : _LIST_ENTRY [ 0x0 - 0x6000 ] +0x058 ServiceTagLinks : _LIST_ENTRY [ 0x67277d47 - 0x79004d ] +0x060 StaticLinks : _LIST_ENTRY [ 0x720044 - 0x760069 ] +0x068 ContextInformation : 0x00720065 Void +0x06c OriginalBase : 0x2e0031 +0x070 LoadTime : _LARGE_INTEGER 0x00000073`00790073 0环与3环通信(常规方式)1、设备对象我们在开发窗口程序的时候，消息被封装成一个结构体：MSG 在内核开发时，消息被封装成另外一个结构体：IRP(I&#x2F;O Request Package) 在窗口程序中，能够接收消息的只能是窗口对象。在内核中，能够接收IRP消息的只能是设备对象 2、创建设备对象1234567891011121314//创建设备名称UNICODE_STRING Devicename;RtlInitUnicodeString(&amp;Devicename,L&quot;\\\\Device\\\\MyDevice&quot;);//创建设备IoCreateDevice(pDriver, //当前设备所属的驱动对象0,&amp;Devicename, //设备对象的名称FILE_DEVICE_UNKNOWN,FILE_DEVICE_SECURE_OPEN,FALSE,&amp;pDeviceObj //设备对象指针); 3、设置交互数据的方式1pDeviceObj-&gt;Flags |= DO_BUFFERED_IO; **缓冲区方式读写(DO_BUFFERED_IO)**：操作系统将应用程序提供缓冲区的数据复制到内核模式下的地址中。 **直接方式读写(DO_DIRECT_IO)**：操作系统会将用户模式下的缓冲区锁住。然后操作系统将这段缓冲区在内核模式地址再次映射一遍。这样，用户模式的缓冲区和内核模式的缓冲区指向的是同一区域的物理内存。缺点就是要单独占用物理页面。 **其他方式读写(在调用IoCreateDevice创建设备后对pDevObj-&gt;Flags即不设置DO_BUFFERED_IO也不设置DO_DIRECT_IO此时就是其他方式)**：在使用其他方式读写设备时，派遣函数直接读写应用程序提供的缓冲区地址。在驱动程序中，直接操作应用程序的缓冲区地址是很危险的。只有驱动程序与应用程序运行在相同线程上下文的情况下，才能使用这种方式。 4、创建符号链接12345//创建符号链接名称RtlInitUnicodeString(&amp;SymbolicLinkName,L&quot;\\\\??\\\\MyTestDriver&quot;);//创建符号链接IoCreateSymbolicLink(&amp;SymbolicLinkName,&amp;Devicename); [!NOTE] 1、设备名称的作用是给内核对象用的，如果要在Ring3访问，必须要有符号链接其实就是一个别名，没有这个别名，在Ring3不可见。 2、内核模式下，符号链接是以“??\\”开头的，如C 盘就是“??\\C:” 3、而在用户模式下，则是以“\\.\\”开头的，如C 盘就是“\\.\\C:“ 5、IRP与派遣函数 在3环会将事件封装澄一个MSG对象，窗口对象接收，然后触发对应的回调函数。 同样在0环也是会将事件封装澄一个IRP对象，设备对象接收，然后触发对应的派遣函数。 6、IRP的类型 IRP类型 来源 作用 IRP_MJ_CREATE CreateFile 打开设备 IRP_MJ_READ ReadFile 设备读取数据 IRP_MJ_WRITE WriteFile 设备写入数据 IRP_MJ_CLOSE CloseHandle 关闭设备 其他类型： IRP类型 来源 IRP_MJ_DEVICE_CONTROL DeviceControl函数会产生此IRP IRP_MJ_POWER 在操作系统处理电源消息时，产生次IRP IRP_MJ_SHUTDOWN 关闭系统前会产生此IRP 7、派遣函数注册位置1234567891011121314151617kd&gt; dt _DRIVER_OBJECTnt!_DRIVER_OBJECT +0x000 Type : Int2B +0x002 Size : Int2B +0x004 DeviceObject : Ptr32 _DEVICE_OBJECT +0x008 Flags : Uint4B +0x00c DriverStart : Ptr32 Void +0x010 DriverSize : Uint4B +0x014 DriverSection : Ptr32 Void +0x018 DriverExtension : Ptr32 _DRIVER_EXTENSION +0x01c DriverName : _UNICODE_STRING +0x024 HardwareDatabase : Ptr32 _UNICODE_STRING +0x028 FastIoDispatch : Ptr32 _FAST_IO_DISPATCH +0x02c DriverInit : Ptr32 long +0x030 DriverStartIo : Ptr32 void +0x034 DriverUnload : Ptr32 void //卸载函数 +0x038 MajorFunction : [28] Ptr32 long //派遣函数 8、注册派遣函数派遣函数种类： 123456789101112131415161718192021222324252627282930#define IRP_MJ_CREATE 0x00#define IRP_MJ_CREATE_NAMED_PIPE 0x01#define IRP_MJ_CLOSE 0x02#define IRP_MJ_READ 0x03#define IRP_MJ_WRITE 0x04#define IRP_MJ_QUERY_INFORMATION 0x05#define IRP_MJ_SET_INFORMATION 0x06#define IRP_MJ_QUERY_EA 0x07#define IRP_MJ_SET_EA 0x08#define IRP_MJ_FLUSH_BUFFERS 0x09#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a#define IRP_MJ_SET_VOLUME_INFORMATION 0x0b#define IRP_MJ_DIRECTORY_CONTROL 0x0c#define IRP_MJ_FILE_SYSTEM_CONTROL 0x0d#define IRP_MJ_DEVICE_CONTROL 0x0e#define IRP_MJ_INTERNAL_DEVICE_CONTROL 0x0f#define IRP_MJ_SHUTDOWN 0x10#define IRP_MJ_LOCK_CONTROL 0x11#define IRP_MJ_CLEANUP 0x12#define IRP_MJ_CREATE_MAILSLOT 0x13#define IRP_MJ_QUERY_SECURITY 0x14#define IRP_MJ_SET_SECURITY 0x15#define IRP_MJ_POWER 0x16#define IRP_MJ_SYSTEM_CONTROL 0x17#define IRP_MJ_DEVICE_CHANGE 0x18#define IRP_MJ_QUERY_QUOTA 0x19#define IRP_MJ_SET_QUOTA 0x1a#define IRP_MJ_PNP 0x1b#define IRP_MJ_PNP_POWER IRP_MJ_PNP // Obsolete....#define IRP_MJ_MAXIMUM_FUNCTION 0x1b 注册派遣函数格式： 123456789101112131415161718NTSTATUS DriverEntry( 。。。。) &#123; //设置卸载函数 pDriverObject-&gt;DriverUnload = 卸载函数; //设置派遣函数 pDriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = 派遣函数1; pDriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = 派遣函数2; pDriverObject-&gt;MajorFunction[IRP_MJ_WRITE] = 派遣函数3; pDriverObject-&gt;MajorFunction[IRP_MJ_READ] = 派遣函数4; pDriverObject-&gt;MajorFunction[IRP_MJ_CLEANUP] = 派遣函数5; pDriverObject-&gt;MajorFunction[IRP_MJ_SET_INFORMATION] = 派遣函数6; pDriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = 派遣函数7; pDriverObject-&gt;MajorFunction[IRP_MJ_SHUTDOWN] = 派遣函数8; pDriverObject-&gt;MajorFunction[IRP_MJ_SYSTEM_CONTROL] = 派遣函数9;&#125; IRP_MJ_MAXIMUM_FUNCTION 派遣函数的最大值 9、派遣函数的格式123456789101112//派遣函数的格式：NTSTATUS MyDispatchFunction(PDEVICE_OBJECT pDevObj, PIRP pIrp)&#123;\t//处理自己的业务...\t//设置返回状态\tpIrp-&gt;IoStatus.Status = STATUS_SUCCESS;\t// getlasterror()得到的就是这个值\tpIrp-&gt;IoStatus.Information = 0; // 返回给3环多少数据 没有填0\tIoCompleteRequest(pIrp, IO_NO_INCREMENT);\treturn STATUS_SUCCESS;&#125; 10、通过IRP_MJ_DEVICE_CONTROL交互数据应用层调用DeviceControl函数会产生此IRP. 代码：Demo代码驱动代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;ntifs.h&gt;#define Deivce_Name L&quot;\\\\Device\\\\hackflame1&quot;#define Symbol_Name L&quot;\\\\??\\\\hackflame1&quot;NTSTATUS dispatchCreate(PDEVICE_OBJECT DeviceObject, PIRP Irp) &#123;\tDbgBreakPoint();\tDbgPrint(&quot;dispatchCreate执行成功 &quot;);\tIrp-&gt;IoStatus.Status = STATUS_SUCCESS;\tIrp-&gt;IoStatus.Information = 0;\tIoCompleteRequest(Irp,IO_NO_INCREMENT);\treturn STATUS_SUCCESS;&#125;NTSTATUS dispatchClose(PDEVICE_OBJECT DeviceObject, PIRP Irp) &#123;\tDbgBreakPoint();\tDbgPrint(&quot;dispatchClose执行成功 &quot;);\tIrp-&gt;IoStatus.Status = STATUS_SUCCESS;\tIrp-&gt;IoStatus.Information = 0;\tIoCompleteRequest(Irp, IO_NO_INCREMENT);\treturn STATUS_SUCCESS;&#125;NTSTATUS dispatchDeviceControl(PDEVICE_OBJECT DeviceObject, PIRP Irp) &#123;\tDbgBreakPoint();\tDbgPrint(&quot;dispatchDeviceControl执行成功 &quot;);\tIrp-&gt;IoStatus.Status = STATUS_SUCCESS;\tIrp-&gt;IoStatus.Information = 0;\tIoCompleteRequest(Irp, IO_NO_INCREMENT);\treturn STATUS_SUCCESS;&#125;VOID DriverUnload(PDRIVER_OBJECT pDriver)&#123;\tUNICODE_STRING symName;\tRtlInitUnicodeString(&amp;symName, Symbol_Name);\tIoDeleteSymbolicLink(&amp;symName);\tif (pDriver-&gt;DeviceObject) IoDeleteDevice(pDriver-&gt;DeviceObject);\tDbgPrintEx(77, 0, &quot;驱动卸载完成&quot;);&#125;NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg)&#123;\tUNICODE_STRING deviceName = &#123; 0 &#125;;\tUNICODE_STRING symName = &#123; 0 &#125;;\tRtlInitUnicodeString(&amp;deviceName, Deivce_Name);\tRtlInitUnicodeString(&amp;symName, Symbol_Name);\tPDEVICE_OBJECT pDevice = NULL; //这里是设备类型 PDEVICE_OBJECT 不是 PDRIVER_OBJECT\tNTSTATUS status = IoCreateDevice(pDriver, 0, &amp;deviceName, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &amp;pDevice);\tif (!NT_SUCCESS(status))\t&#123; KdPrintEx((77, 0, &quot;[db]:%x\\r &quot;, status)); return status;\t&#125;\tstatus = IoCreateSymbolicLink(&amp;symName, &amp;deviceName);\tif (!NT_SUCCESS(status))\t&#123; IoDeleteDevice(pDriverObj); KdPrintEx((77, 0, &quot;[db]:%x\\r &quot;, status)); return status;\t&#125;\tpDevice-&gt;Flags &amp;= ~DO_DEVICE_INITIALIZING;\tpDevice-&gt;Flags |= DO_BUFFERED_IO;\tpDriver-&gt;MajorFunction[IRP_MJ_CREATE] = dispatchCreate;\tpDriver-&gt;MajorFunction[IRP_MJ_CLOSE] = dispatchClose;\tpDriver-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = dispatchDeviceControl;\tpDriver-&gt;DriverUnload = DriverUnload;\treturn status;&#125; 3环代码： 12345678910111213141516#include &lt;iostream&gt;#include&lt;windows.h&gt;#include&lt;winioctl.h&gt;int main()&#123; HANDLE hfile = CreateFileA(&quot;\\\\\\\\.\\\\hackflame1&quot;, GENERIC_READ | GENERIC_WRITE,0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,0); DWORD status = GetLastError(); if (!hfile) &#123; printf(&quot;status:%d &quot;, status); system(&quot;pause&quot;); return 0; &#125; printf(&quot;status:%d &quot;, status); CloseHandle(hfile);&#125; 驱动通信案例代码驱动代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;ntifs.h&gt;#define OPER CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)#define Deivce_Name L&quot;\\\\Device\\\\hackflame1&quot;#define Symbol_Name L&quot;\\\\??\\\\hackflame1&quot;NTSTATUS dispatchCreate(PDEVICE_OBJECT DeviceObject, PIRP Irp) &#123;\tDbgPrint(&quot;dispatchCreate执行成功 &quot;);\tIrp-&gt;IoStatus.Status = STATUS_SUCCESS;\tIrp-&gt;IoStatus.Information = 0;\tIoCompleteRequest(Irp,IO_NO_INCREMENT);\treturn STATUS_SUCCESS;&#125;NTSTATUS dispatchClose(PDEVICE_OBJECT DeviceObject, PIRP Irp) &#123;\tDbgPrint(&quot;dispatchClose执行成功 &quot;);\tIrp-&gt;IoStatus.Status = STATUS_SUCCESS;\tIrp-&gt;IoStatus.Information = 0;\tIoCompleteRequest(Irp, IO_NO_INCREMENT);\treturn STATUS_SUCCESS;&#125;NTSTATUS dispatchDeviceControl(PDEVICE_OBJECT DeviceObject, PIRP Irp) &#123;\tDbgBreakPoint();\tDbgPrint(&quot;dispatchDeviceControl执行成功 &quot;);\tULONG uRead, uWrite;\tNTSTATUS retStatus = NULL;\t//拿到当前设备的堆栈\tPIO_STACK_LOCATION pCurrentStack = IoGetCurrentIrpStackLocation(Irp);\t//获取操作码\tULONG code = pCurrentStack-&gt;Parameters.DeviceIoControl.IoControlCode; //获取缓冲区\tPVOID pIoBuffer = Irp-&gt;AssociatedIrp.SystemBuffer;\t//判断操作码是否是对应的\tswitch (code)\t&#123;\tcase OPER: //从3环向0环写 memcpy(&amp;uRead,pIoBuffer,4); DbgPrint(&quot;uRead: %x &quot;, uRead); //从0环向3环写 uWrite = 0x123456; memcpy(pIoBuffer, &amp;uWrite, 4); Irp-&gt;IoStatus.Information = 4; retStatus = STATUS_SUCCESS; break;\tdefault: break;\t&#125;\tIrp-&gt;IoStatus.Status = retStatus == STATUS_SUCCESS ? retStatus : STATUS_SUCCESS;\tIoCompleteRequest(Irp, IO_NO_INCREMENT);\treturn STATUS_SUCCESS;&#125;VOID DriverUnload(PDRIVER_OBJECT pDriver)&#123;\tUNICODE_STRING symName;\tRtlInitUnicodeString(&amp;symName, Symbol_Name);\tIoDeleteSymbolicLink(&amp;symName);\tif (pDriver-&gt;DeviceObject) IoDeleteDevice(pDriver-&gt;DeviceObject);\tDbgPrintEx(77, 0, &quot;驱动卸载完成&quot;);&#125;NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg)&#123;\tUNICODE_STRING deviceName = &#123; 0 &#125;;\tUNICODE_STRING symName = &#123; 0 &#125;;\tRtlInitUnicodeString(&amp;deviceName, Deivce_Name);\tRtlInitUnicodeString(&amp;symName, Symbol_Name);\tPDEVICE_OBJECT pDevice = NULL; //这里是设备类型 PDEVICE_OBJECT 不是 PDRIVER_OBJECT\tNTSTATUS status = IoCreateDevice(pDriver, 0, &amp;deviceName, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &amp;pDevice);\tif (!NT_SUCCESS(status))\t&#123; KdPrintEx((77, 0, &quot;[db]:%x\\r &quot;, status)); return status;\t&#125;\tstatus = IoCreateSymbolicLink(&amp;symName, &amp;deviceName);\tif (!NT_SUCCESS(status))\t&#123; IoDeleteDevice(pDevice); KdPrintEx((77, 0, &quot;[db]:%x\\r &quot;, status)); return status;\t&#125;\tpDevice-&gt;Flags &amp;= ~DO_DEVICE_INITIALIZING;\tpDevice-&gt;Flags |= DO_BUFFERED_IO;\tpDriver-&gt;MajorFunction[IRP_MJ_CREATE] = dispatchCreate;\tpDriver-&gt;MajorFunction[IRP_MJ_CLOSE] = dispatchClose;\tpDriver-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = dispatchDeviceControl;\tpDriver-&gt;DriverUnload = DriverUnload;\treturn status;&#125; 三环代码： 1234567891011121314151617181920212223242526272829303132333435363738// demoR3.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include&lt;windows.h&gt;#include&lt;winioctl.h&gt;#define OPER CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)HANDLE g_hDevice;int main()&#123; HANDLE g_hDevice = CreateFileA(&quot;\\\\\\\\.\\\\hackflame1&quot;, GENERIC_READ | GENERIC_WRITE,0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,0); DWORD code = GetLastError(); if (code != 0) &#123; printf(&quot;status:%d &quot;, code); system(&quot;pause&quot;); return 0; &#125; LPVOID inBuffer , outBuffer; inBuffer = (LPVOID)0x223456; DWORD size = 4; DWORD dwLen; //向0环写入数据 /* _In_ HANDLE hDevice,\t_In_ DWORD dwIoControlCode,\t_In_reads_bytes_opt_(nInBufferSize) LPVOID lpInBuffer,\t_In_ DWORD nInBufferSize,\t_Out_writes_bytes_to_opt_(nOutBufferSize,*lpBytesReturned) LPVOID lpOutBuffer,\t_In_ DWORD nOutBufferSize,\t_Out_opt_ LPDWORD lpBytesReturned,\t_Inout_opt_ LPOVERLAPPED lpOverlapped */ DeviceIoControl(g_hDevice, OPER,&amp;inBuffer,0x10,&amp;outBuffer,0x10,&amp;dwLen,NULL); printf(&quot;outBuffer:%x &quot;, outBuffer); CloseHandle(g_hDevice); return 0;&#125;","tags":["滴水中级","win内核"],"categories":["逆向"]},{"title":"windbg常用命令","path":"/p/86acdf67/","content":"二：常见非托管命令1.工具和系统级别类 .restart &#x2F;&#x2F; 重启并调试 .kill &#x2F;&#x2F; 强制结束当前调试 q &#x2F;&#x2F; 结束当前调试会话，回到基础工作空间，并结束调试进程 qd &#x2F;&#x2F; 结束当前调试会话，回到基础工作空间，但不结束调试进程 vertarget &#x2F;&#x2F; os信息 !cpuid &#x2F;&#x2F; cpu信息 .time &#x2F;&#x2F; 获取dump抓取时间 ? &#x2F;&#x2F; 打印出所有标准命令 .help &#x2F;&#x2F; 打印出所有元命令 .hh &#x2F;&#x2F; 打开windbg的chm帮助文件 .cls &#x2F;&#x2F; 清空控制台 !analyze -v &#x2F;&#x2F; 对内存转储文件进行分析，并显示详细的结果 2.进程和线程类 | &#x2F;&#x2F; 列出调试进程 |* &#x2F;&#x2F; 列出调试进程 ~ &#x2F;&#x2F; 列出线程 ~* &#x2F;&#x2F; 所有线程 ~* k &#x2F;&#x2F; 所有线程堆栈信息 ~* r &#x2F;&#x2F; 所有线程寄存器信息 ~. &#x2F;&#x2F; 查看当前线程 ~0s &#x2F;&#x2F; 查看主线程 ~N &#x2F;&#x2F; 查看序数为N的线程 ~~[n] &#x2F;&#x2F; 查看线程ID为n的线程 ~N f &#x2F;&#x2F; 冻结序数为N的线程 ~N u &#x2F;&#x2F; 解冻序数为N的线程 ~N n &#x2F;&#x2F; Suspend序数为N的线程 ~N m &#x2F;&#x2F; Resume序数为N的线程 ~* e !gle &#x2F;&#x2F; 显示所有线程最后的一个错误信息 e后可以为任意windbg命令 !runaway &#x2F;&#x2F;显示当前进程的所有线程时间信息 3. 断点类 bl &#x2F;&#x2F; 列出所有断点 bc * &#x2F;&#x2F; 清除所有断点 bc 1 &#x2F;&#x2F; 清除1号断点 bc 1 2 5 &#x2F;&#x2F; 清除1号、2号、5号断点 be * &#x2F;&#x2F; 启用所有断点 be 1 &#x2F;&#x2F; 启用1号断点 bd * &#x2F;&#x2F; 禁用所有断点 bd 1 &#x2F;&#x2F; 禁用1号断点 bp bc701a00 &#x2F;&#x2F; 在bc701a00地址处放置一个断点 bp Test.cpp:36 &#x2F;&#x2F; 在Test.cpp的36行处放置一个断点 bp main &#x2F;&#x2F; 在main函数的起始处放置一个断点 bp Test.cpp:40 “.if (poi(pVar)&gt;5) {}; {g}” &#x2F;&#x2F; “.if (Condition) {Optional Commands}; {g}” &#x2F;&#x2F; 条件断点 pVar指针指向的值&gt;5，执行空语句（;），断住 否则继续执行 4. 调试控制类 g &#x2F;&#x2F; Go(F5) gN &#x2F;&#x2F;【Go with Exception Not Handled】执行gN命令强制让调试器返回没有处理了这个异常，那么系统会进一步分发该异常， gu &#x2F;&#x2F; 执行到当前函数完成时停下 【Go Up】 Ctrl+Break &#x2F;&#x2F; 暂停正在运行的程序 p &#x2F;&#x2F; 单步执行(F10) 【Step】 p 2 &#x2F;&#x2F; 2为步进数目 pc &#x2F;&#x2F; 执行到下一个函数调用处停下 【Step to Next　Call】 pa 7c801b0b &#x2F;&#x2F; 执行到7c801b0b地址处停下 【Step to Adress】 t &#x2F;&#x2F; Step into(F11)　【Trace】 tc &#x2F;&#x2F; 执行到下一个进入点处停下　【Trace to Next Call】 ta 7c801b12 &#x2F;&#x2F; 执行到7c801b12地址处停下 【Trace to Adress】 5. 查看句柄类 !handle &#x2F;&#x2F; 查看所有句柄的ID !handle 000007f8 1 &#x2F;&#x2F; 查看ID为000007f8的句柄的类型 !handle 000007f8 4 &#x2F;&#x2F; 查看ID为000007f8的句柄的名称 !handle 0 5 &#x2F;&#x2F; 查看所有句柄的类型和名称 6. 线程栈类 kb 5 &#x2F;&#x2F; 只显示最上的5层调用堆栈 kv &#x2F;&#x2F; 在kb的基础上增加了函数调用约定等信息 kp &#x2F;&#x2F; 显示每一层函数调用的完整参数，包括参数类型、名字、取值（必须是完整符号的情况下，private symbols）；注意：若程序被优化，这些值不一定对 kd &#x2F;&#x2F; 打印堆栈的地址 .frame &#x2F;&#x2F; 显示当前栈帧 .frame n &#x2F;&#x2F; 设置编号n的栈帧为当前栈帧（n为16进制数） .frame &#x2F;r n &#x2F;&#x2F; 设置编号n的栈帧为当前栈帧（n为16进制数） 并显示寄存器变量 !uniqstack &#x2F;&#x2F; 显示所有线程的调用堆栈 7. 汇编和寄存器类 u . &#x2F;&#x2F; 反汇编当前ip寄存器地址的后8条指令 u $ip &#x2F;&#x2F; 反汇编当前ip寄存器地址的后8条指令 ub . &#x2F;&#x2F; 反汇编当前ip寄存器地址的前8条指令 ub $ip &#x2F;&#x2F; 反汇编当前ip寄存器地址的前8条指令 u main+0x29 L30 &#x2F;&#x2F; 反汇编main+0x29地址的后30条指令 u &#x2F;&#x2F; 反编译下8条指令 uf CTest::add &#x2F;&#x2F; 反汇编CTest类的add函数 uf &#x2F;c main &#x2F;&#x2F; 反汇编main函数，通过&#x2F;c可以查看main函数中的函数调用(call)都有哪些 ub 000c135d L20 &#x2F;&#x2F; 查看地址为000c135d指令前的20条指令内容 r &#x2F;&#x2F; 显示所有寄存器信息及发生core所在的指令 r eax, edx &#x2F;&#x2F; 显示eax，edx寄存器信息 r eax&#x3D;5, edx&#x3D;6 &#x2F;&#x2F; 对寄存器eax赋值为5，edx赋值为6 6. 地址和进制表示类 dt &#x2F;&#x2F; 显示数据结构信息，可以用来查看特定内存地址处的数据结构。 hi(x) &#x2F;&#x2F; 高16 bits low(x) &#x2F;&#x2F; 低16 bits by(x) &#x2F;&#x2F; 返回第一个byte wo(x) &#x2F;&#x2F; 返回第一个word dwo(x) &#x2F;&#x2F; 返回第一个dword qwo(x) &#x2F;&#x2F; 返回第一个4 word(Quad-word) poi(x) &#x2F;&#x2F; 返回第一个指针所指向的值 0n（十进制） 0x (十六进制）0t (8进制) 0y (2进制) 7. 符号模块 .sympath &#x2F;&#x2F; 查看当前符号查找路径 .sympath SRVC:\\mysymbolshttp://msdl.microsoft.com/download/symbols &#x2F;&#x2F; 设置本地和远程的符号路径 !sym noisy &#x2F;&#x2F; 激活详细符号加载(noisy symbol loading)显示 .reload &#x2F;&#x2F; 为所有已加载模块载入符号信息 ld * &#x2F;&#x2F; 为所有模块加载符号 ld kernel32 &#x2F;&#x2F; 加载kernel32.dll的符号 lm &#x2F;&#x2F; 列出所有模块（加载和未加载）对应的符号信息 lmv &#x2F;&#x2F; 列出所有模块（加载和未加载）对应的符号信息 二：常见托管命令1. 常用命令 !threadpool &#x2F;&#x2F; 查看线程池CPU使用量 !threads &#x2F;&#x2F; 查看所有托管线程情况 !clrstack &#x2F;&#x2F; 某个线程托管代码的调用栈情况 ~*e!clrstack &#x2F;&#x2F; 所有线程托管代码的调用栈情况 !runaway &#x2F;&#x2F; 查看线程占用CPU时间 !dumpstackobjects（!dso） &#x2F;&#x2F; 本线程调用栈所有对象实例 !dumpdomain &#x2F;&#x2F; 显示所有域里的程序集，或者根据参数获取指定域。 !savemodule &#x2F;&#x2F; 根据具体程序集地址，把当前程序集的代码生成到指定文件 !PrintException（!pe） &#x2F;&#x2F; 显示在当前线程上引发的最后一个异常错误信息 !VerifyHeap &#x2F;&#x2F; 检查垃圾回收器堆中是否有损坏迹象，并显示找到任何错误 !syncblk &#x2F;&#x2F; 显示同步块表信息 2.查看内存 !eeheap -gc &#x2F;&#x2F; 查看GC堆,查看GC堆上的内存占用是多大 !eeheap –loader &#x2F;&#x2F; 查看Loader堆 !dumpheap –stat &#x2F;&#x2F; GC堆上的统计,看GC堆上存活的对象是那些 !dumpheap -mt 000c135d &#x2F;&#x2F; 查看托管堆上的此class的实例详细列表 !dumpheap –type 000c135d &#x2F;&#x2F; 在托管堆上模糊搜索类名 !gcroot 000c135d &#x2F;&#x2F; 得到这个对象的引用”根” !objsize 000c135d &#x2F;&#x2F; 查看对象占用多大的内存 !name2ee TestClass.exeTestClass.Program.test &#x2F;&#x2F; 显示test方法信息 !dumpmt -md 00976d48 &#x2F;&#x2F; 得到类的成员函数详细信息 !dumpmt xxx &#x2F;&#x2F; 找到相关MethodTable处的有关信息 !dumpmd xxx &#x2F;&#x2F; 根据MethodDesc找到相关模块信息，比如MethodTable. !dumpdomain &#x2F;&#x2F; 显示所有域里的程序集，或者根据参数获取指定域。 !dumpil 00973028 &#x2F;&#x2F; 显示这个方法被编译器编译之后的IL代码 !dumpmodule 1ee30010 &#x2F;&#x2F; 查看某个模块的详细信息 !finalizeQueue &#x2F;&#x2F; 显示为终结(finalization)而登记的所有对象。 三：所有命令参考： 中文版：https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debuggercmds/commands 英文版：windbg 中使用 .hh 命令调出 xxx.chm 的帮助文档","tags":["windbg"],"categories":["逆向"]},{"title":"PHP代码审计环境调试坑点汇总","path":"/p/7a303294/","content":"代码审计环境搭建注意细节1 php.ini参数问题：💡 1.在php版本小于5.3时，php.ini里面配置xdebug需要先关闭ZendOptimizer和ZendDebugger，在参数方面注意的细节就是php5.3之后使用该zend_extension参数，php5.3之前则使用zend_extension_ts参数。 具体示例如下： 12345678910111213141516171819;php5.2如要启用Xdebug要先关闭ZendOptimizer和ZendDebuggerxdebug.profiler_append = 0xdebug.profiler_enable = 1xdebug.profiler_enable_trigger = 0xdebug.profiler_output_dir = &quot;../tmp&quot;xdebug.trace_output_dir = &quot;../tmp&quot;xdebug.profiler_output_name = &quot;cache.out.%t-%s&quot;xdebug.remote_enable = 1xdebug.remote_autostart = 1xdebug.remote_handler = &quot;dbgp&quot;xdebug.remote_host = &quot;127.0.0.1&quot;xdebug.remote_port = 9000xdebug.idekey = PHPSTORMzend_extension_ts=&quot;你的PHPstudy路径\\PhpStudy\\PHPTutorial\\php\\php-5.2.17\\ext\\xdebug.dll&quot;[ZendDebugger];全部删除或者注释掉[Zend];仅保留下面这一行xdebug.zend_extension_ts=&quot;你的PHPstudy路径\\PhpStudy\\PHPTutorial\\php\\php-5.2.17\\ext\\xdebug.dll&quot; 注意：因为ctrl+shift+f已经被占用了，如果有输入法的话就打不开，尤其是win10自带的中文输入法，ctrl+shift+f是简繁体的转化。要打开英文的原装输入法才行。再按ctrl+shift+f就能够打开全局搜索了。 2 IDEA debug断点调试常用快捷键F8：Step Over 跳过，一行一行的向下走，如果当前行有方法不进入方法。&#96; F7：Step Into 跳入，如果当前有方法，进入方法内部，一般用于进入自定义的方法，不会jdk类库的方法。 F9：跳到下一个断点处。 Shift+ F8：Step Out 跳出，从跳入的方法内退出到方法调用处，这个时候方法已经执行完毕，只是还没有完成赋值 Alt+ F8：Evaluate Expression,计算表达式的值。 Alt+ F9：Run to Cursor:运行到光标处，你可以将光标定位到你需要查看的行，然后使用这个功能，代码会运行到光标处，不需要打断点 Alt+ F10：Show Exception Point:如果你的光标在其它行或者其它的页面，点击这个按钮可跳转到当前代码执行的行","tags":["PHP","调试","debug"],"categories":["代码审计"]},{"title":"MVC设计模式-1","path":"/p/988d33e4/","content":"1 MVC介绍1、MVC是一个编程思想，是一种设计模式 2、思想：将一个功能分解成3个部分，M V C Model（模型）:处理与数据有关的逻辑 View（视图）:显示页面 Controller（控制器）:处理业务逻辑 小结： 1、控制器用来接收请求 2、以后不能直接请求模型和视图 2 MVC演化2.1 显示商品1、导入products表的数据 2、将上一讲的MyPDO类拷贝到站点下，改名为MyPDO.class.php，这个文件中只存放MyPDO类 3、在站点下创建index.php，代码如下 12345678910111213141516171819202122232425262728293031323334353637&lt;?php//自动加载类spl_autoload_register(function($class_name)&#123; require &quot;./&#123;$class_name&#125;.class.php&quot;;&#125;);//连接数据库$param=array( &#x27;user&#x27; =&gt; &#x27;root&#x27;, &#x27;pwd&#x27; =&gt; &#x27;root&#x27;);$mypdo= MyPDO::getInstance($param);//获取商品数据$list=$mypdo-&gt;fetchAll(&#x27;select * from products&#x27;);?&gt;&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=&#x27;1&#x27; width=&#x27;980&#x27; bordercolor=&#x27;#000&#x27;&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;删除&lt;/th&gt; &lt;/tr&gt; &lt;?php foreach($list as $rows):?&gt; &lt;tr&gt; &lt;td&gt;&lt;?=$rows[&#x27;proID&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$rows[&#x27;proname&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$rows[&#x27;proprice&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;?php endforeach;?&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 2.2 演化一：分离视图1、创建products_list.html页面（视图页面）,将显示部分的代码拷贝到视图页面上 1234567891011121314151617181920212223&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=&#x27;1&#x27; width=&#x27;980&#x27; bordercolor=&#x27;#000&#x27;&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;删除&lt;/th&gt; &lt;/tr&gt; &lt;?php foreach($list as $rows):?&gt; &lt;tr&gt; &lt;td&gt;&lt;?=$rows[&#x27;proID&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$rows[&#x27;proname&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$rows[&#x27;proprice&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;?php endforeach;?&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 2、在index.php页面上加载视图 123456789101112131415&lt;?php//自动加载类spl_autoload_register(function($class_name)&#123; require &quot;./&#123;$class_name&#125;.class.php&quot;;&#125;);//连接数据库$param=array( &#x27;user&#x27; =&gt; &#x27;root&#x27;, &#x27;pwd&#x27; =&gt; &#x27;root&#x27;);$mypdo= MyPDO::getInstance($param);//获取商品数据$list=$mypdo-&gt;fetchAll(&#x27;select * from products&#x27;);//加载视图require &#x27;./products_list.html&#x27;; 2.3 演化二：分离模型模型的规则 1、一个表对应一个模型，表名和模型名一致（必须的） 2、模型以Model结尾（不是必须的） 代码实现: 1、在站点下创建ProductsModel.class.php页面 123456789101112131415&lt;?php//products模型用来操作products表class ProductsModel &#123; //获取products表的数据 public function getList() &#123; //连接数据库 $param=array( &#x27;user&#x27; =&gt; &#x27;root&#x27;, &#x27;pwd&#x27; =&gt; &#x27;root&#x27; ); $mypdo= MyPDO::getInstance($param); //获取商品数据 return $mypdo-&gt;fetchAll(&#x27;select * from products&#x27;); &#125;&#125; 2、在index.php页面中调用模型的getList() 12345678910&lt;?php//自动加载类spl_autoload_register(function($class_name)&#123; require &quot;./&#123;$class_name&#125;.class.php&quot;;&#125;);//实例化模型$model=new ProductsModel();$list=$model-&gt;getList();//加载视图require &#x27;./products_list.html&#x27;; 2.4 演化三：分离基础模型连接数据库的代码每个模型都要使用，所有我们需要将连接数据库的代码封装到基础模型类中（Model） 第一步：在站点下创建Model.class.php页面（基础模型） 12345678910111213141516&lt;?php//基础模型class Model &#123; protected $mypdo; public function __construct() &#123; $this-&gt;initMyPDO(); &#125; //连接数据库 private function initMyPDO() &#123; $param=array( &#x27;user&#x27; =&gt; &#x27;root&#x27;, &#x27;pwd&#x27; =&gt; &#x27;root&#x27; ); $this-&gt;mypdo= MyPDO::getInstance($param); &#125;&#125; 第二步：ProductsModel继承基础模型类 12345678&lt;?php//products模型用来操作products表class ProductsModel extends Model&#123; //获取products表的数据 public function getList() &#123; return $this-&gt;mypdo-&gt;fetchAll(&#x27;select * from products&#x27;); &#125;&#125; 2.5 演化四：分离控制器控制器代码放在index.php页面中是不合理的，因为项目中的控制器会很多，而index.php只有一个。所以需要将控制器分离开来 控制器的规则： 1、一个模块对应一个控制器（必须的） 2、控制器以Controller结尾（不是必须的） 3、控制器中的方法以Action结尾（不是必须的）,目的防止方法名是PHP关键字 创建ProductsController.class.php 123456789101112&lt;?php//商品模块class ProductsController &#123; //获取商品列表 public function listAction() &#123; //实例化模型 $model=new ProductsModel(); $list=$model-&gt;getList(); //加载视图 require &#x27;./products_list.html&#x27;; &#125;&#125; index.php页面 123456789101112131415&lt;?php//自动加载类spl_autoload_register(function($class_name)&#123; require &quot;./&#123;$class_name&#125;.class.php&quot;;&#125;);//确定路由$c=$_GET[&#x27;c&#x27;]??&#x27;Products&#x27;; //控制器$a=$_GET[&#x27;a&#x27;]??&#x27;list&#x27;; //方法$c=ucfirst(strtolower($c)); //首字母大写$a=strtolower($a); //转成小写$controller_name=$c.&#x27;Controller&#x27;; //拼接控制器类名$action_name=$a.&#x27;Action&#x27;; //拼接方法名//请求分发$obj=new $controller_name();$obj-&gt;$action_name(); a：方法 c：控制器 通过在url地址上传递参数来寻址。 3 删除商品小结： 注意：每次请求都要从index.php进入。所以index.php又叫入口文件。 入口(products_list.html) 12&lt;td&gt;&lt;a href=&quot;index.php?c=Products&amp;a=del&amp;proid=&lt;?=$rows[&#x27;proID&#x27;]?&gt;&quot; onclick=&quot;return confirm(&#x27;确定要删除吗&#x27;)&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; 控制器（ProductsController） 1234567891011121314151617&lt;?php//商品模块class ProductsController &#123;\t..\t//删除商品\tpublic function delAction() &#123; $id=(int)$_GET[&#x27;proid&#x27;];\t//如果参数明确是整数，要强制转成整形 $model=new ProductsModel(); if($model-&gt;del($id)) header(&#x27;location:index.php?c=Products&amp;a=list&#x27;); else &#123; echo &#x27;删除失败&#x27;; exit; &#125;\t&#125;&#125; 模型（ProductsModel） 12345678910&lt;?php//products模型用来操作products表class ProductsModel extends Model&#123;\t...\t//删除商品\tpublic function del($proid) &#123; return $this-&gt;mypdo-&gt;exec(&quot;delete from products where proid=$proid&quot;);\t&#125;&#125;","tags":["PHP"],"categories":["Language"]},{"title":"MVC设计模式-2","path":"/p/184625e/","content":"1 框架目录1.1 创建目录结构 1.2 文件分类存放 将文件存放到不同的目录以后，由于类文件地址发生了变化，所以无法完成自动加载类，那么今天的主要任务就是围绕如何实现类的自动加载展开。 由于每次都请求入口文件，所以”.“表示入口文件所在的目录 2 添加命名空间通过文件目录地址做命名空间，这样获取了命名空间就能知道文件存放的地址。 Model.class.php 123namespace Core;class Model &#123; ... MyPDO.class.php 123namespace Core;class MyPDO&#123; ... ProductsModel.class.php 12345&lt;?phpnamespace Model;//products模型用来操作products表class ProductsModel extends Model&#123; ... ProductsController.class.php 12345&lt;?phpnamespace Controller\\Admin;//商品模块class ProductsController &#123; ... 3 框架类实现3.1 定义路径常量由于文件路径使用频率很高，而且路径比较长，所以将固定不变的路径定义成路径常量 知识点 121、getcwd()：入口文件的绝对路径2、windows下默认的目录分隔符是`\\`，Linux下默认的目录分隔符是`/`。DIRECTORY_SEPARATOR常量根据不同的操作系统返回不同的目录分隔符。 代码实现 在Core文件夹下创建Framework.class.php 12345678910111213private static function initConst()&#123; define(&#x27;DS&#x27;, DIRECTORY_SEPARATOR); //定义目录分隔符 define(&#x27;ROOT_PATH&#x27;, getcwd().DS); //入口文件所在的目录 define(&#x27;APP_PATH&#x27;, ROOT_PATH.&#x27;Application&#x27;.DS); //application目录 define(&#x27;CONFIG_PATH&#x27;, APP_PATH.&#x27;Config&#x27;.DS); define(&#x27;CONTROLLER_PATH&#x27;, APP_PATH.&#x27;Controller&#x27;.DS); define(&#x27;MODEL_PATH&#x27;, APP_PATH.&#x27;Model&#x27;.DS); define(&#x27;VIEW_PATH&#x27;, APP_PATH.&#x27;View&#x27;.DS); define(&#x27;FRAMEWORK_PATH&#x27;, ROOT_PATH.&#x27;Framework&#x27;.DS); define(&#x27;CORE_PATH&#x27;, FRAMEWORK_PATH.&#x27;Core&#x27;.DS); define(&#x27;LIB_PATH&#x27;, FRAMEWORK_PATH.&#x27;Lib&#x27;.DS); define(&#x27;TRAITS_PATH&#x27;, ROOT_PATH.&#x27;Traits&#x27;.DS);&#125; 3.2 引入配置文件1、在config目录下创建config.php 1234567891011&lt;?phpreturn array( //数据库配置 &#x27;database&#x27;=&gt;array(), //应用程序配置 &#x27;app&#x27; =&gt;array( &#x27;dp&#x27; =&gt; &#x27;Admin&#x27;, //默认平台 &#x27;dc&#x27; =&gt; &#x27;Products&#x27;, //默认控制器 &#x27;da&#x27; =&gt; &#x27;list&#x27; //默认方法 ),); 2、在框架类中引入配置文件 123private static function initConfig()&#123; $GLOBALS[&#x27;config&#x27;]=require CONFIG_PATH.&#x27;config.php&#x27;;&#125; 思考：配置文件为什么不保存在常量中？ 答：因为7.0之前，常量不能保存数组和对象。 3.3 确定路由p：【platform】平台 c：【controller】控制器 a：【action】方法 12345678910111213private static function initRoutes()&#123; $p=$_GET[&#x27;p&#x27;]??$GLOBALS[&#x27;config&#x27;][&#x27;app&#x27;][&#x27;dp&#x27;]; $c=$_GET[&#x27;c&#x27;]??$GLOBALS[&#x27;config&#x27;][&#x27;app&#x27;][&#x27;dc&#x27;]; $a=$_GET[&#x27;a&#x27;]??$GLOBALS[&#x27;config&#x27;][&#x27;app&#x27;][&#x27;da&#x27;]; $p=ucfirst(strtolower($p)); $c=ucfirst(strtolower($c)); //首字母大写 $a=strtolower($a); //转成小写 define(&#x27;PLATFROM_NAME&#x27;, $p); //平台名常量 define(&#x27;CONTROLLER_NAME&#x27;, $c); //控制器名常量 define(&#x27;ACTION_NAME&#x27;, $a); //方法名常量 define(&#x27;__URL__&#x27;, CONTROLLER_PATH.$p.DS); //当前请求控制器的目录地址 define(&#x27;__VIEW__&#x27;,VIEW_PATH.$p.DS); //当前视图的目录地址&#125; 3.4 自动加载类12345678910111213141516private static function initAutoLoad()&#123; spl_autoload_register(function($class_name)&#123; $namespace= dirname($class_name); //命名空间 $class_name= basename($class_name); //类名 if(in_array($namespace, array(&#x27;Core&#x27;,&#x27;Lib&#x27;))) //命名空间在Core和Lib下 $path= FRAMEWORK_PATH.$namespace.DS.$class_name.&#x27;.class.php&#x27;; elseif($namespace==&#x27;Model&#x27;) //文件在Model下 $path=MODEL_PATH.$class_name.&#x27;.class.php&#x27;; elseif($namespace==&#x27;Traits&#x27;) //文件在Traits下 $path=TRAITS_PATH.$class_name.&#x27;.class.php&#x27;; else //控制器 $path=CONTROLLER_PATH.PLATFROM_NAME.DS.$class_name.&#x27;.class.php&#x27;; if(file_exists($path) &amp;&amp; is_file($path)) require $path; &#125;);&#125; 3.5 请求分发123456private static function initDispatch()&#123; $controller_name=&#x27;\\Controller\\\\&#x27;.PLATFROM_NAME.&#x27;\\\\&#x27;.CONTROLLER_NAME.&#x27;Controller&#x27;;\t//拼接控制器类名 $action_name=ACTION_NAME.&#x27;Action&#x27;;\t//拼接方法名 $obj=new $controller_name(); $obj-&gt;$action_name();&#125; 3.6 封装run()方法12345678910class Framework&#123; //启动框架 public static function run()&#123; self::initConst(); self::initConfig(); self::initRoutes(); self::initAutoLoad(); self::initDispatch(); &#125; ... 3.7 在入口中调用run()方法123&lt;?phprequire &#x27;./Framework/Core/Framework.class.php&#x27;;Framework::run(); run()方法调用后就启动了框架 4 运行项目1、连接数据库的参数从配置文件中获取 1234567class Model &#123; ... //连接数据库 private function initMyPDO() &#123; $this-&gt;mypdo= MyPDO::getInstance($GLOBALS[&#x27;config&#x27;][&#x27;database&#x27;]); &#125;&#125; 2、更改ProductsControleller控制器 12345678910111213141516171819&lt;?phpnamespace Controller\\Admin;//商品模块class ProductsController &#123; //获取商品列表 public function listAction() &#123; //实例化模型 $model=new \\Model\\ProductsModel(); $list=$model-&gt;getList(); //加载视图 require __VIEW__.&#x27;products_list.html&#x27;; &#125; //删除商品 public function delAction() &#123; ... $model=new \\Model\\ProductsModel(); ... &#125;&#125; 3、更改ProductsModel类 12345&lt;?phpnamespace Model;class ProductsModel extends \\Core\\Model&#123;&#125; 4、更改MyPDO类 123456789101112131415...private function fetchType($type)&#123; switch ($type)&#123; case &#x27;num&#x27;: return \\PDO::FETCH_NUM; case &#x27;both&#x27;: return \\PDO::FETCH_BOTH; case &#x27;obj&#x27;: return \\PDO::FETCH_OBJ; default: return \\PDO::FETCH_ASSOC; &#125;&#125;...//所有的内置类都在公共的命名空间下。 测试：成功 5 traits代码复用有的控制器操作完毕后要跳转，有的不需要， 解决：将跳转的方法封装到traits中。 代码实现 1、将准备好的图片拷贝到Public目录下 2、在Traits目录中创建Jump.class.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?php//跳转的插件namespace Traits;trait Jump&#123; //封装成功的跳转 public function success($url,$info=&#x27;&#x27;,$time=1)&#123; $this-&gt;redirect($url, $info, $time, &#x27;success&#x27;); &#125; //封装失败跳转 public function error($url,$info=&#x27;&#x27;,$time=3)&#123; $this-&gt;redirect($url, $info, $time, &#x27;error&#x27;); &#125; /* * 作用：跳转的方法 * @param $url string 跳转的地址 * @param $info string 显示信息 * @param $time int 停留时间 * @param $flag string 显示模式 success|error */ private function redirect($url,$info,$time,$flag)&#123; if($info==&#x27;&#x27;) header (&quot;location:&#123;$url&#125;&quot;); else&#123; echo &lt;&lt;&lt;str&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;!-- &lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;http://www.php.com&quot;/&gt; --&gt; &lt;title&gt;Document&lt;/title&gt;&lt;style&gt;body&#123; text-align: center; font-family: &#x27;微软雅黑&#x27;; font-size: 18px;&#125;#success,#error&#123; font-size: 36px; margin: 10px auto;&#125;#success&#123; color: #090;&#125;#error&#123; color: #F00;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=&quot;/Public/images/&#123;$flag&#125;.fw.png&quot;&gt; &lt;div id=&#x27;&#123;$flag&#125;&#x27;&gt;&#123;$info&#125;&lt;/div&gt; &lt;div&gt;&lt;span id=&#x27;t&#x27;&gt;&#123;$time&#125;&lt;/span&gt;秒以后跳转&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;window.onload=function()&#123; var t=&#123;$time&#125;; setInterval(function()&#123; document.getElementById(&#x27;t&#x27;).innerHTML=--t; if(t==0) location.href=&#x27;index.php&#x27;; &#125;,1000)&#125;&lt;/script&gt;str; exit; &#125; &#125;&#125; 在ProductsController控制器中使用原型 12345namespace Controller\\Admin;//商品模块class ProductsController&#123; use \\Traits\\Jump; //复用代码 ... 6 删除功能入口 1&lt;a href=&quot;index.php?p=Admin&amp;c=Products&amp;a=del&amp;proid=&lt;?=$rows[&#x27;proID&#x27;]?&gt;&quot; onclick=&quot;return confirm(&#x27;确定要删除吗&#x27;)&quot;&gt;删除&lt;/a&gt; 控制器（ProductsController） 12345678public function delAction() &#123; $id=(int)$_GET[&#x27;proid&#x27;];\t//如果参数明确是整数，要强制转成整形 $model=new \\\\Model\\\\ProductsModel(); if($model-&gt;del($id)) $this-&gt;success(&#x27;index.php?p=Admin&amp;c=Products&amp;a=list&#x27;, &#x27;删除成功&#x27;); else $this-&gt;error(&#x27;index.php?p=admin&amp;c=Products&amp;a=list&#x27;, &#x27;删除失败&#x27;);&#125; 模型、视图 1无改变","tags":["PHP"],"categories":["Language"]},{"title":"PHP-PDO&PDO类&PDO核心类&封装PDO单例","path":"/p/cf780ffd/","content":"1 PDO介绍方法一：mysql扩展【这种方式php7已经淘汰】方法二：mysqli扩展方法三：PDO扩展 1.1 连接数据库方式1.2 PDO介绍PDO（PHP Data Object）扩展为PHP访问各种数据库提供了一个轻量级，一致性的接口。无论访问什么数据库，都可以通过一致性的接口去操作。 1.3 开启PDO扩展开启PDO连接MySQL扩展 1extension=php_pdo_mysql.dll 2 PDO核心类1、PDO类：表示PHP和数据库之间的一个连接2、PDOStatement 类 第一：表示执行数据查询语句（select ,show）后的相关结果集 第二：预处理对象3、PDOException类：表示PDO的异常 3 实例化PDO对象语法 1__construct($dsn,用户名,密码) 3.1 DSNDSN：data source name，数据源名称，包含的是连接数据库的信息，格式如下： 1dsn=数据库类型:host=主机地址;port=端口号;dbname=数据库名称;charset=字符集 数据库类型： 1234MySQL数据库 =&gt; mysql:oracle数据库 =&gt; oci:SQL Server =&gt;sqlsrv:具体驱动类型参见手册“PDO驱动” 3.2 实例化PDO实例化PDO的过程就是连接数据库的过程 1234&lt;?php$dsn=&#x27;mysql:host=localhost;port=3306;dbname=data;charset=utf8&#x27;;$pdo=new PDO($dsn,&#x27;root&#x27;,&#x27;root&#x27;);var_dump($pdo); //object(PDO)#1 (0) &#123; &#125; 3.3 注意事项1、如果连接的是本地数据库，host可以省略 1234&lt;?php$dsn=&#x27;mysql:port=3306;dbname=data;charset=utf8&#x27;;$pdo=new PDO($dsn,&#x27;root&#x27;,&#x27;root&#x27;);var_dump($pdo); //object(PDO)#1 (0) &#123; &#125; 2、如果使用的是3306端口，port可以省略 1234&lt;?php$dsn=&#x27;mysql:dbname=data;charset=utf8&#x27;;$pdo=new PDO($dsn,&#x27;root&#x27;,&#x27;root&#x27;);var_dump($pdo); //object(PDO)#1 (0) &#123; &#125; 3、charset也省略，如果省略，使用的是默认字符编码 1234&lt;?php$dsn=&#x27;mysql:dbname=data&#x27;;$pdo=new PDO($dsn,&#x27;root&#x27;,&#x27;root&#x27;);var_dump($pdo); 4、dbname也可以省略，如果省略就没有选择数据库 1234&lt;?php$dsn=&#x27;mysql:&#x27;;$pdo=new PDO($dsn,&#x27;root&#x27;,&#x27;root&#x27;);var_dump($pdo); 5、host、port、dbname、charset不区分大小写，没有先后顺序 6、驱动名称不能省略，冒号不能省略（因为冒号是驱动名组成部分），数据库驱动只能小写 4 使用PDO4.1 执行数据操作语句方法:$pdo-&gt;exec($sql)，执行数据增、删、改语句，执行成功返回受影响的记录数，如果SQL语句错误返回false。 12345678910111213141516171819202122232425262728293031&lt;?php//1、实例化PDO$dsn=&#x27;mysql:host=localhost;port=3306;dbname=data;charset=utf8&#x27;;$pdo=new PDO($dsn,&#x27;root&#x27;,&#x27;root&#x27;);//2执行数据操作语句//2.1 执行增加/*if($pdo-&gt;exec(&quot;insert into news values (null,&#x27;bb&#x27;,&#x27;bbbbbb&#x27;,unix_timestamp())&quot;)) echo &#x27;自动增长的编号是：&#x27;.$pdo-&gt;lastInsertId (),&#x27;&lt;br&gt;&#x27;;*///2.2 执行修改//echo $pdo-&gt;exec(&quot;update news set title=&#x27;静夜思&#x27; where id in (3,4)&quot;);//2.3 执行删除//echo $pdo-&gt;exec(&#x27;delete from news where id=5&#x27;);\\//2.4 完善$sql=&quot;update news set title=&#x27;静夜思1&#x27; where ids in (3,4)&quot;;$rs=$pdo-&gt;exec($sql);if($rs)&#123; echo &#x27;SQL语句执行成功&lt;br&gt;&#x27;; if(substr($sql, 0,6)==&#x27;insert&#x27;) echo &#x27;自动增长的编号是：&#x27;.$pdo-&gt;lastInsertId (),&#x27;&lt;br&gt;&#x27;; else echo &#x27;受到影响的记录数是：&#x27;.$rs,&#x27;&lt;br&gt;&#x27;;&#125;elseif($rs===0)&#123; echo &#x27;数据没有变化&lt;br&gt;&#x27;;&#125;elseif($rs===false)&#123; echo &#x27;SQL语句执行失败&lt;br&gt;&#x27;; echo &#x27;错误编号：&#x27;.$pdo-&gt;errorCode(),&#x27;&lt;br&gt;&#x27;; //var_dump($pdo-&gt;errorInfo()); echo &#x27;错误信息：&#x27;.$pdo-&gt;errorInfo()[2];&#125; 4.2 执行数据查询语句方法：$pdo-&gt;query($sql)，返回的是PDOStatement对象 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php$dsn=&#x27;mysql:dbname=data;charset=utf8&#x27;;$pdo=new PDO($dsn,&#x27;root&#x27;,&#x27;root&#x27;);//1、执行数据查询语句$stmt=$pdo-&gt;query(&#x27;select * from products&#x27;);//var_dump($stmt); //object(PDOStatement)//2、获取数据//2.1 获取二维数组//$rs=$stmt-&gt;fetchAll(); //默认返回关联和索引数组//$rs=$stmt-&gt;fetchAll(PDO::FETCH_BOTH); //返回关联和索引数组//$rs=$stmt-&gt;fetchAll(PDO::FETCH_NUM); //返回索引数组//$rs=$stmt-&gt;fetchAll(PDO::FETCH_ASSOC); //返回关联数组//$rs=$stmt-&gt;fetchAll(PDO::FETCH_OBJ); //返回对象数组//2.2 获取一维数组,匹配完成后指针下移一条//$rs=$stmt-&gt;fetch(); //关联和索引数组//$rs=$stmt-&gt;fetch(PDO::FETCH_NUM); //索引数组//例题：通过while循环获取所有数据/*while($row=$stmt-&gt;fetch(PDO::FETCH_ASSOC))&#123; $rs[]=$row;&#125;echo &#x27;&lt;pre&gt;&#x27;;var_dump($rs); *///3.3 匹配列：匹配当前行的第n列，列的编号从0开始，匹配完毕后指针下移一条//echo $stmt-&gt;fetchColumn(); //获取当前行的第0列//echo $stmt-&gt;fetchColumn(1); //获取当前行的第1列//3.4 总行数，总列数/*echo &#x27;总行数：&#x27;.$stmt-&gt;rowCount(),&#x27;&lt;br&gt;&#x27;;echo &#x27;总列数：&#x27;.$stmt-&gt;columnCount();*///3.5 遍历PDOStatement对象（PDOStatement对象是有迭代器的）foreach($stmt as $row)&#123; echo $row[&#x27;proname&#x27;],&#x27;-&#x27;,$row[&#x27;proprice&#x27;],&#x27;&lt;br&gt;&#x27;;&#125; 1stdClass类是所有PHP类的父类 4.3 PDO操作事务事务：是一个整体，要么一起执行，要么一起回滚 事务的特性：原子性，一致性，隔离性，永久性 需要将多个SQL语句作为一个整体执行，就需要使用到事务 语法 123start transaction 或 begin 开启事务commit 提交事务rollback 回滚事务 小结： 123$pdo-&gt;beginTransaction() 开启事务$pdo-&gt;commit () 提交事务$pdo-&gt;rollBack() 回滚事务 4.4 PDO操作预处理5 PDO异常处理123456789101112&lt;?phptry&#123; $dsn=&#x27;mysql:dbname=data;charset=utf8&#x27;; $pdo=new PDO($dsn,&#x27;root&#x27;,&#x27;root&#x27;); //这是PDO错误模式属性，PDO自动抛出异常 $pdo-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); $pdo-&gt;query(&#x27;select * from newsssssss&#x27;); //自动抛出异常&#125; catch (PDOException $ex) &#123; echo &#x27;错误信息：&#x27;.$ex-&gt;getMessage(),&#x27;&lt;br&gt;&#x27;; echo &#x27;错误文件：&#x27;.$ex-&gt;getFile(),&#x27;&lt;br&gt;&#x27;; echo &#x27;错误行号：&#x27;.$ex-&gt;getLine();&#125; 小结： 1、PDOException是PDO的异常类 2、实例化PDO会自动抛出异常 3、其他操作不会抛出异常，需要设置PDO的异常模式 4、PDO异常模式 1234PDO::ERRMODE_EXCEPTION\t抛出异常PDO::ERRMODE_SILENT 中断PDO::ERRMODE_WARNING\t警告 6 单例模式封装MyPDO类6.1 步骤1、单例模式 2、初始化参数 3、连接数据库 4、执行增删改 5、执行查询 a）返回二维数组 b）返回一维数组 c）返回一行一列 6.2 代码实现第一部分：单例、初始化参数、实例化PDO 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?phpclass MyPDO&#123; private $type; //数据库类别 private $host; //主机地址 private $port; //端口号 private $dbname; //数据库名 private $charset; //字符集 private $user; //用户名 private $pwd; //密码 private $pdo; //保存PDO对象 private static $instance; private function __construct($param) &#123; $this-&gt;initParam($param); $this-&gt;initPDO(); &#125; private function __clone() &#123; &#125; public static function getInstance($param=array())&#123; if(!self::$instance instanceof self) self::$instance=new self($param); return self::$instance; &#125; //初始化参数 private function initParam($param)&#123; $this-&gt;type=$param[&#x27;type&#x27;]??&#x27;mysql&#x27;; $this-&gt;host=$param[&#x27;host&#x27;]??&#x27;127.0.0.1&#x27;; $this-&gt;port=$param[&#x27;port&#x27;]??&#x27;3306&#x27;; $this-&gt;dbname=$param[&#x27;dbname&#x27;]??&#x27;data&#x27;; $this-&gt;charset=$param[&#x27;charset&#x27;]??&#x27;utf8&#x27;; $this-&gt;user=$param[&#x27;user&#x27;]??&#x27;root&#x27;; $this-&gt;pwd=$param[&#x27;pwd&#x27;]??&#x27;root&#x27;; &#125; //初始化PDO private function initPDO()&#123; try&#123; $dsn=&quot;&#123;$this-&gt;type&#125;:host=&#123;$this-&gt;host&#125;;port=&#123;$this-&gt;port&#125;;dbname=&#123;$this-&gt;dbname&#125;;charset=&#123;$this-&gt;charset&#125;&quot;; $this-&gt;pdo=new PDO($dsn, $this-&gt;user, $this-&gt;pwd); &#125; catch (PDOException $ex) &#123; echo &#x27;错误编号：&#x27;.$ex-&gt;getCode(),&#x27;&lt;br&gt;&#x27;; echo &#x27;错误行号：&#x27;.$ex-&gt;getLine(),&#x27;&lt;br&gt;&#x27;; echo &#x27;错误文件：&#x27;.$ex-&gt;getFile(),&#x27;&lt;br&gt;&#x27;; echo &#x27;错误信息：&#x27;.$ex-&gt;getMessage(),&#x27;&lt;br&gt;&#x27;; exit; &#125; &#125;&#125;//测试$param=array();$mypdo= MyPDO::getInstance($param);var_dump($mypdo); 第二部分：数据操作部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?phpclass MyPDO&#123; private $type; //数据库类别 private $host; //主机地址 private $port; //端口号 private $dbname; //数据库名 private $charset; //字符集 private $user; //用户名 private $pwd; //密码 private $pdo; //保存PDO对象 private static $instance; private function __construct($param) &#123; $this-&gt;initParam($param); $this-&gt;initPDO(); $this-&gt;initException(); &#125; private function __clone() &#123; &#125; public static function getInstance($param=array())&#123; if(!self::$instance instanceof self) self::$instance=new self($param); return self::$instance; &#125; //初始化参数 private function initParam($param)&#123; $this-&gt;type=$param[&#x27;type&#x27;]??&#x27;mysql&#x27;; $this-&gt;host=$param[&#x27;host&#x27;]??&#x27;127.0.0.1&#x27;; $this-&gt;port=$param[&#x27;port&#x27;]??&#x27;3306&#x27;; $this-&gt;dbname=$param[&#x27;dbname&#x27;]??&#x27;data&#x27;; $this-&gt;charset=$param[&#x27;charset&#x27;]??&#x27;utf8&#x27;; $this-&gt;user=$param[&#x27;user&#x27;]??&#x27;root&#x27;; $this-&gt;pwd=$param[&#x27;pwd&#x27;]??&#x27;root&#x27;; &#125; //初始化PDO private function initPDO()&#123; try&#123; $dsn=&quot;&#123;$this-&gt;type&#125;:host=&#123;$this-&gt;host&#125;;port=&#123;$this-&gt;port&#125;;dbname=&#123;$this-&gt;dbname&#125;;charset=&#123;$this-&gt;charset&#125;&quot;; $this-&gt;pdo=new PDO($dsn, $this-&gt;user, $this-&gt;pwd); &#125; catch (PDOException $ex) &#123; $this-&gt;showException($ex); exit; &#125; &#125; //显示异常 private function showException($ex,$sql=&#x27;&#x27;)&#123; if($sql!=&#x27;&#x27;)&#123; echo &#x27;SQL语句执行失败&lt;br&gt;&#x27;; echo &#x27;错误的SQL语句是：&#x27;.$sql,&#x27;&lt;br&gt;&#x27;; &#125; echo &#x27;错误编号：&#x27;.$ex-&gt;getCode(),&#x27;&lt;br&gt;&#x27;; echo &#x27;错误行号：&#x27;.$ex-&gt;getLine(),&#x27;&lt;br&gt;&#x27;; echo &#x27;错误文件：&#x27;.$ex-&gt;getFile(),&#x27;&lt;br&gt;&#x27;; echo &#x27;错误信息：&#x27;.$ex-&gt;getMessage(),&#x27;&lt;br&gt;&#x27;; &#125; //设置异常模式 private function initException()&#123; $this-&gt;pdo-&gt;setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_EXCEPTION); &#125; //执行增、删、改操作 public function exec($sql)&#123; try&#123; return $this-&gt;pdo-&gt;exec($sql); &#125; catch (PDOException $ex) &#123; $this-&gt;showException($ex, $sql); exit; &#125; &#125; //获取自动增长的编号 public function lastInsertId()&#123; return $this-&gt;pdo-&gt;lastInsertId(); &#125;&#125;//测试$param=array();$mypdo= MyPDO::getInstance($param);//echo $mypdo-&gt;exec(&#x27;delete from news where id=6&#x27;);if($mypdo-&gt;exec(&quot;insert into news values (null,&#x27;11&#x27;,&#x27;1111&#x27;,unix_timestamp())&quot;)) echo &#x27;自动增长的编号是：&#x27;.$mypdo-&gt;lastInsertId (); 第三部分：数据查询部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?phpclass MyPDO&#123; ... //判断匹配的类型 private function fetchType($type)&#123; switch ($type)&#123; case &#x27;num&#x27;: return PDO::FETCH_NUM; case &#x27;both&#x27;: return PDO::FETCH_BOTH; case &#x27;obj&#x27;: return PDO::FETCH_OBJ; default: return PDO::FETCH_ASSOC; &#125; &#125; //获取所有数据 ，返回二维数组 public function fetchAll($sql,$type=&#x27;assoc&#x27;)&#123; try&#123; $stmt=$this-&gt;pdo-&gt;query($sql); //获取PDOStatement对象 $type= $this-&gt;fetchType($type); //获取匹配方法 return $stmt-&gt;fetchAll($type); &#125; catch (Exception $ex) &#123; $this-&gt;showException($ex, $sql); &#125; &#125; //获取一维数组 public function fetchRow($sql,$type=&#x27;assoc&#x27;)&#123; try&#123; $stmt=$this-&gt;pdo-&gt;query($sql); //获取PDOStatement对象 $type= $this-&gt;fetchType($type); //获取匹配方法 return $stmt-&gt;fetch($type); &#125; catch (Exception $ex) &#123; $this-&gt;showException($ex, $sql); exit; &#125; &#125; //返回一行一列 public function fetchColumn($sql)&#123; try&#123; $stmt=$this-&gt;pdo-&gt;query($sql); return $stmt-&gt;fetchColumn(); &#125; catch (Exception $ex) &#123; $this-&gt;showException($ex, $sql); exit; &#125; &#125;&#125;//测试$param=array();$mypdo= MyPDO::getInstance($param);//echo $mypdo-&gt;exec(&#x27;delete from news where id=6&#x27;);/*if($mypdo-&gt;exec(&quot;insert into news values (null,&#x27;11&#x27;,&#x27;1111&#x27;,unix_timestamp())&quot;)) echo &#x27;自动增长的编号是：&#x27;.$mypdo-&gt;lastInsertId (); *///$list=$mypdo-&gt;fetchAll(&#x27;select * from news&#x27;);//$list=$mypdo-&gt;fetchRow(&#x27;select * from news where id=1&#x27;);$list=$mypdo-&gt;fetchColumn(&#x27;select count(*) from news&#x27;);echo &#x27;&lt;pre&gt;&#x27;;var_dump($list); 3、$stmt-&gt;bindParam()和$stmt-&gt;bindValue()区别 4、预处理的好处 12a)提高执行效率b)提高安全性 2、参数占位符以冒号开头 1、?是位置占位符 小结： 1234567891011121314151617181920&lt;?php$dsn=&#x27;mysql:dbname=data;charset=utf8&#x27;;$pdo=new PDO($dsn,&#x27;root&#x27;,&#x27;root&#x27;);//创建预处理对象$stmt=$pdo-&gt;prepare(&quot;insert into bank values (:p1,:p2)&quot;); //:p1,:p2是参数占位符//执行预处理$cards=[ [&#x27;p1&#x27;=&gt;&#x27;1003&#x27;,&#x27;p2&#x27;=&gt;500], [&#x27;p1&#x27;=&gt;&#x27;1004&#x27;,&#x27;p2&#x27;=&gt;1000]];foreach($cards as $card)&#123; //方法一： /* $stmt-&gt;bindParam(&#x27;:p1&#x27;, $card[&#x27;p1&#x27;]); $stmt-&gt;bindParam(&#x27;:p2&#x27;, $card[&#x27;p2&#x27;]); $stmt-&gt;execute(); */ //方法二：但数组的下标和参数名一致的时候就可以直接传递关联数组 $stmt-&gt;execute($card);&#125; PDO中的预处理——参数占位符 123456789101112131415161718192021222324252627&lt;?php $dsn=&#x27;mysql:dbname=data;charset=utf8&#x27;; $pdo=new PDO($dsn,&#x27;root&#x27;,&#x27;root&#x27;); //创建预处理对象 $stmt=$pdo-&gt;prepare(&quot;insert into bank values (?,?)&quot;); //?是占位符 //执行预处理 $cards=[ [&#x27;1003&#x27;,500], [&#x27;1004&#x27;,100] ]; foreach($cards as $card)&#123; //绑定参数，并执行预处理, //方法一： /* $stmt-&gt;bindParam(1, $card[0]); //占位符的位置从1开始 $stmt-&gt;bindParam(2, $card[1]); $stmt-&gt;execute(); //执行预处理 */ //方法二： /* $stmt-&gt;bindValue(1, $card[0]); $stmt-&gt;bindValue(2, $card[1]); $stmt-&gt;execute(); */ //方法三：如果占位符的顺序和数组的顺序一致，可以直接传递数组 $stmt-&gt;execute($card); &#125; PDO中的预处理——位置占位符 1execute 预处理名字 [using 变量] 执行预处理 1prepare 预处理名字 from &#x27;sql语句&#x27; 预处理语句： 预处理好处：编译一次多次执行，用来解决一条SQL语句多次执行的问题，提高了执行效率。 复习MySQL中预处理","tags":["PHP"],"categories":["Language"]},{"title":"PHP面向对象-4-命名空间&trait(原型)&迭代器","path":"/p/d71be832/","content":"1 命名空间1.1 介绍在一个大的项目中，可能会遇到同名的类、函数、常量，为了区分这些元素，我们可以将这些元素分别存放到不同的命名空间中。 1、命名空间就是包，用来存放项目中的类、函数、常量 2、通过namespace关键字来声明命名空间 1.2 声明命名空间1234567891011121314&lt;?phpnamespace China; //定义命名空间function getInfo() &#123; echo &#x27;我是中国人&lt;br&gt;&#x27;;&#125;namespace USA; //定义命名空间function getInfo() &#123; echo &#x27;I am a America&lt;br&gt;&#x27;;&#125;//调用getInfo(); //I am a America\\USA\\getInfo(); //I am a America\\China\\getInfo(); //我是中国人 注意：\\表示公共空间 1.3 多级命名空间命名空间的名字可以是多级的（子级命名空间）。 123456789101112131415161718&lt;?phpnamespace China\\Beijing\\Shunyi;class Student &#123;&#125;namespace USA\\Washington;class Student &#123;&#125;//测试：$stu1=new Student(); //相对路径$stu2=new \\USA\\Washington\\Student(); //绝对路径$stu3=new \\China\\Beijing\\Shunyi\\Student(); //绝对路径var_dump($stu1,$stu2,$stu3);//object(USA\\Washington\\Student)#1 (0) &#123; &#125;//object(USA\\Washington\\Student)#2 (0) &#123; &#125;//object(China\\Beijing\\Shunyi\\Student)#3 (0) &#123; &#125; 总结：如果将相对路径转成绝对路径 123公共空间+命名空间+空间元素公共空间 命名空间 空间元素 \\ China\\Shanghai\\PuDong\\ Student 1.4 访问空间元素的三种方式1、非限定名称访问 2、完全限定名称访问 3、限定名称访问 12345678910111213141516&lt;?phpnamespace China\\Beijing\\Shunyi;function getInfo() &#123; echo &#x27;顺义...&lt;br&gt;&#x27;;&#125;namespace China\\Beijing;function getInfo() &#123; echo &#x27;北京...&lt;br&gt;&#x27;;&#125;//访问空间元素的三种方式getInfo(); //非限定名称访问 北京...\\China\\Beijing\\getInfo(); //完全限定名称访问 北京...Shunyi\\getInfo(); //限定名称访问 顺义...//转成绝对路径如下：// \\China\\Beijing\\Shunyi\\getInfo(); 1.5 引入命名空间完全限定名称访问元素路径太长，可以将其他空间引入到当前空间来 通过use引入命名空间 12345678910111213141516171819&lt;?phpnamespace China\\Beijing\\Shunyi;function getInfo() &#123; echo &#x27;李白&lt;br&gt;&#x27;;&#125;namespace USA;function getInfo() &#123; echo &#x27;Lincoln&lt;br&gt;&#x27;;&#125;//引入命名空间use China\\Beijing\\Shunyi;//测试getInfo(); //LincolnShunyi\\getInfo(); //李白/*分析：第一步：通过当前空间拼接成绝对路径：\\USA\\Shunyi\\getInfo(),这个地址没有对应的空间元素第二步：通过引入的空间拼接绝对路径：\\China\\Beijing\\Shunyi+Shunyi\\getInfo(),Shunyi是公共部分，只需要取一个，最后拼接的地址是：\\China\\Beijing\\Shunyi\\getInfo(),这个地址可以找到对应的元素*/ 引入命名空间的拼接规则 12345678910公共空间+引入空间+（去除公共部分，公共部分只能有一级）空间元素比如：namespace A\\B\\C;function getInfo()&#123;&#125;namespace D\\E;use A\\B\\C; //引入命名空间C\\getInfo(); //正确 \\A\\B\\C\\getInfo();B\\C\\getInfo(); //错误 \\A\\B\\C\\B\\C\\getInfo(); 1.6 引入空间元素引入类：use 引入函数：use function [php7.0以后支持] 引入常量：use const\t[php7.0以后支持] 12345678910111213141516171819202122&lt;?phpnamespace China\\Beijing\\Shunyi;class Student &#123;&#125;function getInfo() &#123; echo &#x27;李白&lt;br&gt;&#x27;;&#125;const TYPE=&#x27;学生&#x27;;namespace USA;//引入类use China\\Beijing\\Shunyi\\Student;//引入函数use function China\\Beijing\\Shunyi\\getInfo;//引入常量use const China\\Beijing\\Shunyi\\TYPE;//测试$stu=new Student;var_dump($stu);echo &#x27;&lt;br&gt;&#x27;;getInfo();echo TYPE; 1.7 给类、函数取别名如果引入的类和函数与当前空间的类和函数名称相同，需要给引入的类和函数取别名。 通过as取别名 1234567891011121314151617181920212223242526&lt;?phpnamespace China\\Beijing\\Shunyi;class Student &#123;&#125;function getInfo() &#123; echo &#x27;李白&lt;br&gt;&#x27;;&#125;namespace USA\\Washington;class Student &#123;&#125;function getInfo() &#123; echo &#x27;Lincoln&lt;br&gt;&#x27;;&#125;//引入类取别名use China\\Beijing\\Shunyi\\Student as ChinaStudent;//引入函数use function China\\Beijing\\Shunyi\\getInfo as info1;//测试$stu=new ChinaStudent;var_dump($stu);getInfo(); //Lincolninfo1(); //李白 1.8 公共空间如果一个页面没有namespace声明空间，这个页面的元素在公共空间下 公共空间用\\表示 12345&lt;?phpfunction getInfo() &#123; echo &#x27;李白&lt;br&gt;&#x27;;&#125;\\getInfo(); //李白 1.9 命名空间注意事项1、命名空间只能存放类、函数、const常量 2、第一个namespace前面不能有任何的代码，空白字符、header()也不行。 3、包含文件不影响当前的命名空间 2 trait(原型)trait 为了减少单继承语言的限制，可以在不同层次结构内独立的类中复用类的方法集。 1234567891011121314&lt;?php//原型trait A&#123; public function getInfo() &#123; echo &#x27;锄禾日当午&lt;br&gt;&#x27;; &#125;&#125;//使用原型class Student &#123; use A; //代码复用&#125;//测试$stu=new Student;$stu-&gt;getInfo(); //锄禾日当午 引入多个 trait 1234567891011121314151617181920&lt;?php//原型trait A&#123; public function getInfo1() &#123; echo &#x27;锄禾日当午&lt;br&gt;&#x27;; &#125;&#125;trait B&#123; public function getInfo2() &#123; echo &#x27;床前明月光&lt;br&gt;&#x27;; &#125;&#125;//使用原型class Student &#123; use A,B; //引入A、B trait&#125;//测试$stu=new Student;$stu-&gt;getInfo1(); //锄禾日当午$stu-&gt;getInfo2(); //床前明月光 trait和继承结合 123456789101112131415161718&lt;?phptrait A&#123; public function getInfo() &#123; echo &#x27;这是trait原型&lt;br&gt;&#x27;; &#125;&#125;class Person &#123; public function getInfo() &#123; echo &#x27;这是Person类&lt;br&gt;&#x27;; &#125;&#125;//继承类同时代码复用class Student extends Person &#123; use A; //继承了getInfo，有被A中getInfo覆盖&#125;//测试$stu=new Student;$stu-&gt;getInfo(); //这是trait原型 解决同名冲突 1234567891011121314151617181920212223242526272829303132&lt;?php//原型trait A&#123; public function getInfo() &#123; echo &#x27;锄禾日当午&lt;br&gt;&#x27;; &#125;&#125;trait B&#123; public function getInfo() &#123; echo &#x27;床前明月光&lt;br&gt;&#x27;; &#125;&#125;//使用原型class Student &#123; use A,B&#123; //引入A和B的trait，同时解决名称冲突 //方法一：方法替换 //A::getInfo insteadof B; //将A中的getInfo替换掉B中的getInfo //B::getInfo insteadof A; //将B中的getInfo替换到A中的getInfo //方法二：改名 A::getInfo insteadof B; B::getInfo as show; //将B的getInfo改名为show &#125;&#125;//测试$stu=new Student;$stu-&gt;getInfo(); //锄禾日当午$stu-&gt;show(); //床前明月光/*同名冲突的解决方法有两个：第一：方法替换第二：方法改名 更改权限 1234567891011121314151617&lt;?phptrait A&#123; private function show() &#123; echo &#x27;锄禾日当午&lt;br&gt;&#x27;; &#125;&#125;class Student &#123; use A&#123; //show as public; //将show方法权限设为public; show as public show2; //将show方法设置public，并改名为show2 &#125;&#125;$stu=new Student;//$stu-&gt;show();$stu-&gt;show2(); 多学一招：具体参见手册 1、 多个trait可以组成一个trait 2、 trait可以定义抽象成员 3、 trait可以定义静态成员 4、 trait可以定义属性 3 迭代器3.1 遍历数组手动遍历数组 步骤： 1、复位数组指针 reset() 2、检查指针是否合法\t获取当前指针，如果不为null就是合法的 3、获取当前值 current() 4、获取当前键 key() 5、指针下移 next() 代码实现 12345678910111213&lt;?php$stu=[&#x27;tom&#x27;,&#x27;berry&#x27;,&#x27;ketty&#x27;,&#x27;rose&#x27;];reset($stu); //复位指针while(key($stu)!==null)&#123;//键合法 echo key($stu),&#x27;-&#x27;,current($stu),&#x27;&lt;br&gt;&#x27;;//获取键、值 next($stu); //指针下移&#125;/*0-tom1-berry2-ketty3-rose*/ 3.2 迭代器迭代器是PHP内置的接口 场景：遍历对象，获取的是对象中属性保存的数组 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?php//定义类实现迭代器接口class MyClass implements Iterator&#123; //$list属性用来保存学生数组 private $list=array(); //添加学生 public function addStu($name) &#123; $this-&gt;list[]=$name; &#125; //实现接口中的复位方法 public function rewind() &#123; reset($this-&gt;list); &#125; //验证当前指针是否合法 public function valid() &#123; return key($this-&gt;list)!==null; &#125; //获取值 public function current() &#123; return current($this-&gt;list); &#125; //获取键 public function key() &#123; return key($this-&gt;list); &#125; //指针下移 public function next() &#123; next($this-&gt;list); &#125;&#125;//创建班级$class=new MyClass();//添加学生$class-&gt;addStu(&#x27;tom&#x27;);$class-&gt;addStu(&#x27;berry&#x27;);$class-&gt;addStu(&#x27;ketty&#x27;);//遍历班级foreach($class as $k=&gt;$v)&#123; echo &quot;&#123;$k&#125;-&#123;$v&#125;&lt;br&gt;&quot;;&#125;/*0-tom1-berry2-ketty*/ 4 PSR编码规范4.1 概述 PSR 是 PHP Standard Recommendations 的简写，由 PHP FIG 组织制定的 PHP 规范，是 PHP 开发的实践标准。 目前已表决通过了 6 套标准，已经得到大部分 PHP 框架的支持和认可。 网址：http://psr.phphub.org/ 4.2 PSR-1 基础编码规范12341、PHP代码文件 必须 以 &lt;?php 或 &lt;?= 标签开始2、类的命名大写开头的驼峰命名规范3、类中的常量所有字母都必须大写，单词间用下划线分隔4、方法名称必须符合小写开头驼峰命名规范5、 副作用：(side effects)，一个文件只做一件事情，如果做了其他事情就是产生了副作用 不产生副作用：一个文件只做一件事 产生副作用：一个文件做了多件事情 4.3 PSR-2 编码风格规范12345代码 必须 使用 4 个空格符而不是「Tab 键」进行缩进每个 namespace 命名空间声明语句和 use 声明语句块后面，必须 插入一个空白行类的开始花括号（&#123;） 必须 写在类声明后自成一行，结束花括号（&#125;）也 必须 写在类主体后自成一行方法的开始花括号（&#123;） 必须 写在函数声明后自成一行，结束花括号（&#125;）也 必须 写在函数主体后自成一行。类的属性和方法 必须 添加访问修饰符（private、protected 以及 public），abstract 以及 final 必须 声明在访问修饰符之前，而 static 必须 声明在访问修饰符之后。","tags":["PHP"],"categories":["Language"]},{"title":"PHP面向对象-3-加载类&设计模式&魔术方法&序列化","path":"/p/be32be3e/","content":"1 自动加载类1.1 类的规则 一个文件中只能放一个类（必须） 文件名和类名同名（必须） 类文件以.class.php结尾（不是必须） 1.2 手动加载类在PHP页面上加载类文件 1234567891011&lt;?phprequire &#x27;./Goods.class.php&#x27;; //手动加载类文件require &#x27;./Book.class.php&#x27;; //手动加载类文件require &#x27;./Phone.class.php&#x27;; //手动加载类文件//测试$book=new Book();$book-&gt;setName(&#x27;面向对象编程&#x27;);$phone=new Phone();$phone-&gt;setName(&#x27;苹果6s&#x27;);$book-&gt;getName();$phone-&gt;getName(); 1.3 自动加载类当缺少类的时候自动的调用__autoload()函数，并且将缺少的类名作为参数传递给__autoload()。 123456789101112131415&lt;?php/**作用：自动加载类*@param $class_name string 缺少的类名*/function __autoload($class_name) &#123; require &quot;./&#123;$class_name&#125;.class.php&quot;;&#125;//测试$book=new Book();$book-&gt;setName(&#x27;面向对象编程&#x27;);$phone=new Phone();$phone-&gt;setName(&#x27;苹果6s&#x27;);$book-&gt;getName();$phone-&gt;getName(); 💡 注意：__autoload()函数在PHP7.2以后就不支持了。 1.4 注册加载类通过spl_autoload_register()注册__autoload()函数 1234567891011121314151617181920212223&lt;?php//方法一：/*//加载类函数function loadClass($class_name) &#123; require &quot;./&#123;$class_name&#125;.class.php&quot;;&#125;//注册加载类函数spl_autoload_register(&#x27;loadClass&#x27;);*///方法二：spl_autoload_register(function($class_name)&#123; require &quot;./&#123;$class_name&#125;.class.php&quot;;&#125;);//测试$book=new Book();$book-&gt;setName(&#x27;面向对象编程&#x27;);$phone=new Phone();$phone-&gt;setName(&#x27;苹果6s&#x27;);$book-&gt;getName();$phone-&gt;getName(); 1、spl_autoload_register()可以注册多个自动加载函数 12345678910111213&lt;?phpfunction load1($class) &#123; require &quot;./&#123;$class&#125;.class.php&quot;;&#125;function load2($class) &#123; require &quot;./&#123;$class&#125;.php&quot;;&#125;function load3($class) &#123; require &quot;./&#123;$class&#125;.fun.php&quot;;&#125;spl_autoload_register(&#x27;load1&#x27;);spl_autoload_register(&#x27;load2&#x27;);spl_autoload_register(&#x27;load3&#x27;); 2、PHP5.1以后就开始支持此函数。 1.5 类文件存储不规则的加载方法将类名和文件地址做一个映射，组成一个关联数组。 123456$map=array( //类名 =&gt; 类文件地址 &#x27;Goods&#x27; =&gt; &#x27;./aa/Goods.class.php&#x27;, &#x27;Book&#x27; =&gt; &#x27;./bb/Book.class.php&#x27;, &#x27;Phone&#x27; =&gt; &#x27;./cc/Phone.class.php&#x27;); 代码如下 12345678910111213141516171819&lt;?phpspl_autoload_register(function($class_name)&#123; //类名和文件地址映射成一个关联数组 $map=array( &#x27;Goods&#x27; =&gt; &#x27;./aa/Goods.class.php&#x27;, &#x27;Book&#x27; =&gt; &#x27;./bb/Book.class.php&#x27;, &#x27;Phone&#x27; =&gt; &#x27;./cc/Phone.class.php&#x27; ); //在映射数组中找到就包含 if(isset($map[$class_name])) require $map[$class_name];&#125;);//测试$book=new Book();$book-&gt;setName(&#x27;面向对象编程&#x27;);$phone=new Phone();$phone-&gt;setName(&#x27;苹果6s&#x27;);$book-&gt;getName();$phone-&gt;getName(); 在项目中，绝大部分都是规则存储的，不规则的比较少。 2 clone和__clone()思考：创建对象的方式有哪些？ 12方法一：实例化方法二：克隆 例题 12345678910&lt;?phpclass Student &#123; //执行clone指令的时候自动执行 public function __clone() &#123; echo &#x27;正在克隆对象&lt;br&gt;&#x27;; &#125;&#125;$stu1=new Student;$stu2=clone $stu1; //克隆对象var_dump($stu1,$stu2); //object(Student)#1 (0) &#123; &#125; object(Student)#2 (0) &#123; &#125; 小结： 1、clone的创建对象的方法之一 2、当执行clone指令的时候，会自动的调用__clone()方法 3 设计模式3.1 单例模式1.4.1 单例模式一个类只能有一个对象 应用场景：多次请求数据库只需要一个连接对象。 实现：三私一公 12341、私有的静态属性用来保存对象的单例2、私有的构造方法用来阻止在类的外部实例化3、私有的__clone阻止在类的外部clone对象4、公有的静态方法用来获取对象的单例 代码 123456789101112131415161718192021222324&lt;?php//三私一公class DB &#123; //静态的属性用来保存对象的单例 private static $instance; //私有的构造方法阻止在类的外部实例化 private function __construct() &#123; &#125; //私有的__clone()阻止在类的外部clone对象 private function __clone() &#123; &#125; public static function getInstance() &#123; //保存的值不属于DB类的类型就实例化 if(!self::$instance instanceof self) self::$instance=new self(); return self::$instance; &#125;&#125;//测试$db1=DB::getInstance();$db2=DB::getInstance();var_dump($db1,$db2); //object(DB)#1 (0) &#123; &#125; object(DB)#1 (0) &#123; &#125; 3.2 工厂模式特点：传递不同的参数获取不同的对象 1234567891011121314151617181920212223&lt;?phpclass ProductsA &#123;&#125;class ProductsB &#123;&#125;//工厂模式class ProductsFactory &#123; public function create($num) &#123; switch($num) &#123; case 1: return new ProductsA; case 2: return new ProductsB; default: return null; &#125; &#125;&#125;//测试$factory=new ProductsFactory();$obj1=$factory-&gt;create(1);$obj2=$factory-&gt;create(2);var_dump($obj1,$obj2); //object(ProductsA)#2 (0) &#123; &#125; object(ProductsB)#3 (0) &#123; &#125; 3.3 策略模式特点：传递不同的参数调用不同的策略（方法） 123456789101112131415161718192021&lt;?phpclass Walk &#123; public function way() &#123; echo &#x27;走着去&lt;br&gt;&#x27;; &#125;&#125;class Bus &#123; public function way() &#123; echo &#x27;坐车去&lt;br&gt;&#x27;; &#125;&#125;//策略模式class Student &#123; public function play($obj) &#123; $obj-&gt;way(); &#125;&#125;//测试$stu=new Student;$stu-&gt;play(new Walk()); //走着去$stu-&gt;play(new Bus()); //坐车去 4 序列化与反序列化在PHP中，数组和对象无法保存，如果需要保存就要将数组或对象转换成一个序列。 序列化：将数组或对象转换成一个序列（serialize） 反序列化：将序列化的字符串转换成数组或对象。(unserialize) 4.1 数组的序列化与反序列化123456789101112&lt;?php//数组的序列化/*$stu=[&#x27;tom&#x27;,&#x27;berry&#x27;,&#x27;ketty&#x27;];$str=serialize($stu); //序列化file_put_contents(&#x27;./stu.txt&#x27;,$str);*///数组的反序列化$str=file_get_contents(&#x27;./stu.txt&#x27;);$stu=unserialize($str); //反序列化print_r($stu);\t//Array ( [0] =&gt; tom [1] =&gt; berry [2] =&gt; ketty ) 4.2 对象的序列化与反序列化💡 注意：对象的反序列化需要有类的参与，如果没有类在反序列化时候无法确定类 5 魔术方法1234已经学过的魔术方法__construct() 构造方法__destruct() 析构方法__clone() 克隆方法 5.1 __tostring()、__invoke()__tostring()：将对象当成字符串使用的时候自动调用 __invoke()：将对象当成函数使用的时候自动调用 1234567891011121314&lt;?phpclass Student &#123;\t//把对象当成字符串使用的时候自动执行\tpublic function __tostring() &#123; return &#x27;这是一个对象，不是字符串&lt;br&gt;&#x27;;\t&#125;\t//把对象当成函数使用的时候自动执行\tpublic function __invoke() &#123; echo &#x27;这是一个对象，不是函数&lt;br&gt;&#x27;;\t&#125;&#125;$stu=new Student;echo $stu;\t//当成字符串使用$stu(); //当成函数使用 5.2 __set()、__get()、__isset()、__unset()1234__set($k,$v)：给无法访问的属性赋值的时候自动执行__get($k)：获取无法访问的属性值的时候自动调用__isset($k)：判断无法访问的属性是否存在自动调用__unset($k)：销毁无法访问的属性的时候自动执行 5.3 __call()、__callstatic()12__call()：调用无法访问的方法时自动执行__callstatic()：调用无法访问的静态方法时自动执行 1234567891011121314151617181920&lt;?phpclass Student &#123;\t/**\t*作用：调用无法访问的方法时自动执行\t*@param $fn_name string 方法名\t*@param $fn_args array 参数数组\t*/\tpublic function __call($fn_name,$fn_args) &#123; echo &quot;&#123;$fn_name&#125;不存在&lt;br&gt;&quot;;\t&#125;\t//调用无法访问的静态方法时自动执行\tpublic static function __callstatic($fn_name,$fn_args) &#123; echo &quot;&#123;$fn_name&#125;静态方法不存在&lt;br&gt;&quot;; &#125;&#125;//测试$stu=new Student;$stu-&gt;show(10,20);Student::show(); 5.4 __sleep()、__wakeup()12__sleep()：当序列化的时候自动调用__wakeup()：当反序列化的时候自动调用 1234567891011121314151617181920212223242526&lt;?phpclass Student &#123;\tprivate $name;\tprivate $sex;\tprivate $add=&#x27;中国&#x27;;\tpublic function __construct($name,$sex) &#123; $this-&gt;name=$name; $this-&gt;sex=$sex;\t&#125;\t/**\t*序列化的时候自动调用\t*@return array 序列化的属性名\t*/\tpublic function __sleep() &#123; return array(&#x27;name&#x27;,&#x27;sex&#x27;);\t&#125;\t//反序列化的时候自动调用\tpublic function __wakeup() &#123; $this-&gt;type=&#x27;学生&#x27;;\t&#125;&#125;//测试$stu=new Student(&#x27;tom&#x27;,&#x27;男&#x27;);$str=serialize($stu);\t//序列化$stu=unserialize($str);\t//反序列化print_r($stu); 6 模拟方法重载通过魔术方法模拟方法重载 123456789101112131415&lt;?phpclass Math &#123; public function __call($fn_name,$fn_args) &#123; $sum=0; foreach($fn_args as $v) &#123; $sum+=$v; &#125; echo implode(&#x27;,&#x27;,$fn_args).&#x27;的和是：&#x27;.$sum,&#x27;&lt;br&gt;&#x27;; &#125;&#125;//利用魔术方法模拟方法重载$math=new Math();$math-&gt;call(10,20);$math-&gt;call(10,20,30);$math-&gt;call(10,20,30,40); 7 遍历对象通过foreach遍历对象 12345678910111213141516171819&lt;?phpclass Student &#123; public $name=&#x27;tom&#x27;; protected $sex=&#x27;男&#x27;; private $age=22; public function show() &#123; foreach($this as $k=&gt;$v) &#123; echo &quot;&#123;$k&#125;-&#123;$v&#125;&lt;br&gt;&quot;; &#125; &#125;&#125;//测试$stu=new Student;foreach($stu as $k=&gt;$v) &#123; echo &quot;&#123;$k&#125;-&#123;$v&#125;&lt;br&gt;&quot;;&#125;echo &#x27;&lt;hr&gt;&#x27;;$stu-&gt;show(); 结论：遍历到当前位置所能访问到属性 8 封装MySQL的单例8.1 分析1、实现单例 2、连接数据库 3、对数据进行操作 8.2 步骤第一步：实现单例 第二步：初始化参数 第三步：连接数据库 第四步：操作数据 1、执行数据操作语句（增、删、改） 2、执行数据查询语句 a) 返回二维数组 b) 返回一维数组 c)返回一行一列 8.3 代码实现 第一步：实现单例 123456789101112131415161718&lt;?phpclass MySQLDB &#123; private static $instance; private function __construct() &#123; &#125; private function __clone() &#123; &#125; public static function getInstance() &#123; if(!self::$instance instanceof self) self::$instance=new self(); return self::$instance; &#125;&#125;//测试$db=MySQLDB::getInstance();var_dump($db); 注意：A instanceof B，表示A是否是B的类型，返回bool值 第二步：初始化参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?php//封装MySQL单例class MySQLDB &#123; private $host; //主机地址 private $port; //端口号 private $user; //用户名 private $pwd; //密码 private $dbname; //数据接名 private $charset; //字符集 private $link; //连接对象 private static $instance; private function __construct($param) &#123; $this-&gt;initParam($param); &#125; private function __clone() &#123; &#125; //获取单例 public static function getInstance($param=array()) &#123; if(!self::$instance instanceof self) self::$instance=new self($param); return self::$instance; &#125; //初始化参数 private function initParam($param) &#123; $this-&gt;host=$param[&#x27;host&#x27;]??&#x27;127.0.0.1&#x27;; $this-&gt;port=$param[&#x27;port&#x27;]??&#x27;3306&#x27;; $this-&gt;user=$param[&#x27;user&#x27;]??&#x27;&#x27;; $this-&gt;pwd=$param[&#x27;pwd&#x27;]??&#x27;&#x27;; $this-&gt;dbname=$param[&#x27;dbname&#x27;]??&#x27;&#x27;; $this-&gt;charset=$param[&#x27;charset&#x27;]??&#x27;utf8&#x27;; &#125;&#125;//测试//配置参数$param=array( &#x27;user&#x27; =&gt; &#x27;root&#x27;, &#x27;pwd&#x27; =&gt; &#x27;root&#x27;, &#x27;dbname&#x27; =&gt; &#x27;data&#x27;);//获取单例$db=MySQLDB::getInstance($param);var_dump($db); 第三步：连接数据库 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?php//封装MySQL单例class MySQLDB &#123; private $host; //主机地址 private $port; //端口号 private $user; //用户名 private $pwd; //密码 private $dbname; //数据接名 private $charset; //字符集 private $link; //连接对象 private static $instance; private function __construct($param) &#123; $this-&gt;initParam($param); $this-&gt;initConnect(); &#125; private function __clone() &#123; &#125; //获取单例 public static function getInstance($param=array()) &#123; if(!self::$instance instanceof self) self::$instance=new self($param); return self::$instance; &#125; //初始化参数 private function initParam($param) &#123; $this-&gt;host=$param[&#x27;host&#x27;]??&#x27;127.0.0.1&#x27;; $this-&gt;port=$param[&#x27;port&#x27;]??&#x27;3306&#x27;; $this-&gt;user=$param[&#x27;user&#x27;]??&#x27;&#x27;; $this-&gt;pwd=$param[&#x27;pwd&#x27;]??&#x27;&#x27;; $this-&gt;dbname=$param[&#x27;dbname&#x27;]??&#x27;&#x27;; $this-&gt;charset=$param[&#x27;charset&#x27;]??&#x27;utf8&#x27;; &#125; //连接数据库 private function initConnect() &#123; $this-&gt;link=@mysqli_connect($this-&gt;host,$this-&gt;user,$this-&gt;pwd,$this-&gt;dbname); if(mysqli_connect_error())&#123; echo &#x27;数据库连接失败&lt;br&gt;&#x27;; echo &#x27;错误信息：&#x27;.mysqli_connect_error(),&#x27;&lt;br&gt;&#x27;; echo &#x27;错误码：&#x27;.mysqli_connect_errno(),&#x27;&lt;br&gt;&#x27;; exit; &#125; mysqli_set_charset($this-&gt;link,$this-&gt;charset); &#125;&#125;//测试//配置参数$param=array( &#x27;user&#x27; =&gt; &#x27;root&#x27;, &#x27;pwd&#x27; =&gt; &#x27;root&#x27;, &#x27;dbname&#x27; =&gt; &#x27;data&#x27;);//获取单例$db=MySQLDB::getInstance($param);var_dump($db); 第四步：数据操作的功能 1、执行增、删、改操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?php//封装MySQL单例class MySQLDB &#123; private $host; //主机地址 private $port; //端口号 private $user; //用户名 private $pwd; //密码 private $dbname; //数据接名 private $charset; //字符集 private $link; //连接对象 private static $instance; private function __construct($param) &#123; $this-&gt;initParam($param); $this-&gt;initConnect(); &#125; private function __clone() &#123; &#125; //获取单例 public static function getInstance($param=array()) &#123; if(!self::$instance instanceof self) self::$instance=new self($param); return self::$instance; &#125; //初始化参数 private function initParam($param) &#123; $this-&gt;host=$param[&#x27;host&#x27;]??&#x27;127.0.0.1&#x27;; $this-&gt;port=$param[&#x27;port&#x27;]??&#x27;3306&#x27;; $this-&gt;user=$param[&#x27;user&#x27;]??&#x27;&#x27;; $this-&gt;pwd=$param[&#x27;pwd&#x27;]??&#x27;&#x27;; $this-&gt;dbname=$param[&#x27;dbname&#x27;]??&#x27;&#x27;; $this-&gt;charset=$param[&#x27;charset&#x27;]??&#x27;utf8&#x27;; &#125; //连接数据库 private function initConnect() &#123; $this-&gt;link=@mysqli_connect($this-&gt;host,$this-&gt;user,$this-&gt;pwd,$this-&gt;dbname); if(mysqli_connect_error())&#123; echo &#x27;数据库连接失败&lt;br&gt;&#x27;; echo &#x27;错误信息：&#x27;.mysqli_connect_error(),&#x27;&lt;br&gt;&#x27;; echo &#x27;错误码：&#x27;.mysqli_connect_errno(),&#x27;&lt;br&gt;&#x27;; exit; &#125; mysqli_set_charset($this-&gt;link,$this-&gt;charset); &#125; //执行数据库的增、删、改、查 private function execute($sql) &#123; if(!$rs=mysqli_query($this-&gt;link,$sql))&#123; echo &#x27;SQL语句执行失败&lt;br&gt;&#x27;; echo &#x27;错误信息：&#x27;.mysqli_error($this-&gt;link),&#x27;&lt;br&gt;&#x27;; echo &#x27;错误码：&#x27;.mysqli_errno($this-&gt;link),&#x27;&lt;br&gt;&#x27;; echo &#x27;错误的SQL语句：&#x27;.$sql,&#x27;&lt;br&gt;&#x27;; exit; &#125; return $rs; &#125; /** *执行增、删、改 *@return bool 成功返回true,失败返回false */ public function exec($sql) &#123; $key=substr($sql,0,6); if(in_array($key,array(&#x27;insert&#x27;,&#x27;update&#x27;,&#x27;delete&#x27;))) return $this-&gt;execute($sql); else&#123; echo &#x27;非法访问&lt;br&gt;&#x27;; exit; &#125; &#125; //获取自动增长的编号 public function getLastInsertId() &#123; return mysqli_insert_id($this-&gt;link); &#125;&#125;//测试//配置参数$param=array( &#x27;user&#x27; =&gt; &#x27;root&#x27;, &#x27;pwd&#x27; =&gt; &#x27;root&#x27;, &#x27;dbname&#x27; =&gt; &#x27;data&#x27;);//获取单例$db=MySQLDB::getInstance($param);//更新//$db-&gt;exec(&quot;update news set title=&#x27;青草&#x27; where id=2&quot;);//插入if($db-&gt;exec(&quot;insert into news values (null,&#x27;aa&#x27;,&#x27;bb&#x27;,unix_timestamp())&quot;)) echo &#x27;编号是：&#x27;.$db-&gt;getLastInsertId(); 2、查询结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147&lt;?php//封装MySQL单例class MySQLDB &#123; private $host; //主机地址 private $port; //端口号 private $user; //用户名 private $pwd; //密码 private $dbname; //数据接名 private $charset; //字符集 private $link; //连接对象 private static $instance; private function __construct($param) &#123; $this-&gt;initParam($param); $this-&gt;initConnect(); &#125; private function __clone() &#123; &#125; //获取单例 public static function getInstance($param=array()) &#123; if(!self::$instance instanceof self) self::$instance=new self($param); return self::$instance; &#125; //初始化参数 private function initParam($param) &#123; $this-&gt;host=$param[&#x27;host&#x27;]??&#x27;127.0.0.1&#x27;; $this-&gt;port=$param[&#x27;port&#x27;]??&#x27;3306&#x27;; $this-&gt;user=$param[&#x27;user&#x27;]??&#x27;&#x27;; $this-&gt;pwd=$param[&#x27;pwd&#x27;]??&#x27;&#x27;; $this-&gt;dbname=$param[&#x27;dbname&#x27;]??&#x27;&#x27;; $this-&gt;charset=$param[&#x27;charset&#x27;]??&#x27;utf8&#x27;; &#125; //连接数据库 private function initConnect() &#123; $this-&gt;link=@mysqli_connect($this-&gt;host,$this-&gt;user,$this-&gt;pwd,$this-&gt;dbname); if(mysqli_connect_error())&#123; echo &#x27;数据库连接失败&lt;br&gt;&#x27;; echo &#x27;错误信息：&#x27;.mysqli_connect_error(),&#x27;&lt;br&gt;&#x27;; echo &#x27;错误码：&#x27;.mysqli_connect_errno(),&#x27;&lt;br&gt;&#x27;; exit; &#125; mysqli_set_charset($this-&gt;link,$this-&gt;charset); &#125; //执行数据库的增、删、改、查 private function execute($sql) &#123; if(!$rs=mysqli_query($this-&gt;link,$sql))&#123; echo &#x27;SQL语句执行失败&lt;br&gt;&#x27;; echo &#x27;错误信息：&#x27;.mysqli_error($this-&gt;link),&#x27;&lt;br&gt;&#x27;; echo &#x27;错误码：&#x27;.mysqli_errno($this-&gt;link),&#x27;&lt;br&gt;&#x27;; echo &#x27;错误的SQL语句：&#x27;.$sql,&#x27;&lt;br&gt;&#x27;; exit; &#125; return $rs; &#125; /** *执行增、删、改 *@return bool 成功返回true,失败返回false */ public function exec($sql) &#123; $key=substr($sql,0,6); if(in_array($key,array(&#x27;insert&#x27;,&#x27;update&#x27;,&#x27;delete&#x27;))) return $this-&gt;execute($sql); else&#123; echo &#x27;非法访问&lt;br&gt;&#x27;; exit; &#125; &#125; //获取自动增长的编号 public function getLastInsertId() &#123; return mysqli_insert_id($this-&gt;link); &#125; //执行查询语句 private function query($sql) &#123; if(substr($sql,0,6)==&#x27;select&#x27; || substr($sql,0,4)==&#x27;show&#x27; || substr($sql,0,4)==&#x27;desc&#x27;)&#123; return $this-&gt;execute($sql); &#125;else&#123; echo &#x27;非法访问&lt;br&gt;&#x27;; exit; &#125; &#125; /** *执行查询语句，返回二维数组 *@$sql string 查询sql语句 *@type string assoc|num|both */ public function fetchAll($sql,$type=&#x27;assoc&#x27;) &#123; $rs=$this-&gt;query($sql); $type=$this-&gt;getType($type); return mysqli_fetch_all($rs,$type); &#125; //匹配一维数组 public function fetchRow($sql,$type=&#x27;assoc&#x27;) &#123; $list=$this-&gt;fetchAll($sql,$type); if(!empty($list)) return $list[0]; return array(); &#125; //匹配一行一列 public function fetchColumn($sql) &#123; $list=$this-&gt;fetchRow($sql,&#x27;num&#x27;); if(!empty($list)) return $list[0]; return null; &#125; //获取匹配类型 private function getType($type) &#123; switch($type)&#123; case &#x27;num&#x27;: return MYSQLI_NUM; case &#x27;both&#x27;: return MYSQLI_BOTH; default: return MYSQLI_ASSOC; &#125; &#125;&#125;//测试//配置参数$param=array( &#x27;user&#x27; =&gt; &#x27;root&#x27;, &#x27;pwd&#x27; =&gt; &#x27;root&#x27;, &#x27;dbname&#x27; =&gt; &#x27;data&#x27;);//获取单例$db=MySQLDB::getInstance($param);//更新//$db-&gt;exec(&quot;update news set title=&#x27;青草&#x27; where id=2&quot;);//插入/*if($db-&gt;exec(&quot;insert into news values (null,&#x27;aa&#x27;,&#x27;bb&#x27;,unix_timestamp())&quot;)) echo &#x27;编号是：&#x27;.$db-&gt;getLastInsertId();*///查询//$list=$db-&gt;fetchAll(&#x27;select * from news&#x27;,&#x27;aa&#x27;);//$list=$db-&gt;fetchRow(&#x27;select * from news where id=1&#x27;,&#x27;aa&#x27;);$list=$db-&gt;fetchColumn(&#x27;select count(*) from news&#x27;);echo &#x27;&lt;pre&gt;&#x27;;var_dump($list); 小结： 1、instanceof 用来判断对象是否属于某个类 2、参数必须从外部传递到内部，不能写死到类的内部。 3、为了保证代码的可重用性，一个方法只实现一个功能，所以初始化参数和连接数据库分到两个方法中。","tags":["PHP"],"categories":["Language"]},{"title":"PHP面向对象-2-三大特性&类常量&接口","path":"/p/980312b6/","content":"1 多态多态：多种形态。 多态分为两种：方法重写和方法重载 1.1 方法重写子类重写了父类的同名的方法 1234567891011121314151617&lt;?php//父类class Person &#123; public function show() &#123; echo &#x27;这是父类&lt;br&gt;&#x27;; &#125;&#125;//子类class Student extends Person &#123; //子类重写了父类的同名方法 public function show() &#123; echo &#x27;这是子类&lt;br&gt;&#x27;; &#125;&#125;//测试$stu=new Student;$stu-&gt;show(); //这是子类 注意事项： 子类的方法必须和父类的方法同名 参数个数要一致 子类修饰的不能比父类更加严格 1.2 方法重载在同一个类中，有多个同名的函数，通过参数的不同来区分不同的方法，称为方法重载 💡 注意：PHP不支持方法重载，但是PHP可以通过其他方法来模拟方法重载。 2面向对象三大特性 封装 继承 多态 3 私有属性继承和重写私有属性可以继承但不能重写。 1234567891011121314151617181920212223&lt;?phpclass A &#123; private $name=&#x27;PHP&#x27;; public function showA() &#123; //var_dump($this); //object(B)#1 (2) &#123; [&quot;name&quot;:&quot;B&quot;:private]=&gt; string(4) &quot;Java&quot; [&quot;name&quot;:&quot;A&quot;:private]=&gt; string(3) &quot;PHP&quot; &#125; echo $this-&gt;name,&#x27;&lt;br&gt;&#x27;; //PHP &#125;&#125;class B extends A &#123; private $name=&#x27;Java&#x27;; public function showB() &#123; //var_dump($this); //object(B)#1 (2) &#123; [&quot;name&quot;:&quot;B&quot;:private]=&gt; string(4) &quot;Java&quot; [&quot;name&quot;:&quot;A&quot;:private]=&gt; string(3) &quot;PHP&quot; &#125; echo $this-&gt;name,&#x27;&lt;br&gt;&#x27;; //Java &#125;&#125;$obj=new B();$obj-&gt;showA();$obj-&gt;showB();/*分析：showA()和showB()中的$this都表示B的对象，B中继承了A的私有属性，所以B中有两个$name.在showA()中只能访问A中的$name，不能访问B中的$name在showB()中只能访问B中的$name,不能访问A中的$name*/ 4 方法修饰符方法修饰符有：static、final、abstract 4.1 static【静态的】 static修饰的属性叫静态属性、static修饰的方法叫静态方法 静态成员加载类的时候分配空间，程序执行完毕后销毁 静态成员在内存中就一份。 调用语法 类名::属性 类名::方法名() 123456789&lt;?phpclass Person &#123; public static $add=&#x27;北京&#x27;; // 修饰符之间没有顺序 static public function show() &#123; echo &#x27;这是一个静态的方法&lt;br&gt;&#x27;; &#125;&#125;echo Person::$add,&#x27;&lt;br&gt;&#x27;; //北京Person::show(); //这是一个静态的方法 💡 注意：self表示所在类的类名，使用self降低耦合性 静态成员也可以被继承 12345678910111213&lt;?phpclass Person &#123; public static $add=&#x27;中国&#x27;; public static function show() &#123; echo &#x27;这是人类&lt;br&gt;&#x27;; &#125;&#125;//继承class Student extends Person &#123;&#125;//测试echo Student::$add,&#x27;&lt;br&gt;&#x27;; //中国 通过子类名称访问父类的静态成员Student::show(); //这是人类 静态延时绑定 static表示当前对象所属的类 123456789101112131415161718192021&lt;?phpclass Person &#123; public static $type=&#x27;人类&#x27;; public function show1() &#123; //var_dump($this); //object(Student)#1 (0) &#123; &#125; //echo self::$type,&#x27;&lt;br&gt;&#x27;; //人类 echo static::$type,&#x27;&lt;br&gt;&#x27;; //学生 延时绑定 &#125;&#125;class Student extends Person &#123; public static $type=&#x27;学生&#x27;; public function show2() &#123; //var_dump($this); //object(Student)#1 (0) &#123; &#125; //echo self::$type,&#x27;&lt;br&gt;&#x27;; //学生 echo static::$type,&#x27;&lt;br&gt;&#x27;; //学生 &#125;&#125;//测试$obj=new Student();$obj-&gt;show1();$obj-&gt;show2(); 小结： 1、static在内存中就一份，在类加载的时候分配空间 2、如果有多个修饰符，修饰符之间是没有顺序的 3、self表示所在类的类名 4、static表示当前对象所属的类 5、static有两个作用，第一表示静态的，第二表示类名 4.2 final【最终的】final修饰的方法不能被重写 final修饰的类不能被继承 4.2.1 作用1、如果一个类确定不被继承，一个方法确定不会被重写，用final修饰可以提高执行效率。 2、如果一个方法不允许被其他类重写，可以用final修饰。 4.3 abstract【抽象的】 abstract修饰的方法是抽象方法，修饰的类是抽象类 只有方法的声明没有方法的实现称为抽象方法 一个类中只要有一个方法是抽象方法，这个类必须是抽象类。 抽象类的特点是不能被实例化 子类继承了抽象类，就必须重新实现父类的所有的抽象方法，否则不允许实例化 类中没有抽象方法也可以声明成抽象类，用来阻止类的实例化 4.3.1 抽象类的作用1、定义命名规范 2、阻止实例化，如果一个类中所有的方法都是静态方法，这时候没有必要去实例化，可以通过abstract来阻止来的实例化。 5 类常量类常量是const常量 123456&lt;?phpclass Student &#123; //public const ADD； //7.1以后才支持访问修饰符 const ADD=&#x27;地址不详&#x27;;&#125;echo Student::ADD; 问题：define常量和const常量的区别？ 答：const常量可以做类成员，define常量不可以做类成员。 问题：常量和静态的属性的区别？ 答：相同点：都在加载类的时候分配空间 不同点：常量的值不可以更改，静态属性的值可以更改 6 接口（interface）6.1 接口 如果一个类中所有的方法是都是抽象方法，那么这个抽象类可以声明成接口 接口是一个特殊的抽象类，接口中只能有抽象方法和常量 接口中的抽象方法只能是public，可以省略，默认也是public的 通过implements关键字来实现接口 不能使用abstract和final来修饰接口中的抽象方法。 123456789101112131415161718&lt;?php//声明接口interface IPerson &#123; const ADD=&#x27;中国&#x27;; function fun1(); function fun2();&#125;//接口实现class Student implements IPerson &#123; public function fun1() &#123; &#125; public function fun2() &#123; &#125;&#125;//访问接口中的常量echo IPerson::ADD; 6.2 接口的多重实现类不允许多重继承，但是接口允许多重实现。 12345678910111213141516&lt;?phpinterface IPic1 &#123; function fun1();&#125;interface IPic2 &#123; function fun2();&#125;//接口允许多重实现class Student implements IPic1,IPic2 &#123; public function fun1() &#123; &#125; public function fun2() &#123; &#125;&#125; 注意： 1、在接口的多重实现中，如果有同名的方法，只要实现一次即可 2、类可以继承的同时实现接口 123class Student extends Person implements IPIc1,IPic1&#123;&#125; 7 匿名类这是了解的内容，PHP7.0支持 123456789101112&lt;?php$stu=new class &#123; public $name=&#x27;tom&#x27;; public function __construct() &#123; echo &#x27;构造函数&lt;br&gt;&#x27;; &#125;&#125;;echo $stu-&gt;name;/*运行结果；构造函数tom*/ 小结： 1、如果类只被实例化一次就可以使用匿名类 2、好处，在执行的过程中，类不占用空间 8 方法绑定这是了解的内容，PHP7.0支持 123456789101112&lt;?php$stu=new class &#123; public $name=&#x27;tom&#x27;; public function __construct() &#123; echo &#x27;构造函数&lt;br&gt;&#x27;; &#125;&#125;;echo $stu-&gt;name;/*运行结果；构造函数tom*/ 小结： 1、如果类只被实例化一次就可以使用匿名类 2、好处，在执行的过程中，类不占用空间 9 异常处理集中处理在代码块中发生的异常。 在代码块中发生了异常直接抛出，代码块中不处理异常，将异常集中起来一起处理。 9.1 使用的关键字12345try:监测代码块catch:捕获异常throw:抛出异常finally:无论有无异常都会执行，可以省略Exception：异常类 语法结构 12345678try&#123;\t//检测代码&#125;catch(Exception $ex)&#123;\t//捕获异常&#125;finally&#123;\t//不论是否有异常，都要执行，finally可以省略&#125; 9.2 自定义异常场景：如果实现异常的分类处理？比如异常有三个级别异常对应三种处理方式 自定义三种异常即可 所有异常类的父类是Exception，Exception中的方法不允许重写","tags":["PHP"],"categories":["Language"]},{"title":"PHP面向对象-1-类&对象&属性&访问修饰符","path":"/p/b78a5232/","content":"1 面向对象介绍1.1 介绍面向对象是一个编程思想。编程思想有面向过程和面向对象 面向过程：编程思路集中的是过程上 面向对象：编程思路集中在参与的对象 以去饭馆吃饭为例： 面向过程：点菜——做菜——上菜——吃饭——结账——收拾 面向对象：服务员，厨师，客人 1.2 面向对象的好处 多人合作方便 减少代码冗余，灵活性高 代码的可重用性发挥到极致 可扩展性强 1234多学一招：OOP：面向对象编程（Object Oriented Programming，面向对象编程）OOA: 面向对象分析(Object-Oriented Analysis,OOA)OOD: 面向对象设计（Object-Oriented Design，OOD） 2 类和对象1、对象是具体存在的事物，对象是由属性（变量）和方法（函数）组成的 2、类是具有相同属性和行为的一组对象的集合 分析：做菜动作——厨师对象——厨师类结论：我们在开发的时候，先写类，通过类创建对象，然后调用对象的属性和方法实现功能。 类——对象——调用成员 💡 注意：一个类可以创建多个对象 小结： 1、对象是由属性和方法组成的 2、类是所有对象的相同属性和方法的集合 3、在开发的时候先写类，通过类创建对象，通过对象调用方法和属性 4、一个类可以创建多个对象 3 在PHP中实现类和对象3.1 创建类语法： 1234567class 类名&#123; //属性 //方法 //常量&#125;类是由属性、方法、常量组成的，也可以说类成员有：属性、方法、常量 类名的命名规则： 以字母、下划线开头，后面跟的是字母、数字、下划线 不能用PHP关键字做类名 类名不区分大小写（变量名区分，关键字、类名不区分大小写） 类名用帕斯卡命名法（大驼峰 单词的首字母大写） 123&lt;?phpclass Student &#123;&#125; 3.2 对象实例化通过new关键字来实例化对象。 123456789&lt;?php//定义类class Student &#123;&#125;//实例化对象$stu1=new Student();$stu2=new Student; //小括号可以省略var_dump($stu1,$stu2); //object(Student)#1 (0) &#123; &#125; object(Student)#2 (0) &#123; &#125; 3.3 对象的比较💡 注意：对象的传递是地址传递 相等：结构和保存的值一样就相等全等：指向同一个对象才是全等。 12345678910111213141516&lt;?php//定义类class Student &#123;&#125;//实例化对象$stu1=new Student();$stu2=new Student;$stu3=$stu2; //对象传递的是地址//var_dump($stu1,$stu2,$stu3); //object(Student)#1 (0) &#123; &#125; object(Student)#2 (0) &#123; &#125; object(Student)#2 (0) &#123; &#125;//对象比较var_dump($stu1==$stu2); //bool(true) ,比较对象的结构echo &#x27;&lt;br&gt;&#x27;;var_dump($stu1===$stu2); //bool(false) $stu1和$stu2是否是同一个对象echo &#x27;&lt;br&gt;&#x27;;var_dump($stu2===$stu3); //bool(true) $stu2和$stu3是同一个对象 4 属性属性本质就是变量 通过-&gt;调用对象的成员 对象名-&gt;属性名 对象名-&gt;方法名() 12345678910111213141516171819202122232425&lt;?php//定义类class Student &#123; public $name; //属性 public $add=&#x27;地址不详&#x27;; //属性&#125;//实例化对象$stu=new Student();//print_r($stu); //Student Object ( [name] =&gt; [add] =&gt; 地址不详 )//操作属性//1、给属性赋值$stu-&gt;name=&#x27;tom&#x27;;$stu-&gt;add=&#x27;北京&#x27;;//2、获取属性的值echo &#x27;姓名：&#x27;.$stu-&gt;name,&#x27;&lt;br&gt;&#x27;; //姓名：tomecho &#x27;地址：&#x27;.$stu-&gt;add,&#x27;&lt;br&gt;&#x27;; //地址：北京//3、添加属性$stu-&gt;age=20;print_r($stu); //Student Object ( [name] =&gt; tom [add] =&gt; 北京 [age] =&gt; 20 )echo &#x27;&lt;br&gt;&#x27;;//4、删除属性unset($stu-&gt;add);print_r($stu); //Student Object ( [name] =&gt; tom [age] =&gt; 20 ) 5 方法方法的本质就是函数 1234567891011121314&lt;?phpclass Student &#123; //定义方法 public function show() &#123; echo &#x27;这是show方法&lt;br&gt;&#x27;; &#125; //public可以省略，如果省略，默认就是public function test() &#123; echo &#x27;这是test方法&lt;br&gt;&#x27;; &#125;&#125;$stu=new Student;$stu-&gt;show(); //调用方法$stu-&gt;test(); 多学一招： 1、方法前面public是可以省略的，如果省略，默认就是public的。 2、属性前面的public不能省略 6 访问修饰符用来控制成员的访问权限 修饰符 描述 public（公有的） 在类的内部和外部都能访问 private（私有的） 只能在类的内部访问 protected（受保护的） 在整个继承链上访问 多学一招：一般来说，属性都用私有的，通过公有的方法对私有的属性进行赋值和取值。 作用：保证数据的合法性 💡 提示：$this表示调用当前方法的对象 7 类和对象在内存中的分布 对象的本质是一个复杂的变量 类的本质是一个自定义的复杂数据类型 栈区：运行速度快，体积小，保存基本类型 堆区：运行速度稍慢，体积大，保存复杂类型 实例化的过程就是分配内存空间的过程 对象保存在堆区，将堆区的地址保存到栈区 8 封装封装就是有选择性的提供数据 通过访问修饰符来实现封装 9 构造方法9.1 介绍构造方法也叫构造函数，当实例化对象的时候自动执行。语法： 123function __construct()&#123;&#125;注意：前面是两个下划线 💡 注意：在其他语言里，与类名同名的函数是构造函数，在PHP中不允许这种写法。 10 析构方法10.1 介绍当对象销毁的时候自动调用 语法 12function __destruct()&#123;&#125; 脚下留心：析构函数不可以带参数 11 继承11.1 继承介绍 继承使得代码具有层次结构 子类继承了父类的属性和方法，实现了代码的可重用性。 使用extends关键字实现继承 父类和子类是相对的 语法 12class 子类 extends 父类&#123;&#125; 11.2 子类中调用父类成员1、方法一：通过实例化父类调用父类的成员 2、方法二：通过$this关键字调用父类的成员 11.3 protectedprotected：受保护的，在整个继承链上使用 11.4 继承中的构造函数规则： 1231、如果子类有构造函数就调用子类的，如果子类没有就调用父类的构造函数。2、子类的构造函数调用后，默认不再调用父类的构造函数 通过类名调用父类的构造函数 1类名::__construct() 💡 注意：可以用parent关键字表示父类的名字，可以降低程序的耦合性 11.5 $this详解$this表示当前对象的引用，也就是是或**$this**保存的当前对象的地址 11.6 多重继承PHP不允许多重继承，因为多重继承容易产生二义性 如何实现C继承A和B，使用继承链","tags":["PHP"],"categories":["Language"]},{"title":"PHP基础-3-文件操作","path":"/p/a73ab557/","content":"1 文件操作1.1 将字符串写入文件123&lt;?php$str=&quot;床前明月光，\\r 疑是地上霜。\\r 举头望明月，\\r 低头思故乡。&quot;;file_put_contents(&#x27;./test.txt&#x27;,$str); //将字符串写到文本中 小结： 1、 所有的“写”操作都是清空重写 2、在文本中换行是\\r 123\\r:回车 光标移动到当前行的最前面 :换行 将光标下移动一行按键盘的回车键做了两步，第一步将光标移动到当前行的最前面，第二步下移一行。 3、\\r 是特殊字符，必须放在双引号内 1.2 将整个文件读入一个字符串123456//方法一：echo file_get_contents(&#x27;./test.txt&#x27;); //将整个文件读入一个字符串//方法二：readfile(&#x27;./test.txt&#x27;); //读取输出文件内容//注意：echo file_get_contents()==readfile() 1.3 打开文件并操作12345fopen(地址,模式) 打开文件模式：r：读 readw:写 writea:追加 append 1234567891011121314151617181920//3.1、打开文件写入/*$fp=fopen(&#x27;./test.txt&#x27;,&#x27;w&#x27;); //打开文件返回文件指针（文件地址）//var_dump($fp); //resource(3) of type (stream) for($i=1;$i&lt;=10;$i++)\tfputs($fp,&#x27;关关雎鸠&#x27;.&quot;\\r &quot;);\t//写一行fclose($fp);\t//关闭文件*///3.2 打开文件读取/*$fp=fopen(&#x27;./test.txt&#x27;,&#x27;r&#x27;);\t//打开文件读取while($line=fgets($fp))&#123;\techo $line,&#x27;&lt;br&gt;&#x27;;&#125;*///3.3 打开文件追加$fp=fopen(&#x27;./test.txt&#x27;,&#x27;a&#x27;);\t//打开文件追加fputs($fp,&#x27;在河之洲&#x27;); //在文件末尾追加 小结： 1、打开文件，返回文件指针（文件指针就是文件地址），资源类型 2、打开文件写、追加操作，如果文件不存在，就创建新的文件 3、打开文件读操作，文件不存在就报错 4、fputs()写一行，fgets()读一行，fclose()关闭文件 5、追加是在文件的末尾追加 1.4 是否是文件【is_file()】1echo is_file(&#x27;./test.txt&#x27;)?&#x27;是文件&#x27;:&#x27;不是文件&#x27;; 1.5 判断文件或文件夹是否存在【file_exists()】1echo file_exists(&#x27;./test.txt&#x27;)?&#x27;文件存在&#x27;:&#x27;文件不存在&#x27;; 1.6 删除文件【unlink】123456789$path=&#x27;./test.txt&#x27;;if(file_exists($path))&#123; //文件存在 if(is_dir($path)) //如果是文件夹用rmdir()删除 rmdir($path); elseif(is_file($Path)) //如果是文件用unlink()删除 unlink($path);&#125;else&#123; echo &#x27;文件夹或文件不存在&#x27;;&#125; 1.7 二进制读取【fread(文件指针，文件大小)】文件的存储有两种：字符流和二进制流 二进制流的读取按文件大小来读的。 1234$path=&#x27;./face.jpg&#x27;;$fp=fopen($path,&#x27;r&#x27;);header(&#x27;content-type:image/jpeg&#x27;); //告知浏览器下面的代码通过jpg图片方式解析echo fread($fp,filesize($path)); //二进制读取 多学一招：file_get_contents()也可以进行二进制读取 12header(&#x27;content-type:image/jpeg&#x27;);echo file_get_contents(&#x27;./face.jpg&#x27;); 小结： 1、文本流有明确的结束符，二进制流没有明确的结束符，通过文件大小判断文件是否读取完毕 2、file_get_contents()既可以进行字符流读取，也可以进行二进制读取。 2 表单提交数据的两种方式2.1 两种方式1、get 2、post 12&lt;form method=&quot;post&quot; action=&quot;&quot;&gt;&lt;/form&gt;&lt;form method=&quot;get&quot; action=&quot;&quot;&gt;&lt;/form&gt; 2.2 区别1、外观上看 get提交在地址上可以看到参数 post提交在地址栏上看不到参数 2、安全性 get不安全 post安全 3、提交原理 get提交是参数一个一个的提交 post提交是所有参数作为一个整体一起提交 4、提交数据大小 get提交一般不超过255个字节 post提交的大小取决于服务器 12// 在php.ini中，可以配置post提交的大小post_max_size = 8M 5、灵活性 get很灵活，只要有页面的跳转就可以传递参数 post不灵活，post提交需要有表单的参与 1234567891011121、 html跳转 &lt;a href=&quot;index.php?name=tom&amp;age=20&quot;&gt;跳转&lt;/a&gt;2、JS跳转&lt;script type=&quot;text/javascript&quot;&gt; location.href=&#x27;index.php?name=tom&amp;age=20&#x27;; location.assign(&#x27;index.php?name=tom&amp;age=20&#x27;); location.replace(&#x27;index.php?name=tom&amp;age=20&#x27;);&lt;/script&gt;3、PHP跳转header(&#x27;location:index.php?name=tom&amp;age=22&#x27;) 小结： 12&lt;form method=&quot;post&quot; action=&quot;&quot;&gt;&lt;/form&gt;&lt;form method=&quot;get&quot; action=&quot;&quot;&gt;&lt;/form&gt; 3 服务器接受数据的三种方式通过名字获取名字对应的值 123$_POST：数组类型，保存的POST提交的值$_GET：数组类型，保存的GET提交的值$_REQUEST：数组类型，保存的GET和POST提交的值 在一个请求中，既有get又有post，get和post传递的名字是一样的，这时候通过$_REQUET获取的数据是什么? 答：结果取决于配置文件 1request_order = &quot;GP&quot; # 先获取GET，在获取POST值 小结： 1、在开发的时候，如果明确是post提交就使用$_POST获取，如果明确get提交就用$_GET获取 2、request获取效率低，尽可能不要使用，除非提交的类型不确定的情况下才使用。 4 参数传递4.1 复选框值的传递复选框的命名要注意带’[]’。 123456789101112131415&lt;body&gt;&lt;?phpif(isset($_POST[&#x27;button&#x27;])) &#123; print_r($_POST[&#x27;hobby&#x27;]);&#125;?&gt;&lt;form method=&quot;post&quot; action=&quot;&quot;&gt; 爱好： &lt;input type=&quot;checkbox&quot; name=&quot;hobby[]&quot; value=&#x27;爬山&#x27;&gt;爬山 &lt;input type=&quot;checkbox&quot; name=&quot;hobby[]&quot; value=&#x27;抽烟&#x27;&gt;抽烟 &lt;input type=&quot;checkbox&quot; name=&quot;hobby[]&quot; value=&#x27;喝酒&#x27;&gt;喝酒 &lt;input type=&quot;checkbox&quot; name=&quot;hobby[]&quot; value=&#x27;烫头&#x27;&gt;烫头 &lt;input type=&quot;submit&quot; name=&quot;button&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt; 小结： 1、表单提交到本页面需要判断一下是否有post提交 2、数组的提交表单元素的名字必须带有[] 5 文件上传开发中需要上传图片、音乐、视频等等，这种上传传递是二进制数据。 5.1 客户端上传文件文件域 1&lt;input type=&quot;file&quot; name=&quot;image&quot;&gt; 表单的enctype属性 默认情况下，表单传递是字符流，不能传递二进制流，通过设置表单的enctype属性传递复合数据。 enctype属性的值有： application&#x2F;x-www-form-urlencoded：【默认】，表示传递的是带格式的文本数据。 multipart&#x2F;form-data：复合的表单数据（字符串，文件），文件上传必须设置此值 text&#x2F;plain：用于向服务器传递无格式的文本数据，主要用户电子邮件 单词 12multipart：复合form-data：表单数组 5.2 服务器接受文件超全局变量$_FILES是一个二维数组，用来保存客户端上传到服务器的文件信息。二维数组的行是文件域的名称，列有5个。1、$_FILES[][‘name’]：上传的文件名2、$_FILES[][‘type]：上传的类型，这个类型是MIME类型（image&#x2F;jpeg、image&#x2F;gif、image&#x2F;png）3、$_FILES[][‘size’]：文件的大小，以字节为单位4、$_FILES[][‘tmp_name’]：文件上传时的临时文件5、$_FILES[][‘error’]：错误编码(值有0、1、2、3、4、6、7)0表示正确 $_FILES[][‘error’]详解 值 错误描述 0 正确 1 文件大小超过了php.ini中允许的最大值 upload_max_filesize &#x3D; 2M 2 文件大小超过了表单允许的最大值 3 只有部分文件上传 4 没有文件上传 6 找不到临时文件 7 文件写入失败 注意：MAX_FILE_SIZE必须在文件域的上面。 只要掌握的错误号：0和4 5.3 将上传文件移动到指定位置函数： 1move_uploaded_file(临时地址,目标地址) 代码 1234567891011121314151617&lt;body&gt;&lt;?phpif(!empty($_POST)) &#123; if($_FILES[&#x27;face&#x27;][&#x27;error&#x27;]==0)&#123; //上传正确 //文件上传 move_uploaded_file($_FILES[&#x27;face&#x27;][&#x27;tmp_name&#x27;],&#x27;./&#x27;.$_FILES[&#x27;face&#x27;][&#x27;name&#x27;]); &#125;else&#123; echo &#x27;上传有误&#x27;; echo &#x27;错误码:&#x27;.$_FILES[&#x27;face&#x27;][&#x27;error&#x27;]; &#125;&#125;?&gt;&lt;form method=&quot;post&quot; action=&quot;&quot; enctype=&#x27;multipart/form-data&#x27;&gt; &lt;input type=&quot;file&quot; name=&quot;face&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;button&quot; value=&quot;上传&quot;&gt;&lt;/form&gt;&lt;/body&gt; 小结：上传的同名的文件要给覆盖 5.4 与文件上传有关的配置123456789post_max_size = 8M：表单允许的最大值upload_max_filesize = 2M：允许上传的文件大小upload_tmp_dir =F:\\wamp\\tmp：指定临时文件地址，如果不知道操作系统指定file_uploads = On：是否允许文件上传max_file_uploads = 20：允许同时上传20个文件 6 优化文件上传6.1 更改文件名方法一：通过时间戳做文件名 1234&lt;?php$path=&#x27;face.stu.jpg&#x27;;//echo strrchr($path,&#x27;.&#x27;); //从最后一个点开始截取，一直截取到最后echo time().rand(100,999).strrchr($path,&#x27;.&#x27;); 方法二：通过uniqid()实现 1234$path=&#x27;face.stu.jpg&#x27;;echo uniqid().strrchr($path,&#x27;.&#x27;),&#x27;&lt;br&gt;&#x27;; //生成唯一的IDecho uniqid(&#x27;goods_&#x27;).strrchr($path,&#x27;.&#x27;),&#x27;&lt;br&gt;&#x27;; //带有前缀echo uniqid(&#x27;goods_&#x27;,true).strrchr($path,&#x27;.&#x27;),&#x27;&lt;br&gt;&#x27;; //唯一ID+随机数 6.2 验证文件格式方法一：判断文件的扩展名（不能识别文件伪装） 操作思路：将文件的后缀和允许的后缀对比 12345678910111213141516&lt;body&gt;&lt;?phpif(!empty($_POST)) &#123; $allow=array(&#x27;.jpg&#x27;,&#x27;.png&#x27;,&#x27;.gif&#x27;); //允许的扩展名 $ext=strrchr($_FILES[&#x27;face&#x27;][&#x27;name&#x27;],&#x27;.&#x27;); //上传文件扩展名 if(in_array($ext,$allow)) echo &#x27;允许上传&#x27;; else echo &#x27;文件不合法&#x27;;&#125;?&gt;&lt;form method=&quot;post&quot; action=&quot;&quot; enctype=&#x27;multipart/form-data&#x27;&gt; &lt;input type=&quot;file&quot; name=&quot;face&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;button&quot; value=&quot;上传&quot;&gt;&lt;/form&gt;&lt;/body&gt; 注意：比较扩展名不能防止文件伪装。 方法二：通过$_FIELS[][&#39;type&#39;]类型（不能识别文件伪装） 12345678910111213141516&lt;body&gt;&lt;?phpif(!empty($_POST)) &#123; $allow=array(&#x27;image/jpeg&#x27;,&#x27;image/png&#x27;,&#x27;image/gif&#x27;); //允许的类别 $mime=$_FILES[&#x27;face&#x27;][&#x27;type&#x27;]; //上传文件类型 if(in_array($mime,$allow)) echo &#x27;允许上传&#x27;; else echo &#x27;文件不合法&#x27;;&#125;?&gt;&lt;form method=&quot;post&quot; action=&quot;&quot; enctype=&#x27;multipart/form-data&#x27;&gt; &lt;input type=&quot;file&quot; name=&quot;face&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;button&quot; value=&quot;上传&quot;&gt;&lt;/form&gt;&lt;/body&gt; 注意：比较$_FIELS[][&#39;type&#39;]不能防止文件伪装。 方法三：php_fileinfo扩展（可以防止文件伪装） 在php.ini中开启fileinfo扩展 1extension=php_fileinfo.dll 注意：开启fileinfo扩展以后，就可以使用finfo_*的函数了 123456789101112131415161718&lt;body&gt;&lt;?phpif(!empty($_POST)) &#123; //第一步：创建finfo资源 $info=finfo_open(FILEINFO_MIME_TYPE); //var_dump($info); //resource(2) of type (file_info) //第二步：将finfo资源和文件做比较 $mime=finfo_file($info,$_FILES[&#x27;face&#x27;][&#x27;tmp_name&#x27;]); //第三步，比较是否合法 $allow=array(&#x27;image/jpeg&#x27;,&#x27;image/png&#x27;,&#x27;image/gif&#x27;); //允许的类别 echo in_array($mime,$allow)?&#x27;合法&#x27;:&#x27;不合法&#x27;;&#125;?&gt;&lt;form method=&quot;post&quot; action=&quot;&quot; enctype=&#x27;multipart/form-data&#x27;&gt; &lt;input type=&quot;file&quot; name=&quot;face&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;button&quot; value=&quot;上传&quot;&gt;&lt;/form&gt;&lt;/body&gt; 小结：验证文件格式有三种方法 1、可以验证扩展名（不可以防止文件伪装） 2、通过$_FILES[][&#39;type&#39;]验证（不可以防止文件伪装） 3、通过file_info扩展（可以防止文件伪装）","tags":["PHP"],"categories":["Language"]},{"title":"PHP基础-2-作用域&递归&文件夹操作","path":"/p/f60eefa5/","content":"1 作用域1.1 变量作用域1、全局变量：在函数外面 2、局部变量：在函数里面，默认情况下，函数内部是不会去访问函数外部的变量 3、超全局变量：可以在函数内部和函数外部访问 | $GLOBALS || — || $_SERVER || $_GET || $_POST || $_FILES || $_COOKIE || $_SESSION || $_REQUEST || $_ENV | global关键字 12345678910111213141516171819&lt;?php$num=10;function fun() &#123;\tglobal $num; //将全局变量的$num的地址引入到函数内部 相当于$num=&amp;GLOBALS[&#x27;num&#x27;]\techo $num;\t//10\t$num=100;&#125;fun();echo &#x27;&lt;br&gt;&#x27;;echo $num; //100-----------------------------------&lt;?php$num=10;function fun() &#123;\tglobal $num;\tunset($num); //销毁的是引用，不是具体的值&#125;fun();echo $num; //10 小结： 1、$GLOBALS保存的是全局变量的所有的值 2、global用于创建一个全局变量的引用 💡 注意：常量没有作用域的概念 1.2 静态变量（static）静态变量一般指的是静态局部变量。 静态变量只初始化一次 1.2.1 常量和静态变量的区别1、常量和静态变量都是初始化一次 2、常量不能改变值，静态变量可以改变值 3、常量没有作用域，静态变量有作用域 12345678910111213141516171819&lt;?phpfunction fun1() &#123;\tdefine(&#x27;num&#x27;,10);&#125;function fun2() &#123;\techo num; //10&#125;fun1();fun2();------------------------------------------------------------&lt;?phpfunction fun1() &#123;\tstatic $num=10;&#125;function fun2() &#123;\techo $num; //Notice: Undefined variable: num 因为静态变量是有作用域的&#125;fun1();fun2(); 1.3 匿名函数use()默认情况下，函数内部不能访问函数外部的变量，但在匿名函数中，可以通过use将外部变量引入匿名函数中 123456&lt;?php$num=10;$fun=function() use($num) &#123; //将$num引入到匿名函数中\techo $num;\t&#125;;$fun(); //10 思考：如何在函数内部访问函数外部变量 1、使用超全局变量 2、$GLOBALS 3、global 4、use将函数外部变量引入到匿名函数内部 2 递归函数内部自己调用自己 递归有两个元素，一个是递归点（从什么地方递归），第二递归出口 3 包含文件3.1 包含文件的方式1、require：包含多次 2、include：包含多次 3、require_once： 包含一次 4、include_once： 包含一次 💡 小结： 1、require遇到错误抛出error类别的错误，停止执行 2、include遇到错误抛出warning类型的错误，继续执行 3、require_once、include_once只能包含一次 4、HTML类型的包含页面中存在PHP代码，如果包含到PHP中是可以被执行的 5、包含文件相当于把包含文件中的代码拷贝到主文件中执行，魔术常量除外，魔术常量获取的是所在文件的信息。 6、包含在编译时不执行、运行时加载到内存、独立编译包含文件 3.2 包含文件的路径12./ 当前目录../ 上一级目录 12require &#x27;./head.html&#x27;; //在当前目录下查找require &#x27;head.html&#x27;; //受include_path配置影响 include_path的使用场景： 如果包含文件的目录结构比较复杂，比如：在c:\\aa\\bb\\cc\\dd中有多个文件需要包含，可以将包含的路径设置成include_path，这样包含就只要写文件名就可以了 1234&lt;?phpset_include_path(&#x27;c:\\aa\\bb\\cc\\dd&#x27;); //设置include_pathrequire &#x27;head1.html&#x27;; //受include_path配置影响require &#x27;head2.html&#x27;; include_path可以设置多个，路径之间用分号隔开 1set_include_path(&#x27;c:\\aa\\bb\\cc\\dd;d:\\\\&#x27;); 4 错误处理4.1 错误的级别 notice：提示 warning：警告 error：致命错误 notice和warning报错后继续执行，error报错后停止执行 4.2 错误的提示方法方法一：显示在浏览器上 方法二：记录在日志中 4.3 与错误处理有关的配置在php.ini中 123451. error_reporting = E_ALL：报告所有的错误2. display_errors = On：将错误显示在浏览器上3. log_errors = On：将错误记录在日志中4. error_log=’地址’：错误日志保存的地址 在项目开发过程中有两个模式，开发模式，运行模式 123开发模式：错误显示在浏览器上，不要记录在日志中运行模式：错误不显示在浏览器上，记录是日志中 5 文件编程5.1 文件夹操作1 、创建文件夹【mkdir(路径，权限，是否递归创建)】 12make:创建directory：目录，文件夹 例题 12345&lt;?php//1、创建目录//mkdir(&#x27;./aa&#x27;); //创建aa文件夹//mkdir(&#x27;./aa/bb&#x27;); //在aa目录下创建bb(aa目录必须存在)mkdir(&#x27;./aa/bb/cc/dd&#x27;,0777,true); //递归创建 小结： 1、0777表示是文件夹的权限，在Linux中会详细讲解 2、true表示递归创建，默认是false 2、删除文件夹【rmdir()】 123//remove:移除rmdir(&#x27;./aa/bb/cc/dd&#x27;); //删除dd文件夹 提醒： 121、删除的文件夹必须是空的2、PHP基于安全考虑，没有提供递归删除。 3、重命名文件夹【rename(旧名字，新名字)】 1rename(&#x27;./aa&#x27;,&#x27;./aaa&#x27;); //将aa改为aaa 4、是否是文件夹【is_dir()】 1echo is_dir(&#x27;./aaa&#x27;)?&#x27;是文件夹&#x27;:&#x27;不是文件夹&#x27;; 5、打开文件夹、读取文件夹、关闭文件夹 12345678$folder=opendir(&#x27;./&#x27;); //打开目录//var_dump($folder); //resource(3) of type (stream)while($f=readdir($folder))&#123; //读取文件夹 if($f==&#x27;.&#x27; || $f==&#x27;..&#x27;) continue; echo iconv(&#x27;gbk&#x27;,&#x27;utf-8&#x27;,$f),&#x27;&lt;br&gt;&#x27;; //将gbk转成utf-8&#125;closedir($folder); //关闭文件夹 小结： 1231、opendir()返回资源类型2、每个文件夹中都有.和..3、iconv()用来做字符编码转换","tags":["PHP"],"categories":["Language"]},{"title":"PHP基础-1-变量-常量-运算符-数据类型-判断-循环","path":"/p/5b8fbc6e/","content":"0 输出语句12345678echo:输出print:输出，输出成功返回1print_r()：输出数组var_dump():输出数据的详细信息，带有数据类型和数据长度&lt;?php\tvar_dump(&#x27;abc&#x27;);\t//string(3) &quot;abc&quot; ?&gt; 1 变量1.1 变量的命名规则 变量必须以$开头，$符不是变量的一部分，仅表示后面的标识符是变量名。 除了$以外，以字母、下划线开头，后面跟着数字、字母、下划线 变量名区分大小写，$aa和$Aa是两个空间 1.2 可变变量变量名可以变，将变量名存储在另外一个变量中 1234&lt;?php$a=10;$b=&#x27;a&#x27;;echo $$b;\t//10 1.3 变量传递变量的传递有值传递和地址传递（引用传递） 123456&lt;?php//值传递$num1=10;\t//将10付给$num1$num2=$num1;\t//将$num1的值付给$num2$num2=20; //更改$num2echo $num1; //10 1.4 销毁变量用unset()来销毁变量，销毁的是变量名，变量值由PHP垃圾回收机制销毁 12345&lt;?php$num1=10;$num2=&amp;$num1;unset($num1);\t//销毁的是变量名echo $num2; //10 2 常量2.1 定义常量1、用define()函数定义常量 1define(常量名，值，[是否区别大小写]) true表示不区分大小写，默认是false 2、还可以使用const关键字定义常量 12const NAME=&#x27;tom&#x27;;echo NAME; //tom 定义常量有两种方式，define()和const 常量在整个运行过程中值保持不变，常量不能重新定义 使用constant获取特殊字符做的常量名的值 defined()用来判断常量是否被定义 2.2 预定义常量123echo PHP_VERSION,&#x27;&lt;br&gt;&#x27;; //PHP版本号echo PHP_OS,&#x27;&lt;br&gt;&#x27;; //PHP操作系统echo PHP_INT_MAX,&#x27;&lt;br&gt;&#x27;; //PHP中整型的最大值 2.3 魔术常量魔术常量它们的值随着它们在代码中的位置改变而改变 123echo __LINE__,&#x27;&lt;br&gt;&#x27;; //获取当前行号echo __FILE__,&#x27;&lt;br&gt;&#x27;; //文件的完整路径和文件名echo __DIR__,&#x27;&lt;br&gt;&#x27;; //文件所在的目录 3 数据类型3.1 基本类型（标量类型）3.1.1 整型存整数，PHP_INT_MAX获取整形最大值 机制 缩写 单词 十进制 dec decimalist 二进制 bin binary 八进制 oct octonary 十六进制 hex hexdecimalist 3.1.2 浮点型浮点数在内存中保存的是近似值 浮点数不能参与比较 123var_dump(0.9==(1-0.1)); //bool(true) echo &#x27;&lt;br&gt;&#x27;;var_dump(0.1==(1-0.9)); //bool(false) 如果浮点数要比较，必须确定比较的位数 12345var_dump(0.9==(1-0.1)); //bool(true) echo &#x27;&lt;br&gt;&#x27;;var_dump(0.1==(1-0.9)); //bool(false) echo &#x27;&lt;br&gt;&#x27;;var_dump(bccomp(0.1,1-0.9,5));\t//比较小数点后面5位 int(0) 0表示相等 💡 提醒：如果一个整数超出了整形的范围，会自动的转成浮点型 3.1.3 布尔型不能使用echo 和print输出布尔型，要使用var_dump()输出 123$name=&#x27;tom&#x27;;echo &#x27;我的名字叫$name&#x27;,&#x27;&lt;br&gt;&#x27;;\t//我的名字叫$nameecho &quot;我的名字叫$name&quot;,&#x27;&lt;br&gt;&#x27;;\t//我的名字叫tom 3.1.4 字符串型在PHP中单引号字符串和双引号字符串是有区别的 单引号字符串是真正的字符串 双引号字符串要解析字符串中的变量 123$name=&#x27;tom&#x27;;echo &#x27;我的名字叫$name&#x27;,&#x27;&lt;br&gt;&#x27;;\t//我的名字叫$nameecho &quot;我的名字叫$name&quot;,&#x27;&lt;br&gt;&#x27;;\t//我的名字叫tom 3.2 复合类型3.2.1 数组在PHP中数组有两种形式，索引数组和关联数组 索引数组：用整数做下标，默认从0开始，后面依次加一 关联数组：用字符串做下标，通过&#x3D;&gt;符号将下标和值关联起来 12345678910111213141516&lt;?php//1、索引数组的声明$stu=array(&#x27;tom&#x27;,&#x27;berry&#x27;,&#x27;ketty&#x27;); //索引数组print_r($stu);\t//输出数组 Array ( [0] =&gt; tom [1] =&gt; berry [2] =&gt; ketty ) echo &#x27;&lt;hr&gt;&#x27;;echo $stu[0],&#x27;&lt;br&gt;&#x27;;\t//tomecho $stu[1],&#x27;&lt;br&gt;&#x27;;\t//berryecho $stu[2],&#x27;&lt;hr&gt;&#x27;;\t//ketty------------------------------------------//2、关联数组$emp=array(&#x27;name&#x27;=&gt;&#x27;李白&#x27;,&#x27;sex&#x27;=&gt;&#x27;男&#x27;,&#x27;age&#x27;=&gt;22);print_r($emp);\t//Array ( [name] =&gt; 李白 [sex] =&gt; 男 [age] =&gt; 22 ) echo &#x27;&lt;hr&gt;&#x27;;echo $emp[&#x27;name&#x27;],&#x27;&lt;br&gt;&#x27;;\t//李白echo $emp[&#x27;sex&#x27;],&#x27;&lt;br&gt;&#x27;;\t//男echo $emp[&#x27;age&#x27;]; //22 二维数组的声明 12345$stu=[\t[&#x27;name&#x27;=&gt;&#x27;tom&#x27;,&#x27;sex&#x27;=&gt;&#x27;男&#x27;,&#x27;age&#x27;=&gt;22],\t[&#x27;name&#x27;=&gt;&#x27;berry&#x27;,&#x27;sex&#x27;=&gt;&#x27;女&#x27;,&#x27;age&#x27;=&gt;23]];echo &#x27;&lt;pre&gt;&#x27;; 短数组语法，可以直接通过中括号声明数组 12$stu=[&#x27;tom&#x27;,&#x27;berry&#x27;,&#x27;ketty&#x27;];print_r($stu); //Array ( [0] =&gt; tom [1] =&gt; berry [2] =&gt; ketty ) 3.2.2 对象3.3 特殊类型1、资源 2、null 3.4 类型转换1、自动类型转换：当提供的类型和需要的类型不一致的时候会自动进行类型转换 12345678$num=10;if($num)&#123; //自动将数字转成布尔型\techo &#x27;aa&#x27;;&#125;else&#123;\techo &#x27;bb&#x27;;&#125;---------------------------------echo &#x27;20&#x27;-10;\t//自动的将字符串转成数字 2、强制类型转换 语法：（数据类型）数据 其他类型和布尔之间的转换 规则：0、空为假，非0非空为真 12345&lt;?phpvar_dump((bool)&#x27;abc&#x27;);\techo &#x27;&lt;br&gt;&#x27;; //bool(true) var_dump((bool)&#x27;&#x27;); echo &#x27;&lt;br&gt;&#x27;; //bool(false) var_dump((bool)&#x27;0&#x27;);\techo &#x27;&lt;br&gt;&#x27;; //bool(false)?&gt; 4 运算符4.1 算术运算符 一元运算符 二元运算符 ++ + – - * &#x2F; % (取模) 4.2 关系运算符（比较运算符）1234567=&lt;&lt;=== //弱类型比较 不对数据类型作比较 &#x27;1&#x27;=1 true!====//强类型比较 对数据类型和值都进行比较 &#x27;1&#x27;=1 false!== 4.3 逻辑运算符123456&amp;\t与：运算符两边的表达式都要计算|\t或：运算符两边的表达式都要计算&amp;&amp;\t短路与：如果前面的条件不满足，后面的条件就不用计算了||\t短路或!\t非 4.4 赋值运算符123456=\t//赋值+= //a+=b a=a+b-=*=/=%= 4.5 字符串连接符(.)4.6 错误抑制符(@)错误抑制符只对表达式有效 12&lt;?phpecho @($aa+$bb);\t//错误抑制 4.7 三元运算符(?:)表达式1 ? 值1 : 值2 4.8 null合并运算符(??)PHP7.0以后才支持 例题 12&lt;?phpecho $name??&#x27;姓名不详&#x27;; //姓名不详 多学一招：两个用来判断的函数 12isset()：判断变量是否被设置，并且设置的不是nullempty()：检查一个变量是否为空，能转成false全部是空，[&#x27;&#x27;,0,0.0,array(),null] 例题 5 判断5.1 语法1、if语句 2、ifelse语句 3、switch case语句 6 循环1、for 123for(初始值;条件;增量)&#123;\t//循环体&#125; 2、while&amp;do-while 123456while(条件)&#123;&#125;-------------------------do&#123; &#125;while(条件) 3、foreach 123456//语法一foreach(数组 as 值)&#123;&#125;//语法二foreach(数组 as 键=&gt;值)&#123;&#125; 示例： 123456789101112131415161718192021&lt;?php$stu=[&#x27;tom&#x27;,&#x27;berry&#x27;,&#x27;ketty&#x27;];foreach($stu as $v)&#123;\techo $v,&#x27;&lt;br&gt;&#x27;;&#125;/**tomberryketty*/echo &#x27;&lt;hr&gt;&#x27;;-----------------------------------------------------------foreach($stu as $k=&gt;$v)&#123;\techo &quot;&#123;$k&#125;:&#123;$v&#125;&lt;br&gt;&quot;;&#125;/**0:tom1:berry2:ketty*/?&gt; 小结： for、while、do-while可以相互替换 如果明确知道循环多少次首先for循环，如要要循环到条件不成立为止选while或do-while 先判断再执行选while，先执行再判断选do-while while循环条件不成立就不执行，do-while至少执行一次 7 跳转语句123break：中断循环continue：中断当前循环，进入下一个循环 8 函数8.1 函数定义123function 函数名(参数1，参数2，...)&#123; //函数体&#125; 小结： 1、变量名区分大小写 2、关键字、函数名不区分大小写 8.2 可变函数123456&lt;?phpfunction show($args) &#123;\techo $args,&#x27;&lt;br&gt;&#x27;;&#125;$str=&#x27;show&#x27;;\t//将函数名保存到变量中$str(&#x27;锄禾日当午&#x27;); 8.3 匿名函数匿名函数就是没有名字的函数 1234567&lt;?php//匿名函数$fun=function()&#123;\techo &#x27;锄禾日当午&lt;br&gt;&#x27;;&#125;;//匿名函数调用$fun();","tags":["PHP"],"categories":["Language"]},{"title":"汇编入门学习","path":"/p/d147e7fa/","content":"汇编一、指令1 mov可以立即数到内存，寄存器到内存。内存到寄存器 1.1 mov指令操作的四种形式 [立即数] [reg] reg代表寄存器 可以是8个通用寄存器中的任意一个 [reg+立即数] [reg+reg*{1,2,4,8}] 1.2 指令格式 MOV r&#x2F;m8,r8 r通用寄存器 MOV r&#x2F;m16,r16 m代表内存 MOV r&#x2F;m32,r32 r8代表8位通用寄存器 MOV r8,r&#x2F;m8 m8代表8为内存 MOV r16,r&#x2F;m16 imm8代表8位立即数 MOV r32,r&#x2F;m32 MOV r8,imm8 MOV r16,imm16 MOV r32,imm32 2 movs移动数据 内存-内存 （EDI-ESI） MOVS BYTE PTR ES:[EDI],BYTE PTR DS:[ESI] 简写为：MOVSB MOVS WORD PTR ES:[EDI],WORD PTR DS:[ESI] 简写为：MOVSW MOVS DWORD PTR ES:[EDI],DWORD PTR DS:[ESI] 简写为：MOVSD 💡 默认DF位是0时，当完成movs操作后ESI和EDI的值会加byte,word,dword{1，2，4} 3 stos将AI&#x2F;AX&#x2F;EAX的值存储到[EDI]指定的内存单元 STOS BYTE PRT ES:[EDI] 简写为STOSB STOS WORD PRT ES:[EDI] 简写为STOSW STOS DWORD PRT ES:[EDI] 简写为STOSD 💡 默认DF位是0时，当完成stos操作后EDI的值会加byte,word,dword{1，2，4} 4 rep按计数寄存器ECX中指定的次数重复执行字符串指令 1234MOV ECX,10REP MOVSDREP STOSD 5 add5.1 指令格式 ADD r&#x2F;m8,imm8 ADD r&#x2F;m16,imm16 ADD r&#x2F;m32,imm32 ADD r&#x2F;m16,imm8 ADD r&#x2F;m32,imm8 ADD r&#x2F;m8,r8 ADD r&#x2F;m16,r16 ADD r&#x2F;m32,r32 ADD r8,,r&#x2F;m8 ADD r16,r&#x2F;m16 ADD r32,r&#x2F;m32 6 sub6.1 指令格式 SUB r&#x2F;m8,imm8 SUB r&#x2F;m16,imm16 SUB r&#x2F;m32,imm32 SUB r&#x2F;m16,imm8 SUB r&#x2F;m32,imm8 SUB r&#x2F;m8,r8 SUB r&#x2F;m16,r16 SUB r&#x2F;m32,r32 SUB r8,,r&#x2F;m8 SUB r16,r&#x2F;m16 SUB r32,r&#x2F;m32 7 and7.1 指令格式 AND r&#x2F;m8,imm8 AND r&#x2F;m16,imm16 AND r&#x2F;m32,imm32 AND r&#x2F;m16,imm8 AND r&#x2F;m32,imm8 AND r&#x2F;m8,r8 AND r&#x2F;m16,r16 AND r&#x2F;m32,r32 AND r8,r&#x2F;m8 AND r16,r&#x2F;m16 AND r32,r&#x2F;m32 8 or8.1 指令格式 OR r&#x2F;m8,imm8 OR r&#x2F;m16,imm16 OR r&#x2F;m32,imm32 OR r&#x2F;m16,imm8 OR r&#x2F;m32,imm8 OR r&#x2F;m8,r8 OR r&#x2F;m16,r16 OR r&#x2F;m32,r32 OR r8,r&#x2F;m8 OR r16,r&#x2F;m16 OR r32,r&#x2F;m32 9 not9.1 功能进行取反操作 9.2 指令格式 NOT r32 NOT r16 NOT m16 NOT m32 10 xor10.1 指令格式 XOR r&#x2F;m8,imm8 XOR r&#x2F;m16,imm16 XOR r&#x2F;m32,imm32 XOR r&#x2F;m16,imm8 XOR r&#x2F;m32,imm8 XOR r&#x2F;m8,r8 XOR r&#x2F;m16,r16 XOR r&#x2F;m32,r32 XOR r8,r&#x2F;m8 XOR r16,r&#x2F;m16 XOR r32,r&#x2F;m32 11 push11.1 功能 向堆栈中压入数据 然后修改栈顶指针ESP寄存器地址，看数据类型byte,word,dword分别对应-1，-2，-4 11.2 指令格式 PUSH r32 PUSH r16 PUSH m16 PUSH m32 PUSH imm8&#x2F;imm16&#x2F;imm32 PUSHAD（把8个通用寄存器的值存入堆栈，其中D是DWORD） PUSHFD (把32位的eflags寄存器压入栈中，其中D是DWORD) 11.3 其他方式实现该功能 12 pop12.1 功能 将栈顶数据存储到寄存器&#x2F;内存 修改栈顶指针ESP寄存器地址，看数据类型byte,word,dword分别对应+1，+2，+4 12.2 指令格式 POP r16 POP r32 POP m16 POP m32 POPAD （把存入堆栈的8个寄存器值弹出，恢复8个寄存器的值） POPFD (把存入堆栈的32位eflags值弹出，恢复eflags值) 12.3 其他方式实现该功能 13 jmp13.1 功能 修改寄存器EIP的值 13.2 指令格式 JMP 寄存器&#x2F;立即数&#x2F;内存 14 call14.1 功能 PUSH当前call指令的下一行地址进入堆栈 往EIP内存入立即数&#x2F;寄存器&#x2F;内存 简写：jmp 立即数&#x2F;寄存器&#x2F;内存 💡 与JMP唯一的区别：在堆栈中存储call指令下一行内存地址 14.2 指令格式 CALL 立即数&#x2F;寄存器&#x2F;内存 15 ret15.1 功能 将当前栈顶数据值存入EIP ADD ESP,4 然后当前栈顶指针+4，赋值给ESP MOV EIP,[ESP-4] 15.2 指令格式 RET 16 CMP16.1 功能该指令是比较两个操作数。 实际上，它相当于SUB指令，但是相减的记过并不保存到第一个操作数中。 只是根据相减的结果来改变零标志位的,当两个操作数相等的时候,零标志位置1。 16.2 指令格式 CMP R&#x2F;M,R&#x2F;M&#x2F;IMM 17 TEST17.1 功能TEST指令相当于AND指令，只不过与的结果并不保存到第一个操作数中。 该指令在一定程序上和CMP指令时类似的,两个数值进行AND操作,结果不保存,但是会改变相应标志位. 17.2 指令格式TEST r&#x2F;m,r&#x2F;m&#x2F;imm 18 ADC18.1 功能带进位加法，两边不能同时为内存 宽度要一样 18.2 指令格式 ADC r&#x2F;m,r&#x2F;m&#x2F;imm 19 SBB19.1 功能带借位减法，两边不能同时为内存 宽度要一样 19.2 指令格式 SBB r&#x2F;m,r&#x2F;m 20 XCHG20.1 功能交换数据，两边不能同时为内存 宽度要一样 20.2 指令格式 XCHG r&#x2F;m,r&#x2F;m 21 算术位移指令21.1 SAL（算术左移）SAR Reg&#x2F;Mem, CL&#x2F;Imm 21.2 SAR（算术右移）SAR Reg&#x2F;Mem, CL&#x2F;Imm 注意：算术右移时候补最高位符号位，是1补1，是0补0 22 逻辑移位指令注意：不管是左移还是右移都是补0 22.1 SHL（逻辑左移）SHL Reg&#x2F;Mem, CL&#x2F;Imm 22.2 SHR（逻辑右移）SHR Reg&#x2F;Mem, CL&#x2F;Imm 23 循环移位指令23.1 ROL（循环左移）ROL r&#x2F;m, i8 最低位是1则补1，最低位是0则补0 23.2 ROR（循环右移）ROR r&#x2F;m, CL 最高位是1则补1，最高位是0则补0 24 带进位的循环移位指令CF位是1则补1，反之则补0 24.1 RCL（带进位循环左移）RCL r&#x2F;m, i8 24.2 RCR（带进位循环右移）RCR r&#x2F;m, CL 二、存储模式大端模式：数据高位在低位，数据低位在高位 小端模式：数据高位在高位，数据低位在低位 三 JCC1 标志寄存器 EFLAGS 2 CF（bit 0）[Carry flag]2.1 功能若算术操作产生的结果在最高有效位发生进位或者借位则将其置1，反之清零。这个标志通常用来只是无符号整型运算的溢出状态。 👉 有符号运算看O位，无符号运算看C位 2.2 例子 3 PF （bit 2）[parity flag]3.1 功能如果结果的最低有效字节包含偶数个1位，则该位置1，否则清零。 利用PF课进行奇偶校验检查： 需要传输“11001110”，数据中含有5个“1”，所以其奇校验位为“0”，同时把“110011100”数据传输给接收方，接收方收到数据时后再一次计算奇偶性，“110011100”中仍然含有5个“1”，所以接收方计算出的奇校验位还是“0”，与发送方一致，表示在此次传输过程中未发生错误 4 AF（bit 4）[Auxiliary carry flag]4.1 功能 在字操作时，发生低字节向高字节进位或借位时； 在字节操作时，发生低四位向高四位进位或借位时。 辅助进位标志AF的值被置为1，否则其值为0： 5 ZF（bit 6）[zero flag]5.1 功能零标志ZF用来反映运算结果是否为0。 若结果为0，则将其置1，反之清零 经常与CMP或者TEST等指令一起使用 6 SF（bit 7）[Sign flag]6.1 功能该标志被设置为有符号整型的最高有效位 0指示结果为正，反之则为负 7 OF（bit 11）[OverFlow flag]7.1 功能一处标志OF用于反映有符号数加减运算所得结果是否溢出。 如果是无符号数运算，是否溢出看CF位。 如果是有符号数运算，是否溢出看OF位。 8 DF（bit 10）[Oirection flag]8.1 功能这个方向标志控制串指令（MOVS,CMPS,SCAS,LODS以及STOS）设置DF标志是的串指令自动递减（从高地址向低地址方向处理字符串），清楚该标志则使得指令自动递增 STD以及CLD指令分别用于设置以及清楚DF标志 9 JCC指令 Index JCC指令 说明 EFLAGS 1 JE ，JZ 结果为零则跳转(相等时跳转) ZF&#x3D;1 2 JNE，JNZ 结果不为零则跳转(不相等时跳转) ZF&#x3D;0 3 JS 结果为负则跳转 SF&#x3D;1 4 JNS 结果为非负则跳转 SF&#x3D;0 5 JP，JPE 结果中1的个数为偶数则跳转 PF&#x3D;1 6 JNP，JPO 结果中1的个数为偶数则跳转 PF&#x3D;0 7 JO 结果溢出了则跳转 OF&#x3D;1 8 JNO 结果没有溢出则跳转 OF&#x3D;0 9 JB，JNAE 小于则跳转 (无符号数) CF&#x3D;1 10 JNB，JAE 大于等于则跳转 (无符号数) CF&#x3D;0 11 JBE，JNA 小于等于则跳转 (无符号数) CF&#x3D;1 or ZF&#x3D;1 12 JNBE，JA 大于则跳转(无符号数) CF&#x3D;0 and ZF&#x3D;0 13 JL，JNGE 小于则跳转 (有符号数) SF≠ OF 14 JNL，JGE 大于等于则跳转 (有符号数) SF&#x3D;OF 15 JLE，JNG 小于等于则跳转 (有符号数) ZF&#x3D;1 or SF≠ OF 16 JNLE，JG 大于则跳转(有符号数) ZF&#x3D;0 and SF&#x3D;OF 👉 在任何运算之前得先确定时有符号运算还是无符号运算","tags":["Assembly"],"categories":["Language"]},{"title":"shellcode编写","path":"/p/22672422/","content":"什么是ShellCode？不依赖环境，放到任何地方都可以执行的机器码 shellcode编写原则 不能有全局变量 不能使用常量字符串 不能使用系统调用 不能嵌套调用其他函数 案例思路通过TEB结构体查找PEB，然后在PEB中找到_PEB_LDR_DATA，再从_PEB_LDR_DATA中找到InLoadOrderModuleList，这是一个链表，链表内存储的是有关所有加载dll的相关信息，可以通过这个结构来进行断链dll隐藏，_LDR_DATA_TABLE_ENTRY这是链表里的node的结构体，接下来我们遍历我们想要找到的dll，拿到DllBase，之后通过PE的知识解析，从中找到导出表，从导出表中拿到GetProcAddress和LoadLibraryA函数，之后就可以通过这两个函数进行加载dll和使用dll中的函数。 其中有关_LDR_DATA_TABLE_ENTRY结构体内容如下，可以参考看看 12345678910111213141516171819202122232425262728293031//0x50 bytes (sizeof)struct _LDR_DATA_TABLE_ENTRY&#123; struct _LIST_ENTRY InLoadOrderLinks; //0x0 struct _LIST_ENTRY InMemoryOrderLinks; //0x8 struct _LIST_ENTRY InInitializationOrderLinks; //0x10 VOID* DllBase; //0x18 VOID* EntryPoint; //0x1c ULONG SizeOfImage; //0x20 struct _UNICODE_STRING FullDllName; //0x24 struct _UNICODE_STRING BaseDllName; //0x2c ULONG Flags; //0x34 USHORT LoadCount; //0x38 USHORT TlsIndex; //0x3a union &#123; struct _LIST_ENTRY HashLinks; //0x3c struct &#123; VOID* SectionPointer; //0x3c ULONG CheckSum; //0x40 &#125;; &#125;; union &#123; ULONG TimeDateStamp; //0x44 VOID* LoadedImports; //0x44 &#125;; VOID* EntryPointActivationContext; //0x48 VOID* PatchInformation; //0x4c&#125;; 实例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167// demo08shellcode.cpp : Defines the entry point for the console application.//#include &quot;stdafx.h&quot;#include &lt;windows.h&gt;//functiontypedef FARPROC (WINAPI *GETPROCADDRESS)(HMODULE hModule,LPCSTR lpProcName); typedef int (WINAPI *MESSAGEBOXA)(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType);typedef HMODULE (WINAPI *LOADLIBRARYA)(LPCSTR lpLibFileName);GETPROCADDRESS PGETPROCADDRESS;MESSAGEBOXA PMESSAGEBOX;LOADLIBRARYA PLOADLIBRARY;//structtypedef struct _UNICODE_STRING&#123; USHORT Length; //0x0 USHORT MaximumLength; //0x2 PWSTR Buffer; //0x4&#125;UNICODE_STRING;//0x0 bytes (sizeof)//0x28 bytes (sizeof)typedef struct _PEB_LDR_DATA&#123; DWORD Length; //0x0 BYTE Initialized; //0x4 VOID* SsHandle; //0x8 LIST_ENTRY InLoadOrderModuleList; //0xc LIST_ENTRY InMemoryOrderModuleList; //0x14 LIST_ENTRY InInitializationOrderModuleList; //0x1c VOID* EntryInProgress; //0x24&#125;PEB_LDR_DATA; typedef struct _LDR_DATA_TABLE_ENTRY&#123; LIST_ENTRY InLoadOrderLinks; //0x0 LIST_ENTRY InMemoryOrderLinks; //0x8 LIST_ENTRY InInitializationOrderLinks; //0x10 VOID* DllBase; //0x18 VOID* EntryPoint; //0x1c DWORD SizeOfImage; //0x20 UNICODE_STRING FullDllName; //0x24 UNICODE_STRING BaseDllName; //0x2c DWORD Flags; //0x34 WORD LoadCount; //0x38 WORD TlsIndex; //0x3a union &#123; LIST_ENTRY HashLinks; //0x3c struct &#123; VOID* SectionPointer; //0x3c DWORD CheckSum; //0x40 &#125;; &#125;; union &#123; DWORD TimeDateStamp; //0x44 VOID* LoadedImports; //0x44 &#125;; VOID* EntryPointActivationContext; //0x48 VOID* PatchInformation; //0x4c&#125;LDR_DATA_TABLE_ENTRY; int strcmp(char* buf1,char* buf2)&#123;\twhile(*buf1 &amp;&amp; *buf2 &amp;&amp; *buf1 == *buf2)&#123; buf1++; buf2++;\t&#125;\tif (*buf1 == *buf2)\t&#123; return 1;\t&#125;\treturn 0;&#125;void ToShellcode()&#123;\tLDR_DATA_TABLE_ENTRY *pPLD = NULL,*pBeg = NULL;\tPGETPROCADDRESS = NULL;\tPLOADLIBRARY = NULL;\tPMESSAGEBOX = NULL;\tWORD *pFirst = NULL,*pLast = NULL;\tDWORD ret = 0,i=0;\tDWORD dwKernelBase = 0;\tchar szKerner32[] = &#123;&#x27;k&#x27;,0,&#x27;e&#x27;,0,&#x27;r&#x27;,0,&#x27;n&#x27;,0,&#x27;e&#x27;,0,&#x27;l&#x27;,0,&#x27;3&#x27;,0,&#x27;2&#x27;,0,&#x27;.&#x27;,0,&#x27;d&#x27;,0,&#x27;l&#x27;,0,&#x27;l&#x27;,0,0,0&#125;;\tchar szUser32[] = &#123;&#x27;U&#x27;,&#x27;S&#x27;,&#x27;E&#x27;,&#x27;R&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;.&#x27;,&#x27;d&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,0&#125;; char szGetProAddress[] = &#123;&#x27;G&#x27;,&#x27;e&#x27;,&#x27;t&#x27;,&#x27;P&#x27;,&#x27;r&#x27;,&#x27;o&#x27;,&#x27;c&#x27;,&#x27;A&#x27;,&#x27;d&#x27;,&#x27;d&#x27;,&#x27;r&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;s&#x27;,0&#125;;\tchar szLoadLibrary[] = &#123;&#x27;L&#x27;,&#x27;o&#x27;,&#x27;a&#x27;,&#x27;d&#x27;,&#x27;L&#x27;,&#x27;i&#x27;,&#x27;b&#x27;,&#x27;r&#x27;,&#x27;a&#x27;,&#x27;r&#x27;,&#x27;y&#x27;,&#x27;A&#x27;,0&#125;;\tchar szMessageBox[] = &#123;&#x27;M&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;s&#x27;,&#x27;a&#x27;,&#x27;g&#x27;,&#x27;e&#x27;,&#x27;B&#x27;,&#x27;o&#x27;,&#x27;x&#x27;,&#x27;A&#x27;,0&#125;;\tchar lpText[] = &#123;0xD7,0xA2,0xC8,0xEB,0xB3,0xC9,0xB9,0xA6,0x00&#125;;\tchar lpCaption[]= &#123;&#x27;s&#x27;,&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;c&#x27;,&#x27;o&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;T&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;t&#x27;,0&#125;;\t__asm&#123; mov eax,fs:[0x30] //PEB mov eax,[eax+0xc] //PEB-&gt;Ldr add eax,0x0c //LDR_DATA_TABLE_ENTRY InLoadOrderModuleList mov pBeg,eax mov eax,[eax] mov pPLD,eax\t&#125;\t/*\tif (strcmp(szMessageBox,name))\t&#123; printf(&quot;%d:--%s--%x &quot;,t+1,name,funAddress); PMESSAGEBOX = (MESSAGEBOX)funAddress;\t&#125;*/\t//kernel32.dll\twhile (pPLD != pBeg)\t&#123; pLast = (WORD*)pPLD-&gt;BaseDllName.Buffer; pFirst = (WORD*)szKerner32; while(!pLast &amp;&amp; *pLast == *pFirst)&#123; pLast++; pFirst++; &#125; if (*pLast == *pFirst) &#123; dwKernelBase = (DWORD)pPLD-&gt;DllBase; break; &#125; pPLD = (LDR_DATA_TABLE_ENTRY*)pPLD-&gt;InLoadOrderLinks.Flink;\t&#125;\tPIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)dwKernelBase;\tPIMAGE_NT_HEADERS pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\tPIMAGE_FILE_HEADER pPEHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTHeader + 4);\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + IMAGE_SIZEOF_FILE_HEADER);\tDWORD dataDirectorySize = sizeof(pOptionHeader-&gt;DataDirectory) / sizeof(IMAGE_DATA_DIRECTORY);\tPIMAGE_DATA_DIRECTORY pDataDirectory = (PIMAGE_DATA_DIRECTORY)pOptionHeader-&gt;DataDirectory;\tPIMAGE_EXPORT_DIRECTORY pExportTable = (PIMAGE_EXPORT_DIRECTORY)(dwKernelBase + pDataDirectory-&gt;VirtualAddress);\tLPVOID funNameBase = (LPVOID)(dwKernelBase + pExportTable-&gt;AddressOfNames);\tLPVOID funAddressBase = (LPVOID)(dwKernelBase + pExportTable-&gt;AddressOfFunctions);\tfor (DWORD t = 0;t&lt;pExportTable-&gt;NumberOfNames;t++)\t&#123; DWORD funAddress = dwKernelBase + *(PDWORD)((DWORD)funAddressBase+(t*4)); char* name = (char*)(dwKernelBase + *(PDWORD)((DWORD)funNameBase+(t*4))); //printf(&quot;name:%s &quot;,name); if (strcmp(szGetProAddress,name)) &#123; printf(&quot;%d:--%s--%x &quot;,t+1,name,funAddress); PGETPROCADDRESS = (GETPROCADDRESS)funAddress; &#125;else if (strcmp(szLoadLibrary,name)) &#123; printf(&quot;%d:--%s--%x &quot;,t+1,name,funAddress); PLOADLIBRARY = (LOADLIBRARYA)funAddress; &#125;\t&#125;\t//getchar();\tHMODULE hmodule = PLOADLIBRARY((LPCSTR)szUser32);\tPMESSAGEBOX = (MESSAGEBOXA)PGETPROCADDRESS(hmodule,szMessageBox);\tPMESSAGEBOX(0,lpText,lpCaption,MB_OK);\treturn;&#125;int main(int argc, char* argv[])&#123;\tToShellcode();\tprintf(&quot;Hello World! &quot;);\treturn 0;&#125;","tags":["shellcode"],"categories":["逆向"]},{"title":"保护模式","path":"/p/6c15571f/","content":"保护模式介绍什么是保护模式？x86 CPU的3个模式：实模式、保护模式和虚拟8086模式。 为什么不直接讲x64的？x86是由Intel推出的一种复杂指令集,能够生产支持这种指令集CPU公司主要是Intel和AMD. AMD在1999年的时候，拓展了这套指令集，称为x86-64,后改名为AMD64,Intel也兼容了这个产品，称为Intel 64.但AMD64和Intel64几乎是一样的，所以在很多资料中统称为x64.这套指令集是对x86的拓展，向下兼容的. 保护模式有什么特点？段的机制 页的机制 学习保护模式有什么用？真正理解内核是如何运作的 段寄存器结构1、什么是段寄存器？当我们用汇编读写某一个地址时： 1mov dword ptr ds:[0x123456] eax我们真正读写的地址是： 1ds.base + 0x123456 ES CS SS DS FS GS LDTR TR 共8个 2、段寄存器的结构 3、段寄存器的读写3.1 读段寄存器12345比如：MOV AX,ES 只能读16位的可见部分读写LDTR的指令为：SLDT/LLDT读写TR的指令为：STR/LTR 3.2 写段寄存器1比如：MOV DS,AX 写时是写96位 段寄存器属性探测1、段寄存器成员简介 段寄存器 Selector Attribute Base Limit ES 0023 可读、可写 0 0xFFFFFFFF CS 001B 可读、可执行 0 0xFFFFFFFF SS 0023 可读、可写 0 0xFFFFFFFF DS 0023 可读、可写 0 0xFFFFFFFF FS 003B 可读、可写 0x7FFDE000 0xFFF GS - - - - 2、探测Attribute1234567int var = 0; __asm &#123; mov ax,ss\t//cs不行 cs是可读 可执行 但不可写 mov ds,ax mov dword ptr ds:[var],eax &#125; 3、探测Base12345678910int var = 1; __asm &#123; mov ax,fs mov gs,ax mov eax,gs:[0]\t//不要用DS 否则编译不过去 mov dword ptr ds:[var],eax //mov edx,dword ptr ds:[0x7FFDF000]&#125; 4、探测Limit12345678910int var = 1; __asm &#123; mov ax,fs mov gs,ax mov eax,gs:[0]\t//不要用DS 否则编译不过去 mov dword ptr ds:[var],eax //mov edx,dword ptr ds:[0x7FFDF000]&#125; 段描述符与段选择子段描述符分类GDT(全局描述符表) LDT(局部描述符表) 当我们执行类似MOV DS,AX指令时，CPU会查表，根据AX的值来决定查找GDT还是LDT,查找表的什么位置，查出多少数据. 段描述符 段选择子段选择子是一个16位的段描述符，该描述符指向了定义该段的段描述符. RPL：请求特权级别 TI： 12TI=0 查GDT表TI=1 查LDT表 Index：处理器将索引值乘以8在加上GDT或者LDT的Base地址，就是要加载的段描述符 加载段描述符至段寄存器除了MOV指令，我们还可以使用LES、LSS、LDS、LFS、LGS指令修改寄存器 CS不能通过上述的指令进行修改，CS为代码段，CS的改变会导致EIP的改变，要改CS，必须要保证CS与EIP一起改，后面会讲 12345char buffer[6]; __asm &#123; les ecx,fword ptr ds:[buffer] //高2个字节给es，低四个字节给ecx\t&#125; [!NOTE] 注意：RPL&lt;&#x3D;DPL(在数值上) 段描述符属性P位和G位1、P位 123P = 1 段描述符有效P = 0 段描述符无效 2、G位（当前寻址上限） G &#x3D; 0 Limit单位是bytes 1Limit = 000 FFFFF 前面加000 G &#x3D; 1 Limit单位是以4KB 1Limit = FFFFF FFF 后面加FFF S位和TYPE域1、S位 S &#x3D; 1 代码段或者数据段描述符 S &#x3D; 0 系统段描述符 2、TYPE域 分析举例 数据段（DS）说明Access 访问位，表示该位最后一次被操作系统清零后，该段是否被访问过.每当处理器将该段选择符置入某个段寄存器时，就将该位置1. Write 是否可写 E 扩展方向 （向上拓展红色部分图一，向下拓展红色部分图二） 代码段（CS）说明A 访问位 R 可读位 C 一致位 123C = 1 一致代码段C = 0 非一致代码段 系统段（SS）描述符当S&#x3D;0时，该段描述符为系统描述符.系统描述符有分为以下类型 DB位DB位：当前实际地址最多大小 1、CS段 1D = 1 采用32位寻址方式 整个地址空间是4KB 12D = 0 采用16位寻址方式\t前缀67 改变寻址方式 整个地址空间是64K 2、SS段 123D = 1 隐式堆栈访问指令（如：PUSH POP CALL） 使用32位堆栈指针寄存器ESP D = 0 隐式堆栈访问指令（如：PUSH POP CALL） 使用16位堆栈指针寄存器SP 3、向下拓展的数据段 1D = 1 段上线为4GB 1D = 0 段上线为64KB 总结 段描述符中的DB位控制操作数的默认大小，DB&#x3D;0时默认操作数为16位，DB&#x3D;1时默认操作数为32位。 寄存器宽度的改变通过改变DB位实现，不影响寄存器本身的宽度。 CS段描述符的DB位控制代码段的默认操作数大小，影响push指令的默认操作数。 SS段描述符的DB位改变堆栈寄存器的寻址方式，从32位变为16位 段权限检查CPU分级 如何查看程序处于几环?CPL(Current Privilege Level) ：当前特权级 CS和SS中存储的段选择子后2位 例如：23 &#x3D;&#x3D; 0010 0011 2b &#x3D;&#x3D; 0010 1011 11&#x3D;&#x3D;3 那么在三环 DPL(Descriptor Privilege Level) 描述符特权级别 DPL存储在段描述符中，规定了访问该段所需要的特权级别是什么. 通俗的理解：如果你想访问我，那么你应该具备什么特权. 举例说明： 123mov DS,AX 如果AX指向的段DPL = 0 但当前程序的CPL = 3 这行指令是不会成功的 RPL(Request Privilege Level) 请求特权级别RPL是针对段选择子而言的，每个段的选择子都有自己的RPL 举例说明： 123Mov ax,0008\t与\tMov ax,000B //段选择子 Mov ds,ax Mov ds,ax //将段描述指向的是同一个段描述符,但RPL是不一样的. 数据段的权限检查12345比如当前程序处于0环，也就是说CPL=0Mov ax,000B\t//1011 RPL = 3Mov ds,ax\t//ax指向的段描述符的DPL = 0 数据段的权限检查： 1CPL &lt;= DPL 并且 RPL &lt;= DPL (数值上的比较) 注意：代码段和系统段描述符中的检查方式并不一样 总结12345CPL CPU当前的权限级别DPL 如果你想访问我，你应该具备什么样的权限RPL 用什么权限去访问一个段 代码跨段执行流程段寄存器:ES,CS,SS,DS,FS,GS,LDTR,TR 段寄存器读写：除CS外，其他的段寄存器都可以通过MOV,LES,LSS,LDS,LFS,LGS指令进行修改 1、代码间的跳转(段间跳转 非调用门之类的)段间跳转，有2种情况，即要跳转的段是一致代码段还是非一致代码段，也就是看C等于0还是1 同时修改CS与EIP的指令 JMP FAR &#x2F; CALL FAR &#x2F; RETF &#x2F; INT &#x2F;IRETED [!NOTE] 注意：只改变EIP的指令 JMP &#x2F; CALL &#x2F; JCC &#x2F; RET 2、执行流程CPU如何执行这行代码? JMP 0x20:0x004183D7 (1) 段选择子拆分 12340x20 对应二进制形式 0000 0000 0010 0000\tRPL = 00 TI = 0Index = 4 (2) 查表得到段描述符 12345TI = 0 所以查GDT表 Index = 4 找到对应的段描述符四种情况可以跳转：代码段、调用门、TSS任务段、任务门 (3) 权限检查 123如果是非一致代码段，要求:CPL == DPL 并且 RPL &lt;= DPL 如果是一致代码段，要求:CPL &gt;= DPL (4) 加载段描述符 1通过上面的权限检查后，CPU会将段描述符加载到CS段寄存器中. (5) 代码执行 1CPU将 CS.Base + Offset 的值写入EIP 然后执行CS:EIP处的代码，段间跳转结束. 3、总结 对于一致代码段:也就是共享的段 特权级高的程序不允许访问特权级低的数据：核心态不允许访问用户态的数据 特权级低的程序可以访问到特权级高的数据，但特权级不会改变：用户态还是用户态 对于普通代码段：也就是非一致代码段 只允许同级访问 绝对禁止不同级别的访问：核心态不是用户态，用户态也不是核心态. 直接对代码段进行JMP 或者 CALL的操作，无论目标是一致代码段还是非一致代码段，CPL都不会发生改变.如果要提升CPL的权限，只能通过调用门. 3、实验3.1 构造段描述符找一个非一致代码段描述符,复制一份，写入到GDT表中 1234567891011kd&gt; r gdtrgdtr=8003f000kd&gt; dq 8003f0008003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffb00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab8003f030 ffc093df`f0000001 0040f300`00000fff8003f040 0000f200`0400ffff 00000000`000000008003f050 80008954`b1000068 80008954`b16800688003f060 00009302`2f40ffff 0000920b`80003fff8003f070 ff0092ff`700003ff 80009a40`0000ffff 将 00cffb00&#96;0000ffff 数据写如某个P位为0的位置 1kd&gt; eq 8003f048 00cffb00`0000ffff(用内核工具查看新增是否成功） 3.2 OD中进行测试在OD中，执行跨段跳转 JMP FAR 004B:0041840D 成功的话，CS段寄存器就会修改成4B 3.3 修改段描述符的权限级别,并再次在OD中进行测试将00cffb00`0000ffff 改为00cf9b00`0000ffff在OD中，执行跨段跳转 JMP FAR 004B:0041840D 3.4 将该段描述符的属性更改为一致代码段.将00cffb00`0000ffff 改为00cf9f00`0000ffff在OD中，执行跨段跳转 JMP FAR 004B:0041840D 如果是一致代码段，要求:CPL &gt;&#x3D; DPL (当前同样可以访问) CPL:3 DPL:0 4、总结1、为了对数据进行保护，普通代码段是禁止不同级别进行访问的。用户态的代码不能访问内核的数据，同样，内核态的代码也不能访问用户态的数据. 2、如果想提供一些通用的功能，而且这些功能并不会破坏内核数据，那么可以选择一致代码段，这样低级别的程序可以在不提升CPL权限等级的情况下即可以访问. 3、如果想访问普通代码段，只有通过“调用门”等提示CPL权限，才能访问。 长调用与短调用我们通过JMP FAR可以实现段间的跳转，如果要实现跨段的调用就必须要学习CALL FAR，也就是长调用. CALL FAR比JMP FAR要复杂，JMP并不影响堆栈,但CALL指令会影响. 1、短调用指令格式：CALL 立即数&#x2F;寄存器&#x2F;内存 发生改变的寄存器：ESP EIP 2、长调用(跨段不提权)指令格式：CALL CS:EIP(EIP是废弃的) 发生改变的寄存器：ESP EIP CS 3、长调用(跨段并提权)指令格式：CALL CS:EIP(EIP是废弃的) 发生改变的寄存器：ESP EIP CS SS 4、总结 跨段调用时，一旦有权限切换，就会切换堆栈. CS的权限一旦改变，SS的权限也要随着改变，CS与SS的等级必须一样. JMP FAR 只能跳转到同级非一致代码段，但CALL FAR可以通过调用门提权，提升CPL的权限. 调用门1、调用门执行流程指令格式：CALL CS:EIP(EIP是废弃的) 执行步骤： 根据CS的值 查GDT表，找到对应的段描述符 这个描述符是一个调用门. 在调用门描述符中存储另一个代码段段的选择子. 选择子指向的段 段.Base + 偏移地址 就是真正要执行的地址. 2、门描述符 （16-31位）offset+（0-15位）offset &#x3D; 跳转到函数执行的位置 3、构造一个调用门（无参 提权）1234567891011第一步：构造大概的值DPL:3环 == 110000 0000 0000 0000 1110 1100(调用门固定值) 0000 0000 == 0000ec000000 0000 0000 1000 0000 0000 0000 0000 == 000800000000ec00`00080000第二步：拿到方法地址4010000040ec00`00081000第三步：eq 80b99048 0040ec00`00081000第四步：运行程序 3.1 代码测试步骤一：代码测试，并观察堆栈与寄存器的变化记录执行前的寄存器值：SS ESP CS 执行前： 执行后： 1234567eax=00000048 ebx=7ffd9000 ecx=00000000 edx=00000001 esi=00000000 edi=0012fe5ceip=00401000 esp=a69f5ca0 ebp=0012fe5c iopl=0 nv up ei pl nz na pe nccs=0008 ss=0010 ds=0023 es=0023 fs=0030 gs=0000 efl=00000206 变化： 12345CS:1b-&gt;08 ESP:12fd7c-&gt;a682bca0(高地址)SS:23-&gt;10 堆栈： 步骤二：在测试代码中加入特权指令并读取高2G内存 测试代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950BYTE GDT[6] = &#123;0&#125;;DWORD dwH2Gvalue;void _declspec(naked) getRegister()&#123;\t__asm&#123; pushad pushfd mov eax,0x80b9900c mov ebx,[eax] mov dwH2Gvalue,ebx sgdt GDT //获取GDT表地址 popfd popad retf\t&#125;&#125;void printfRegister()&#123;\tDWORD GDT_ADDR = *(PDWORD)(&amp;GDT[2]);\tWORD GDT_LIMIT = *(PWORD)(&amp;GDT[0]);\tprintf(&quot;%x %x %x &quot;,dwH2Gvalue,GDT_ADDR,GDT_LIMIT);&#125;int testfun1()&#123;\t__asm&#123; mov ebx,ebx mov ebx,ebx\t&#125;\tchar buf[6];\t*(DWORD*)&amp;buf[0] = 0x12345678;\t*(WORD*)&amp;buf[4] = 0x48;\t__asm&#123; call fword ptr[buf]\t&#125;\tprintfRegister();\tgetchar();\treturn 0;&#125;int _tmain(int argc, _TCHAR* argv[])&#123;\ttestfun1();\treturn 0;&#125; 4、构造一个调用门（有参 提权）调用门描述符： 0040EC03&#96;00081030 （三个参数） 1kd&gt;eq 8003f048 0040EC03`00081030 测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// demo03.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &lt;windows.h&gt;DWORD x,y,z;void _declspec(naked) getRegister()&#123;\t__asm&#123; pushad pushfd mov eax,[esp+0x24+0x8+0x8] mov dword ptr ds:[x],eax mov eax,[esp+0x24+0x8+0x4] mov dword ptr ds:[y],eax mov eax,[esp+0x24+0x8+0x0] mov dword ptr ds:[z],eax popfd popad retf 0xc\t&#125;&#125;void printfRegister()&#123;\tprintf(&quot;%x %x %x &quot;,x,y,z);&#125;int testfun1()&#123; char buf[6];\t*(DWORD*)&amp;buf[0] = 0x12345678;\t*(WORD*)&amp;buf[4] = 0x68;\t__asm&#123; push 1 push 2 push 3 call fword ptr[buf]\t&#125;\tprintfRegister();\tgetchar();\treturn 0;&#125;int _tmain(int argc, _TCHAR* argv[])&#123;\ttestfun1();\treturn 0;&#125; 成功获取到3个传入的参数 5、总结 当通过门，权限不变的时候，只会PUSH两个值：CS和返回地址新的CS的值由调用门决定 当通过门，权限改变的时候，会PUSH四个值：SS、ESP、CS和返回地址 新的CS的值由调用门决定 新的SS和ESP由TSS提供 通过门调用时，要执行哪行代码有调用门决定，但使用RETF返回时，由堆栈中压入的值决定，这就是说，进门时只能按指定路线走，出门时可以翻墙(只要改变堆栈里面的值就可以想去哪去哪) 可不可以再建个门出去呢?也就是用Call 当然可以了 前门进 后门出 中断门使用场景 系统调用 1大家在开发应用程序时都会使用到Windows提供的API，这些API在执行的过程中需要从3环一步一步进入到0环，这一过程就是系统调用，在这个过程中也用到了中断门（一些比较老的API使用的是中断门，但是新API中使用的都是快速调用） 调试 1大家使用OD调试程序时候会使用断点，断点本质上就是在你选中的这一行中写入一个字节0xCC，也就是INT 3指令，这个指令就是用来执行中断门的。中断门也有一张表，我们称之为IDT（中断描述符表），与GDT一样，IDT也是由一系列描述符组成的，每个描述符占8字节，需要注意的是IDT表中的第一个元素不是NULL（GDT是） 1、IDTIDT即中断描述符表,同GDT一样，IDT也是由一系列描述符组成的，每个描述符占8个字节。但要注意的是，IDT表中的第一个元素不是NULL。在windbg中查看IDT表的基址和长度 2、IDT表的构成IDT表可以包含3种门描述符： 任务门描述符 中断门描述符 陷阱门描述符 3、中断门描述符结构 当8-12位的值是01110则是一个中断门 函数执行：401030 0040ee00&#96;00081030 4、构造一个中断门1234567//INT index 指令触发寻找中断门//当前（写入的地址-idt首地址）/ 8 = index索引 16进制 __asm&#123; push fs INT 0x22 pop fs&#125; 5、中断执行INTX其中，X是索引，X*8+IDT的基址就是具体的中断门描述符 6、中断返回INT N指令： 在没有权限切换时，会向堆栈PUSH 3个值，分别是：CS EFLAG EIP（返回地址） 在有权限切换时，会向堆栈PUSH 5个值，分别是：SS ESP EFLAG CS EIP（返回地址） 在中断门中，不能通过RETF返回，而应该通过IRET&#x2F;IRETD指令返回 陷阱门1、陷阱门描述符结构 当8-12位的值是01111则是一个陷阱门 2、构造一个陷阱门构造一个陷阱门（0040EF00 00081030） 0000ef00 00080000 0000 0000 0000 0000 1110 1111 0000 0000 写入到IDT表中 1eq&gt;8003f500 0040EF00`0008103 执行陷阱门 123__asm&#123; INT 0x32&#125; 3、陷阱门与中断门的区别中断门执行时，将IF位（中断标志）清零,但陷阱门不会。 任务段在调用门、中断门与陷阱门中，一旦出现权限切换，那么就会有堆栈的切换。而且，由于CS的CPL发生改变，也导致了SS也必须要切换。 切换时，会有新的ESP和SS(CS是由中断门或者调用门指定)这2个值从哪里来的呢？TSS (Task-state segment )，任务状态段. 1、TSS的结构 大小104字节 2、TSS的作用不要把TSS与“任务切换”联系到一起 TSS的意义就在于可以同时换掉”一堆”寄存器 3、TR段寄存器取值CPU如何找到TSS呢? 通过TR段寄存器，base找到TSS内存 Limit指的是TSS内存大小，TR段寄存器值来自于GDT表，GDT表里的TSS段描述符 4、TSS段描述符(TSS Descriptor) 5、TR寄存器读写 将TSS段描述符加载到TR寄存器 指令：LTR 说明： 用LTR指令去装载的话仅仅是改变TR寄存器的值(96位) 并没有真正改变TSS LTR指令只能在系统层使用 加载后TSS段描述符会状态位会发生改变 6、修改TR寄存器 在Ring0 我们可以通过LTR指令去修改TR寄存器 在Ring3 我们可以通过CALL FAR 或者 JMP FAR指令来修改 用JMP去访问一个代码段的时候，改变的是CS和EIP ： 12JMP 0x48:0x123456 如果0x48是代码段 执行后：CS--&gt;0x48 EIP--&gt;0x123456 用JMP去访问一个任务段的时候： 如果0x48是TSS段描述符，先修改TR寄存器，在用TR.Base指向的TSS中的值修改当前的寄存器 注意： 如果你用JMP的话Previous Task Link的值不变和NT位不变，没有人给你填充初始值多少现在就多少，如果用Call那就会写成原来那个TSS段的选择子和NT位置1 NT &#x3D; 0 IRET（堆栈取 中断返回） NT &#x3D; 1 IRET （TSS:PTL 不是中断返回） 7、实现任务切换 构造完整的TSS 构造TSS段描述符 使用CALL FAR&#x2F;JMP FAR指令修改TR寄存器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;#include &lt;windows.h&gt; int o_eax, n_esp;short n_cs, n_ss; void __declspec(naked) GetValue() &#123; // 将寄存器保存到全局变量中 _asm &#123; mov o_eax, eax mov n_esp, esp mov ax, cs mov n_cs, ax mov ax, ss mov n_ss, ax mov eax, o_eax iretd &#125;&#125; void main()&#123; char stack[100] = &#123;0&#125;; // 栈 char buffer[6] = &#123;0x0, 0x0, 0x0, 0x0, 0x4B, 0x0&#125;; // 选择子 int iCr3 = 0; printf(&quot;Input: &quot;); scanf(&quot;%x&quot;, &amp;iCr3); getchar(); DWORD tss[0x68] = &#123; 0x00000000, // Previous Task Link // 不同权限对应的ESP、SS，如果不涉及到权限切换所以可以将这些寄存器的值全部填0 0x00000000, // ESP0 0x00000000, // SS0 0x00000000, // ESP1 0x00000000, // SS1 0x00000000, // ESP2 0x00000000, // SS2 (DWORD)iCr3, // Cr3，与页的知识有关，必须要赋值 0x00401020, // EIP，下一次执行代码的位置，必须要赋值，在代码中就是GetValue函数的地址 0x00000000, // EFLAGS 0x00000000, // EAX 0x00000000, // ECX 0x00000000, // EDX 0x00000000, // EBX (DWORD)stack, // ESP，任务切换时也需要切换栈，所以在代码中我们可以声明一个数组，将其地址作为一块栈 0x00000000, // EBP 0x00000000, // ESI 0x00000000, // EDI 0x00000023, // ES 0x00000008, // CS，切到0环的代码段描述符 0x00000010, // SS，CS与SS需要保持一致 0x00000023, // DS 0x00000030, // FS，切到0环就是0x30，3环就是0x3B 0x00000000, // GS，Windows没有使用这个段寄存器所以永远是0 0x00000000, // LDT，填0 0x20ac0000 // IO_MAP，Windows2000以后不用了，默认值 &#125;; _asm &#123; push fs call far fword ptr[buffer] // 长调用 pop fs &#125; // 输出寄存器的值证明完成了任务切换 printf(&quot;ESP: %x, CS: %x, SS: %x &quot;, n_esp, n_cs, n_ss); getchar();&#125; 根据TSS段描述符的结构构造描述符，首先获取TSS的地址，在代码中下断点然后查看地址即可：其地址为0x0012fd70 我们就得出对应TSS段描述符中Base的值，接着Limit就是TSS的大小0x68，DPL为3（3环程序访问） Type域为0x9即表示当前描述符没有被加载过。 在Windbg中断点输入 1kd&gt; !process 0 0 指令找到当前的程序获取Cr3的值填入到程序中 最终得出TSS段描述符为： 构造TSS段描述符：XX00e9XX&#96;XXXX0068 1234tss:0x0012fc2ceq 8003f0c0 0000e912`fc2c0068cr3:bf3915e0 getValue 4113d0 接着我们使用eq指令在Windbg中向GDT表中写入我们构造好的TSS段描述符： 通过windbg寄存器我们可以看到EIP,ESP,CS,SS变成了我们设置的值 任务门1、任务门描述符 12构造任务门：0000 e500 00c3 0000&gt;eq 8003f500 0000e500`00c30000 2、任务门执行过程： INT N 查IDT表，找到中断门描述符 通过中断门描述符，查GDT表，找到任务段描述符 使用TSS段中的值修改寄存器 IRETD返回 3、代码段选择子一定要计算正确 1234idt 0x20 构造中断门eq 8003f500 0000e500`004b0000gdt 0x4b 构造任务门 0100 1011 RPL：3 eq 8003f048 0000e912`fd700068 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// demo07.cpp : Defines the entry point for the console application.//#include &quot;stdafx.h&quot;#include &lt;stdio.h&gt;#include &lt;windows.h&gt; DWORD dwOK,dwESP,dwCS; void __declspec(naked) GetValue() &#123; // 将寄存器保存到全局变量中\tdwOK = 1;\t_asm &#123; mov eax,esp mov dwESP,eax mov ax,cs mov word ptr[dwCS],ax iretd &#125;&#125;int main()&#123; char stack[100] = &#123;0&#125;; // 栈 char buffer[6] = &#123;0x0, 0x0, 0x0, 0x0, 0xC0, 0x0&#125;; // 选择子 int iCr3 = 0;\tprintf(&quot;Input: &quot;); scanf(&quot;%x&quot;, &amp;iCr3); getchar();\tDWORD tss[0x68] = &#123; 0x00000000, // Previous Task Link // 不同权限对应的ESP、SS，如果不涉及到权限切换所以可以将这些寄存器的值全部填0 0x00000000, // ESP0 0x00000000, // SS0 0x00000000, // ESP1 0x00000000, // SS1 0x00000000, // ESP2 0x00000000, // SS2 (DWORD)iCr3, // Cr3，与页的知识有关，必须要赋值 (ULONG)GetValue, // EIP，下一次执行代码的位置，必须要赋值，在代码中就是GetValue函数的地址 0x00000000, // EFLAGS 0x00000000, // EAX 0x00000000, // ECX 0x00000000, // EDX 0x00000000, // EBX (DWORD)stack, // ESP，任务切换时也需要切换栈，所以在代码中我们可以声明一个数组，将其地址作为一块栈 0x00000000, // EBP 0x00000000, // ESI 0x00000000, // EDI 0x00000023, // ES 0x00000008, // CS，切到0环的代码段描述符 0x00000010, // SS，CS与SS需要保持一致 0x00000023, // DS 0x00000030, // FS，切到0环就是0x30，3环就是0x3B 0x00000000, // GS，Windows没有使用这个段寄存器所以永远是0 0x00000000, // LDT，填0 0x20ac0000 // IO_MAP，Windows2000以后不用了，默认值 &#125;;\tprintf(&quot;TSS:%x &quot;,&amp;tss);\tgetchar();\t_asm &#123; PUSH fs INT 0X20 // 长调用 POP fs &#125;\t// 输出寄存器的值证明完成了任务切换 printf(&quot;ESP: %x, CS: %x, dwOK: %x &quot;, dwESP, dwCS, dwOK);\tgetchar();\treturn 0;&#125; 分页1、4GB空间 2、物理地址地址分为：线性地址、有效地址、物理地址 指令： 1MOV eax,dword ptr ds:[0x12345678] 0x12345678是属于有效地址 ds.base+0x12345678 &#x3D; 线性地址 3、物理在哪每个进程都有一个CR3，(准确的说是都一个CR3的值，CR3本身是个寄存器，一个核，只有一套寄存器) CR3指向一个物理页，一共4096字节 4、设置分页方式 将noexecute 改成 execute 5、如何寻找物理地址（10-10-12为例）10-10-12 一共32位，把一段地址拆分成三段10位 10位 12位 用notepad为例 第一步先在notepad中写入一个hello world字符串，然后使用CE进行搜索拿到字符串在进程中的地址 第二步拆分地址 1234000AA750 hello world字符串在进程中地址第一级：0000 0000 00 0第二级：00 1010 1010 AA * 4 = 2A8第三级：750 第三步windbg进行查看找到cr3的值 12345DirBase:314b7000第一级：!dd cr3+0 = 314b7000+0第二级：!dd 3192d067+2A8 后面三位是属性使用时改成000第三级：!dd 319ed000+750!db 319ed000+750 可验证 PDE&#x2F;PTEPDE和PTE介绍1、PDE与PTE 2、指向相同物理页 PTE可以没有物理页，且只能对应一个物理页 多个PTE也可以指向同一个物理页 3、实验查分0地址，观察PTE是否有物理页 向0地址读写数据 没有挂物理页之前向0地址写入不了数据 手动挂物理页 12345678910111213141516171819202122232425262728293031323334353637383940414243x的线性地址：0x1245052先拆分0000 0001 00 1010 0100 0101 245 * 4 = 914052DirBase: 553aa000第一级：kd&gt; !dd 553aa000#553aa000 54ad6067 54a95067 00000000 00000000#553aa010 00000000 00000000 00000000 00000000#553aa020 00000000 00000000 00000000 00000000#553aa030 00000000 00000000 00000000 00000000#553aa040 00000000 00000000 00000000 00000000#553aa050 00000000 00000000 00000000 00000000#553aa060 00000000 00000000 00000000 00000000#553aa070 00000000 00000000 00000000 00000000第二级：kd&gt; !dd 54ad6000 + 914#54ad6914 54df5067 00000000 00000000 00000000#54ad6924 00000000 00000000 00000000 00000000#54ad6934 00000000 00000000 00000000 5576d067#54ad6944 5556f067 553b0067 00000000 00000000#54ad6954 00000000 00000000 00000000 00000000#54ad6964 00000000 00000000 00000000 00000000#54ad6974 00000000 00000000 00000000 0bb31025#54ad6984 0bb32025 00000000 00000000 00000000查询下0地址kd&gt; !dd 54ad6000#54ad6000 00000000 00000000 00000000 00000000#54ad6010 00000000 00000000 00000000 00000000#54ad6020 00000000 00000000 00000000 00000000#54ad6030 00000000 00000000 00000000 00000000#54ad6040 54e97067 00000000 00000000 00000000#54ad6050 00000000 00000000 00000000 00000000#54ad6060 00000000 00000000 00000000 00000000#54ad6070 00000000 00000000 00000000 00000000把当前x变量的物理页挂到0地址上kd&gt; !ed 54ad6000 54df5067 PDE&#x2F;PTE 属性1、物理页的属性物理页的属性 &#x3D; PDE属性 &amp; PTE属性 2、P位PDE和PTE的P位如果为0，则当前的物理页是无效的，反之 3、R&#x2F;W位R&#x2F;W &#x3D; 0 只读 R&#x2F;W &#x3D; 1 可读可写 12345678910111213141516#include &quot;stdafx.h&quot;#include &lt;windows.h&gt;int main(int argc, char* argv[])&#123;\tchar* str = &quot;hello world&quot;;\tprintf(&quot;%x &quot;,str);\tgetchar();\tDWORD dwAddr = (DWORD)str;\t*(char*)dwAddr = &#x27;M&#x27;;\tprintf(&quot;%s &quot;,str);\treturn 0;&#125; 已知上面代码在正常情况下str是只读的，后续是无法对它进行任何的修改操作的。会报错内存访问异常 现在我们对R&#x2F;W位进行查询 123456789101112131415161718192021222324250x420f94Dirbase:7f4fd0000000 0000 01 00 0010 0000 20*4=80f94第一级：kd&gt; !dd 7f4fd000#7f4fd000 7f57b067 7f7ba067 00000000 00000000#7f4fd010 00000000 00000000 00000000 00000000#7f4fd020 00000000 00000000 00000000 00000000#7f4fd030 00000000 00000000 00000000 00000000#7f4fd040 00000000 00000000 00000000 00000000#7f4fd050 00000000 00000000 00000000 00000000#7f4fd060 00000000 00000000 00000000 00000000#7f4fd070 00000000 00000000 00000000 00000000第二级：kd&gt; !dd 7f7ba000 + 80#7f7ba080 7c7e9025 00000000 00de4067 7f895067#7f7ba090 7fe65067 7eb52027 00000000 00000000#7f7ba0a0 00000000 00000000 00000000 00000000#7f7ba0b0 00000000 00000000 00000000 00000000#7f7ba0c0 7f8dc067 7f7dd067 7f5de067 7f8df067#7f7ba0d0 7f960067 7fe61067 00de2067 7fbe3067#7f7ba0e0 00000000 00000000 00000000 00000000#7f7ba0f0 00000000 00000000 00000000 00000000 可以看到7c7e9025对应的二进制是 10111 1100 0111 1110 1001 0000 0010 0101 而第二位R/W：0 说明是只读权限 现在我们修改7c7e9025-&gt;7c7e9027 10111 1100 0111 1110 1001 0000 0010 0111 12345678910111213141516171819kd&gt; !dd 7f7ba000 + 80#7f7ba080 7c7e9025 00000000 00de4067 7f895067#7f7ba090 7fe65067 7eb52027 00000000 00000000#7f7ba0a0 00000000 00000000 00000000 00000000#7f7ba0b0 00000000 00000000 00000000 00000000#7f7ba0c0 7f8dc067 7f7dd067 7f5de067 7f8df067#7f7ba0d0 7f960067 7fe61067 00de2067 7fbe3067#7f7ba0e0 00000000 00000000 00000000 00000000#7f7ba0f0 00000000 00000000 00000000 00000000kd&gt; !ed 7f7ba080 7c7e9027kd&gt; !dd 7f7ba000 + 80#7f7ba080 7c7e9027 00000000 00de4067 7f895067#7f7ba090 7fe65067 7eb52027 00000000 00000000#7f7ba0a0 00000000 00000000 00000000 00000000#7f7ba0b0 00000000 00000000 00000000 00000000#7f7ba0c0 7f8dc067 7f7dd067 7f5de067 7f8df067#7f7ba0d0 7f960067 7fe61067 00de2067 7fbe3067#7f7ba0e0 00000000 00000000 00000000 00000000#7f7ba0f0 00000000 00000000 00000000 00000000 现在看看效果 已经成功！！！！ 4、U&#x2F;S 位U&#x2F;S &#x3D; 0 特权用户 U&#x2F;S &#x3D; 1 普通用户 5、P&#x2F;S位只对PDE有意义，PS &#x3D;&#x3D; PageSize的意思 当PS&#x3D;&#x3D;1的时候 PDE直接指向物理页 无PTE,低22位是页内偏移。也就是说少一级偏移。 6、A位是否被访问（读或者写）过 A&#x3D;1 访问过 [!NOTE] 即使只访问一个字节也会导致PDE或者PTE置1 7、D位脏位：是否被写过 0：没有被写过 1：被写过 页目录表基址1、拆分C0300000当前我们用DbgView程序为例 123456789101112131415161718192021222324252627282930313233343536373839404142434445DirBase: 238ef0001100 0000 00 00 300 * 4 = C0011 0000 0000 300 * 4 = C00000kd&gt; !dd 238ef000 #238ef000 237e3067 2365a067 23a2e067 23a1c067 #238ef010 00000000 00000000 00000000 00000000#238ef020 00000000 00000000 00000000 00000000#238ef030 00000000 00000000 00000000 00000000#238ef040 00000000 00000000 00000000 00000000#238ef050 00000000 00000000 00000000 00000000#238ef060 00000000 00000000 00000000 00000000#238ef070 00000000 00000000 00000000 00000000kd&gt; !dd 238ef000 + C00 PDT#238efc00 238ef063 236f0063 00000000 09f55163 //PDE#238efc10 09f56163 09f57163 09f58163 09f59163#238efc20 09f5a163 09f5b163 09f5c163 09f5d163#238efc30 09f5e163 09f5f163 09f60163 09f61163#238efc40 09f62163 09f63163 09f64163 09f65163#238efc50 09f66163 09f67163 09f68163 09f69163#238efc60 09f6a163 09f6b163 09f2c163 09f2d163#238efc70 09f2e163 09f2f163 09f30163 09f31163kd&gt; !dd 238ef000 + C00 PTT#238efc00 238ef063 236f0063 00000000 09f55163 //PTE#238efc10 09f56163 09f57163 09f58163 09f59163#238efc20 09f5a163 09f5b163 09f5c163 09f5d163#238efc30 09f5e163 09f5f163 09f60163 09f61163#238efc40 09f62163 09f63163 09f64163 09f65163#238efc50 09f66163 09f67163 09f68163 09f69163#238efc60 09f6a163 09f6b163 09f2c163 09f2d163#238efc70 09f2e163 09f2f163 09f30163 09f31163kd&gt; !dd 238ef000#238ef000 237e3067 2365a067 23a2e067 23a1c067#238ef010 00000000 00000000 00000000 00000000#238ef020 00000000 00000000 00000000 00000000#238ef030 00000000 00000000 00000000 00000000#238ef040 00000000 00000000 00000000 00000000#238ef050 00000000 00000000 00000000 00000000#238ef060 00000000 00000000 00000000 00000000#238ef070 00000000 00000000 00000000 00000000 结论：C0300000存储的值就是PDT 如果我们要访问第N个PDE，那么有如下公式：0xC0300000 + N*4 2、页目录表基址(XP系统 10-10-12分页模式) 3、总结 通过0xC0300000找到的物理页就是页目录表 这个物理页即是页目录表本身也是页表 页目录表是一张特殊的页表，每一项PTE指向的不是普通的物理页，而是指向其他的页表 如果我们要访问第N个PDE，那么有如下公式：0xC0300000 + N*4 页表基址1、拆分C0000000 &#x2F; C0001000 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859DirBase: 238ef000第一个PTTkd&gt; !dd 237e3000#237e3000 00000000 00000000 00000000 00000000#237e3010 00000000 00000000 00000000 00000000#237e3020 00000000 00000000 00000000 00000000#237e3030 00000000 00000000 00000000 00000000#237e3040 23764067 00000000 00000000 00000000#237e3050 00000000 00000000 00000000 00000000#237e3060 00000000 00000000 00000000 00000000#237e3070 00000000 00000000 00000000 00000000第二个PTTkd&gt; !dd 2365a000 #2365a000 238ee025 23951025 23b08025 239c9025#2365a010 23b0a025 23b8b025 23b4c025 2388d025#2365a020 2398e025 238cf025 00000000 238ad025#2365a030 00000000 239ef025 23830025 23931025#2365a040 00000000 23833025 23734025 237f5025#2365a050 236f6025 23677025 00000000 00000000#2365a060 00000000 00000000 00000000 00000000#2365a070 00000000 235a5025 23666025 00000000C000000011 0000 0000 300 * 4 = C0000 0000 0000 00kd&gt; !dd 238ef000 + C00kd&gt; !dd 238ef000 + 0kd&gt; !dd 237e3000 #237e3000 00000000 00000000 00000000 00000000#237e3010 00000000 00000000 00000000 00000000#237e3020 00000000 00000000 00000000 00000000#237e3030 00000000 00000000 00000000 00000000#237e3040 23764067 00000000 00000000 00000000#237e3050 00000000 00000000 00000000 00000000#237e3060 00000000 00000000 00000000 00000000#237e3070 00000000 00000000 00000000 00000000用0xC0000000查出来的是第一张PTT表C0001000 11 0000 0000 300 * 4 = C0000 0000 0001 1 * 4 = 00kd&gt; !dd 238ef000 + C00kd&gt; !dd 238ef000 + 4kd&gt; !dd 2365a000#2365a000 238ee025 23951025 23b08025 239c9025#2365a010 23b0a025 23b8b025 23b4c025 2388d025#2365a020 2398e025 238cf025 00000000 238ad025#2365a030 00000000 239ef025 23830025 23931025#2365a040 00000000 23833025 23734025 237f5025#2365a050 236f6025 23677025 00000000 00000000#2365a060 00000000 00000000 00000000 00000000#2365a070 00000000 235a5025 23666025 00000000用0xC0001000查出来的是第二张PTT表 线性地址0xc0000000映射到第一个PTT表，0xC0000000到0xC0001000刚好相差0x1000相当于一个页，后续地址增量为4KB，对应不同的PTT表。 0xc0300000线性地址用于访问页目录表本身。掌握0xc0000000和0xc0300000两个地址等于掌握了进程内存的读写权限 总结： 页表被映射到了从0xC0000000到0xC03FFFFF的4M地址空间 在这1024个表中有一张特殊的表：页目录表 页目录被映射到了0xC0300000开始处的4K地址空间 2、总结PDI与PTI：10-10-12 （I就是Index） 访问页目录表的公式：0xC0300000 + PDI*4 访问页表的公式：0xC0000000 + PDI*4096 + PTI*4 2-9-9-12分页随着硬件的发展，这时候10-10-12分页的物理地址显然不够用，因此2-9-9-12分页随之产生。 1、10-10-12分页划分 先确定了页的大小 4K 所以后面的12位的功能就确定了。(4096 &#x3D; 2^12) 当初的物理内存比较小，所以4个字节的PTE就够了，加上页的尺寸是4K 所以一个页能存储1024个 PTE 也就是2的10次方 第二个10也就确定了。(4096&#x2F;4 &#x3D; 1024 &#x3D; 2^10) 剩下的10为PDI 10+10+12刚好32位 2、2-9-9-12分页划分 页的大小是确定的，4KB不能随便改，所以12确定了 如果想增大物理内存的访问范围，就需要增大PTE，考虑对齐的因素，增加到8个字节 同理PDI也是2的9次方32，2-9-9-12 还差2位 所以就再做一级 叫PDPI 3、2-9-9-12分页结构 PDPTE：Page-Directory-Point-Table Entry页目录指针表项 每项占8个字节 第四项PDPTE指向的是第四张PDT表时，第四张PDT表的前四项又分别指向PDPTT表的PDPTE 12345678910111213141516171819202122总结如下:\t1.第三个PDPTE指向了一个PDT表，此表的前四项 指向了PDPTE的每一个元素2.根据计算 C0600000 的最大索引，不会超过 C0604000 mov edi, edi\t.text:0043C92A 55 push ebp\t.text:0043C92B 8B EC mov ebp, esp\t.text:0043C92D 51 push ecx\t.text:0043C92E 51 push ecx\t.text:0043C92F 8B 4D 08 mov ecx, [ebp+VirtualAddress]\t.text:0043C932 56 push esi\t.text:0043C933 8B C1 mov eax, ecx\t.text:0043C935 C1 E8 12 shr eax, 12h\t.text:0043C938 BE F8 3F 00 00 mov esi, 3FF8h\t.text:0043C93D 23 C6 and eax, esi\t.text:0043C93F 2D 00 00 A0 3F sub eax, 3FA00000h线性地址 &gt;&gt;18 +C0600000 也就是说。得出的索引是 2^14，最大值4000H 实际应用从0开始，也就是 4000H-(1*8byte) 那么得到最后一个PDE 也就是 C06003FFE8，由此可推出 C0600000是第一个PDT表的首地址\tC0601000是第二个PDT表的首地址 C0602000是第三个PDT表的首地址\tC0603000是第四个PDT表的首地址 4、如何寻找物理地址（2-9-9-12为例）2-9-9-12 一共32位，把一段地址拆分成三段2位 9位 9位 12位 用notepad为例 第一步先在notepad中写入一个hello world字符串，然后使用CE进行搜索拿到字符串在进程中的地址 第二步拆分地址 12345000AA750 hello world字符串在进程中地址第一部分：00 0*8第一部分：00 0000 000 0*8第一部分：0 1010 1010 AA * 8 = 550第四部分：750 第三步windbg进行查看找到cr3的值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647DirBase:123402a0第一级：!dd 123402a0kd&gt; !dd 123402a0#123402a0 288a8001 00000000 28729001 00000000#123402b0 2886a001 00000000 287a7001 00000000#123402c0 1d083001 00000000 1cf44001 00000000#123402d0 1cec5001 00000000 1d142001 00000000#123402e0 1d402001 00000000 1d383001 00000000#123402f0 1d1c4001 00000000 1d301001 00000000#12340300 1cc20001 00000000 1cce1001 00000000#12340310 1cc62001 00000000 1cb5f001 00000000第二级：!dd 288a8000+0 后面三位是属性使用时改成000kd&gt; !dd 288a8000#288a8000 285e4067 00000000 28b43067 00000000#288a8010 28696067 00000000 00000000 00000000#288a8020 285e5067 00000000 2885e067 00000000#288a8030 28ca1067 00000000 29088067 00000000#288a8040 28757067 00000000 00000000 00000000#288a8050 00000000 00000000 00000000 00000000#288a8060 00000000 00000000 00000000 00000000#288a8070 00000000 00000000 00000000 00000000第三级：!dd 285e4000+550kd&gt; !dd 285e4000+550#285e4550 2892b067 80000000 28821067 80000000#285e4560 28922067 80000000 286e4067 80000000#285e4570 28625067 80000000 28866067 80000000#285e4580 288e7067 80000000 28a68067 80000000#285e4590 288e9067 80000000 00000200 00000000#285e45a0 00000200 00000000 00000200 00000000#285e45b0 29142067 80000000 28c8d067 80000000#285e45c0 28ed1067 80000000 28d94067 80000000第四级：!dd 2892b000 + 750kd&gt; !dd 2892b000 + 750#2892b750 00650068 006c006c 0020006f 006f0077#2892b760 006c0072 00000064 00000000 00000000#2892b770 00000000 00000000 00000000 00000000#2892b780 00000000 00000000 00000000 00000000#2892b790 00000000 0088000c 000a0005 0008014a#2892b7a0 00000000 000350ac 000aaec8 000aa3e0#2892b7b0 00000000 00000000 00000000 00000000#2892b7c0 0005002e 00102341 000800cc 00000000!db 2892b000 + 750 可验证 开启2-9-9-12：将C:\\boot.ini文件中的execute改为noexecute 重启 5、PDPTE结构 PDPTE共有四项（4 &#x3D; 2^2） 35-12 存储的是页目录表的基址，低12位补0，共36位，即页目录基址。 6、PDE结构 当PS&#x3D;1时是大页，35-21位是大页的物理地址，这样36位的物理地址的低21位为0，这就意味着页的大小为2MB，且都是2MB对齐。 12^21 = 2MB 当PS&#x3D;0时，35-12位是页表基址，低12位补0，共36位 12^12 = 4KB 在所有的表项中（除了指向2MB页的页目录项），基地址都被视为36位物理地址的高24位，这就迫使页表和页都是4KB对齐的（这样，36位物理地址的低12位都为0）。当页目录项指向一个2MB的页时，基地址被视为36位物理地址的高15位，这就迫使2MB的页都是2MB对齐的（这样，36位物理地址的低21位为0） 7、PTE结构 PTE中35-12是物理页基址，24位，低12位补0 物理页基址+12位的页内偏移指向具体数据 8、XD标志位AMD中称为NX,即No Excetion PDE&#x2F;PTE结构： 段的属性：有可读、可写和可执行 页的属性：有可读、可写 当RET执行返回的时候，如果我修改堆栈里面的数据指向一个我提前准备好的数据（把数据当作代码来执行）所以，Intel就做了硬件保护，做了一个不可执行位，XD&#x3D;1时。那么你的软件溢出了也没有关系，即使你的EIP蹦到了危险的“数据区”，也是不可以执行的！在PAE分页模式下，PDE与PTE的最高位为XD&#x2F;NX位 9、页目录表，页表基地址PAE分页模式下 页目录表基址：0xC0600000页表基址：0xC0000000 PDPTE、PDI与PTI 12-9-9-12 （I就是Index） 访问页目录表项（PDE）的公式： 10xc0600000 + PDPTI * 0x200 * 8 + PDI * 8 访问页表项（PTE）的公式 10xc0000000 + PDPTI * 0x200 * 0x200 * 8 + PDI * 0x200 * 8 + PTI * 8 TLB1、地址解析 通过一个线性地址访问一个物理页。比如：一个DWORD，其实未必真正读的是4个字节，我们先读的PDE再读PTE，最后才读的4个字节的页。 在2-9-9-12会读24个字节，如果跨页可能更多。为了提高效率，只能做记录。CPU内部做了一个表，来记录这些东西，这个表格是CPU内部的，和寄存器一样快，这个表格：TLB 2、TLB结构 ATTR（属性）：属性是PDPE PDE PTE三个属性AND起来的. 如果是10-10-12 就是PDE and PTE 不同的CPU 这个表的大小不一样 只要Cr3变了，TLB立马刷新，一核一套TLB. 操作系统的高2G映射基本不变，如果Cr3改了，TLB刷新 重建高2G以上很浪费。所以PDE和PTE中有个G标志位，如果G位为1刷新TLB时将不会刷新 PDE&#x2F;PTE的G位为1的页，当TLB满了，根据统计信息将不常用的地址废弃，最近最常用的保留 3、TLB种类TLB在X86体系的CPU里的实际应用最早是从Intel的486CPU开始的，在X86体系的CPU里边，一般都设有如下4组TLB: 第一组：缓存一般页表（4K字节页面）的指令页表缓存（Instruction-TLB） 第二组：缓存一般页表（4K字节页面）的数据页表缓存（Data-TLB） 第三组：缓存大尺寸页表（2M&#x2F;4M字节页面）的指令页表缓存（Instruction-TLB） 第四组：缓存大尺寸页表（2M&#x2F;4M字节页面）的数据页表缓存（Data-TLB） 中断与异常1、什么是中断 中断通常是由CPU外部的输入输出设备(硬件)所触发的，供外部设备通知CPU“有事情需要处理”，因此又叫中断请求(Interrupt Request) 中断请求的目的是希望CPU暂时停止执行当前正在执行的程序，转去执行中断请求所对应的中断处理例程(中断处理程序在哪有IDT表决定) 80x86有两条中断请求线 非屏蔽中断线，称为NMI（NonMaskable Interrupt） 可屏蔽中断线，称为INTR（Interrupt Require） 2、非可屏蔽中断如何处理 当非可屏蔽中断产生时，CPU在执行完当前指令后会里面进入中断处理程序非可屏蔽中断不受EFLAG寄存器中IF位的影响，一旦发生，CPU必须处理非可屏蔽中断处理程序位于IDT表中的2号位置 3、可屏蔽中断在硬件级，可屏蔽中断是由一块专门的芯片来管理的，通常称为中断控制器.它负责分配中断资源和管理各个中断源发出的中断请求.为了便于标识各个中断请求，中断管理器通常用IRQ(Interrupt Request)后面加上数字来表示不同的中断 比如：在Windows中 时钟中断的IRQ编号为0 也就是：IRQ0 4、时钟中断 大多数操作系统时钟中断在10-100MS之间，Windows系列为10-20MS 5、可屏蔽中断如何处理 （IDT表）中断号 IRQ 说明 0x30 IRQ0 时钟中断 0x31-0x3F IRQ1-IRQ15 其他硬件设备的中断 如果自己的程序执行时不希望CPU去处理这些中断 用CLI指令清空EFLAG寄存器中的IF位 用STI指令设置EFLAG寄存器中的IF位 硬件中断与IDT表中的对应关系并非固定不变的，参见：APIC（高级可编程中断控制器） 6、异常异常通常是CPU在执行指令时检测到的某些错误，比如除0、访问无效页面等 中断与异常的区别： 1、中断来自于外部设备，是中断源（比如键盘）发起的，CPU是被动的. 2、异常来自于CPU本身，是CPU主动产生的 3、INT N虽然被称为“软件中断”，但其本质是异常。EFLAG的IF位对INT N无效。 7、异常处理无论是由硬件设备触发的中断请求还是由CPU产生的异常，处理程序都在IDT表。 常见的异常处理程序： 错误类型 （IDT表）中断号 页错误 0xE 段错误 0xD 除零错误 0x0 双重错误 0x8 8、缺页异常缺页异常的产生： 1、当PDE&#x2F;PTE的P&#x3D;0时。 2、当PDE&#x2F;PTE的属性为只读，但程序试图写入的时一旦发生缺页异常，CPU会执行IDT表中的0xE号中断处理程序，由操作系统来接管。 控制寄存器1、控制寄存器 控制寄存器用于控制和确定CPU的操作模式 控制寄存器类型：Cr0、Cr1、Cr2、Cr3、Cr4、Cr8 Cr0：包含系统控制标志，用于控制处理器的工作模式和状态 Cr1：保留 Cr2：包含页面错误线性地址（导致页面错误的线性地址） Cr3：页目录表基址 Cr4：包含一组标志位，用于启用一些体系结构扩展功能，并指示操作系统或执行程序对特定处理器功能的支持情况。 Cr8：仅64位下使用 2、Cr0 PE位：CR0的位0是启用保护（Protection Enable）标志。 PE&#x3D;1保护模式 PE&#x3D;0 实地址模式 1这个标志仅开启段级保护，而并没有启用分页机制。若要启用分页机制，那么PE和PG标志都要置位。 PG位：当设置该位时即开启了分页机制。在开启这个标志之前必须已经或者同时开启PE标志。 12345PG=0且PE=0 处理器工作在实地址模式下PG=0且PE=1 处理器工作在没有开启分页机制的保护模式下PG=1且PE=0 在PE没有开启的情况下 无法开启PGPG=1且PE=1 处理器工作在开启了分页机制的保护模式下 WP位：对于Intel 80486或以上的CPU，CR0的位16是写保护（Write Proctect）标志当设置该标志时，处理器会禁止超级用户程序（例如特权级0的程序）向用户级只读页面执行写操作； 1234当CPL&lt;3的时候：如果 WP=0 可以读写任意用户级物理页，只要线性地址有效.如果 WP=1 可以读取任意用户级物理页，但对于只读的物理页，则不能写. 3、Cr2 当CPU访问某个无效页面时，会产生缺页异常，此时，CPU会将引起异常的线性地址存放在CR2中。 4、Cr4 PAE：1 是2-9-9-12分页 ，0 是10-10-12分页 PSE： PWT&#x2F;PCD1、CPU缓存 CPU缓存是位于CPU与物理内存之间的临时存储器，它的容量比内存小的多但是交换速度却比内存要快得多。 CPU缓存可以做的很大，有几K、几十K、几百K 甚至上M的也有。 CPU缓存与TLB的区别： TLB：线性地址 &lt;—–&gt; 物理地址 CPU缓存：物理地址 &lt;—–&gt; 内容 所以当拿到一个程序的线性地址查询时，先会使用TLB，然后在使用CPU缓存 2、关于PWT&#x2F;PCD属性PWT：Page Write Through 1PWT = 1 时 写Cache的时候也要将数据写入内存中。 PCD：Page Cache Disable 1PCD = 1时，禁止某个页写入缓存，直接写内存。\t比如，做页表用的页，已经存储在TLB中了，可能不需要再缓存了 具体细节参考Intel白皮书 调试踩坑1、32位的系统就得用老版本的32位windbg，不要用windbg perview 暂时不知道怎么解决 2、windbg老版本遇到寄存器内容无法显示 WingDbg.dll插件放windbg相同目录下 1!WingDbg.regfix 下载地址：https://github.com/mbikovitsky/WingDbg","tags":["滴水中级","win内核"],"categories":["逆向"]},{"title":"github actions 云编译","path":"/p/2d289b78/","content":"如何使用Github Actions 如果你想要编译别人的软件，在github上。 1、fork项目到自己仓库 2、点击当前项目的Action功能 3、新建一个工作流New workflow 4、选择你当前项目是什么语言，c、java、go等。 之后就会生成一个yml文件给你编辑 你把下面的模板粘贴进去修改一下就直接编译即可 如果原项目由github&#x2F;workflows那就直接用他的，没有则可以用下面这个模板 go项目编译1234567891011121314151617181920212223242526272829303132333435363738394041# This workflow will build a golang project# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-goname: Goon: push: branches: [ &quot;main&quot; ] pull_request: branches: [ &quot;main&quot; ]jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - name: Set up Go uses: actions/setup-go@v4 with: go-version: &#x27;1.20&#x27; - uses: goreleaser/goreleaser-action@v4 with: args: &quot;release --rm-dist --snapshot&quot; version: 1.23.0 env: GITHUB_TOKEN: &quot;$&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;&quot; path: ./ # 可根据你的项目结构选择编译产物路径 - name: Zip files run: zip -r dist/VcenterKiller_archive.zip dist/VcenterKiller* #编译后的名字 ，在虚拟机默认文件会在dist目录下 - name: Upload binaries to release uses: svenstaro/upload-release-action@v2 with: repo_token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; file: dist/VcenterKiller* tag: $&#123;&#123; github.ref &#125;&#125; overwrite: true file_glob: true draft: false #编译完成后 会自动发布到release java项目编译maven1234567891011121314151617181920212223242526272829303132333435363738394041# This workflow will build a Java project with Maven, and cache/restore any dependencies to improve the workflow execution time# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-java-with-maven# This workflow uses actions that are not certified by GitHub.# They are provided by a third-party and are governed by# separate terms of service, privacy policy, and support# documentation.name: Java CI with Mavenon: push: branches: [ &quot;main&quot; ] pull_request: branches: [ &quot;main&quot; ]jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - name: Set up JDK 8 uses: actions/setup-java@v4 with: java-version: &#x27;8&#x27; distribution: &#x27;temurin&#x27; cache: maven - name: Build with Maven run: | mvn package assembly:single - name: Upload binaries to release - name: Upload binaries to release uses: svenstaro/upload-release-action@v2 with: repo_token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; file: &#123;路径&#125;/&#123;项目名&#125;* tag: $&#123;&#123; github.ref &#125;&#125; overwrite: true file_glob: true draft: false #编译完成后 会自动发布到release gradle123456789101112131415161718192021222324252627282930313233343536373839404142434445# This workflow uses actions that are not certified by GitHub.# They are provided by a third-party and are governed by# separate terms of service, privacy policy, and support# documentation.# This workflow will build a Java project with Gradle and cache/restore any dependencies to improve the workflow execution time# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-java-with-gradlename: Java CI with Gradleon: push: branches: [ &quot;main&quot; ] pull_request: branches: [ &quot;main&quot; ]jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - name: Set up JDK 8 uses: actions/setup-java@v4 with: java-version: &#x27;8&#x27; distribution: &#x27;temurin&#x27; # Configure Gradle for optimal use in GitHub Actions, including caching of downloaded dependencies. # See: https://github.com/gradle/actions/blob/main/setup-gradle/README.md - name: Setup Gradle uses: gradle/actions/setup-gradle@af1da67850ed9a4cedd57bfd976089dd991e2582 # v4.0.0 with: gradle-version: &#x27;8.7&#x27; - name: Build with Gradle Wrapper run: ./gradlew shadowJar - name: Upload binaries to release uses: svenstaro/upload-release-action@v2 with: repo_token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; file: build/libs/&#123;项目名&#125;* #这里需要修改 tag: $&#123;&#123; github.ref &#125;&#125; overwrite: true file_glob: true draft: false #编译完成后 会自动发布到release 具体保存得看构建的时候日志问题 rust项目编译123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209name: Release - Distribute binarieson: # If we want to make release using github interface. # release: # types: [published] # If we want to make release by pushing new tag. workflow_dispatch: push: tags: - &#x27;[0-9]+.[0-9]+.[0-9]+&#x27; pull_request: branches: - master paths: - &#x27;Cargo.toml&#x27; - &#x27;Cargo.lock&#x27; - &#x27;.github/workflows/test.yml&#x27;env: BIN_NAME: legba PROJECT_NAME: legba REPO_NAME: Legba/Legba BREW_TAP: Legba/homebrew-tapjobs: build: name: Build runs-on: $&#123;&#123; matrix.os &#125;&#125; strategy: fail-fast: false # don&#x27;t fail other jobs if one fails matrix: # aarch64-linux is failing due to python3 missing issues during tests. I&#x27;m removing it for now. # build: [x86_64-linux, aarch64-linux, x86_64-macos, aarch64-macos, x86_64-windows, x86_64-win-gnu] build: [x86_64-linux, x86_64-macos, aarch64-macos, x86_64-windows, x86_64-win-gnu] include: # - build: aarch64-linux # os: ubuntu-20.04 # rust: stable # target: aarch64-unknown-linux-gnu # cross: true - build: aarch64-macos os: macos-latest rust: stable target: aarch64-apple-darwin cross: true - build: x86_64-linux os: ubuntu-20.04 rust: stable target: x86_64-unknown-linux-gnu cross: false - build: x86_64-macos os: macos-latest rust: stable target: x86_64-apple-darwin cross: false - build: x86_64-windows os: windows-2019 rust: stable target: x86_64-pc-windows-msvc cross: false - build: x86_64-win-gnu os: windows-2019 rust: stable-x86_64-gnu target: x86_64-pc-windows-gnu cross: false steps: - name: Set Git config (windows only) if: contains(matrix.os, &#x27;windows&#x27;) # Windows is missing some dependencies run: | git config --global pack.windowMemory &quot;100m&quot; git config --global pack.packSizeLimit &quot;100m&quot; git config --global pack.threads &quot;1&quot; git config --global pack.deltaCacheSize &quot;512m&quot; #- name: Windows Install dependencies # if: contains(matrix.os, &#x27;windows&#x27;) # run: | # powershell.exe -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command &quot;iex ((New-Object System.Net.WebClient).DownloadString(&#x27;https://chocolatey.org/install.ps1&#x27;))&quot; # SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin&quot; # choco install openssl -y - name: Install dependencies #(按实际情况修改) if: contains(matrix.build, &#x27;x86_64-linux&#x27;) # Windows is missing some dependencies run: sudo apt-get update &amp;&amp; sudo apt-get install -y gcc-aarch64-linux-gnu python3 - name: Install python 3.10 uses: actions/setup-python@v5 with: python-version: &#x27;3.10&#x27; - name: Checkout sources uses: actions/checkout@v4 with: submodules: true - name: Install $&#123;&#123; matrix.rust &#125;&#125; toolchain uses: actions-rs/toolchain@v1 with: profile: minimal toolchain: $&#123;&#123; matrix.rust &#125;&#125; target: $&#123;&#123; matrix.target &#125;&#125; override: true - name: Run cargo test uses: actions-rs/cargo@v1 with: use-cross: $&#123;&#123; matrix.cross &#125;&#125; command: test args: --release --locked --target $&#123;&#123; matrix.target &#125;&#125; - name: Build release binary uses: actions-rs/cargo@v1 with: use-cross: $&#123;&#123; matrix.cross &#125;&#125; command: build args: --release --locked --target $&#123;&#123; matrix.target &#125;&#125; - name: Calculate tag name # if: contains(matrix.build, &#x27;linux&#x27;) shell: bash run: | name=dev if [[ $&#123;GITHUB_REF&#125; =~ refs/tags/[0-9]+.[0-9]+.[0-9]+ ]]; then name=$&#123;GITHUB_REF#refs/tags/&#125; fi echo &quot;TAG=$name&quot; &gt;&gt; $GITHUB_ENV id: tagname - name: Build and package artifacts shell: bash run: | mkdir dist if [[ &quot;$&#123;&#123; matrix.build &#125;&#125;&quot; =~ &quot;windows&quot; ]]; then cp &quot;target/$&#123;&#123; matrix.target &#125;&#125;/release/$BIN_NAME.exe&quot; &quot;dist/&quot; else cp &quot;target/$&#123;&#123; matrix.target &#125;&#125;/release/$BIN_NAME&quot; &quot;dist/&quot; fi if [[ &quot;$&#123;&#123; matrix.build &#125;&#125;&quot; =~ &quot;linux&quot; ]]; then cargo install cargo-deb cargo deb --target $&#123;&#123; matrix.target &#125;&#125; --deb-version $&#123;TAG&#125; cp &quot;target/$&#123;&#123; matrix.target &#125;&#125;/debian/legba_$&#123;TAG&#125;_amd64.deb&quot; &quot;dist/&quot; || true fi - uses: actions/upload-artifact@v4.3.4 with: name: bins-$&#123;&#123; matrix.build &#125;&#125; path: dist package: name: Package needs: [build] runs-on: ubuntu-latest steps: - name: Checkout sources uses: actions/checkout@v4 with: submodules: false - uses: actions/download-artifact@v4 with: path: dist - name: Calculate tag name # if: contains(matrix.build, &#x27;linux&#x27;) shell: bash run: | name=dev if [[ $&#123;GITHUB_REF&#125; =~ refs/tags/[0-9]+.[0-9]+.[0-9]+ ]]; then name=$&#123;GITHUB_REF#refs/tags/&#125; fi echo &quot;TAG=$name&quot; &gt;&gt; $GITHUB_ENV id: tagname - name: Build archive shell: bash run: | set -ex rm -rf tmp mkdir tmp for dir in dist/bins-* ; do platform=$&#123;dir#&quot;dist/bins-&quot;&#125; unset exe if [[ $platform =~ &quot;win&quot; ]]; then exe=&quot;.exe&quot; fi pkgname=$PROJECT_NAME-$TAG-$platform mkdir tmp/$pkgname cp $dir/$BIN_NAME$exe dist/ || true mv $dir/$BIN_NAME$exe tmp/$pkgname chmod +x tmp/$pkgname/$BIN_NAME$exe if [[ $platform =~ &quot;linux&quot; ]]; then mv &quot;$dir/legba_$&#123;TAG&#125;_amd64.deb&quot; dist/ || true fi tar cJf dist/$pkgname.tar.xz -C tmp $pkgname 7z a dist/$pkgname.zip tmp/$pkgname done - name: Upload binaries to release if: (github.event_name == &#x27;push&#x27; &amp;&amp; startsWith(github.ref, &#x27;refs/tags/&#x27;)) || github.event_name == &#x27;release&#x27; uses: svenstaro/upload-release-action@v2 with: repo_token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; file: dist/* file_glob: true tag: $&#123;&#123; github.ref &#125;&#125; overwrite: true","tags":["github-actions"],"categories":["开发"]},{"title":"Hello World","path":"/p/4a17b156/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment This message is used to verify that this feed (feedId:72563970594258944) belongs to me (userId:72463685633295360). Join me in enjoying the next generation information browser https://follow.is."},{"title":"explore","path":"/explore/index.html","content":"CyberChef加密解密反弹shell生成反弹shell网页"},{"title":"友链","path":"/friends/index.html","content":""}]