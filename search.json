[{"title":"shellcode编写","path":"/p/22672422/","content":"什么是ShellCode？不依赖环境，放到任何地方都可以执行的机器码 shellcode编写原则 不能有全局变量 不能使用常量字符串 不能使用系统调用 不能嵌套调用其他函数 案例思路通过TEB结构体查找PEB，然后在PEB中找到_PEB_LDR_DATA，再从_PEB_LDR_DATA中找到InLoadOrderModuleList，这是一个dll的链表，也可以通过这个结构来进行断链dll隐藏，_LDR_DATA_TABLE_ENTRY这是链表里的node的结构体，接下来我们遍历我们想要找到的dll，拿到DllBase，之后通过PE的知识解析，从中找到导入表，从导入表中拿到GetProcAddress和LoadLibraryA函数，之后就可以通过这两个函数进行加载dll和使用dll中的函数。 实例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167// demo08shellcode.cpp : Defines the entry point for the console application.//#include &quot;stdafx.h&quot;#include &lt;windows.h&gt;//functiontypedef FARPROC (WINAPI *GETPROCADDRESS)(HMODULE hModule,LPCSTR lpProcName); typedef int (WINAPI *MESSAGEBOXA)(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType);typedef HMODULE (WINAPI *LOADLIBRARYA)(LPCSTR lpLibFileName);GETPROCADDRESS PGETPROCADDRESS;MESSAGEBOXA PMESSAGEBOX;LOADLIBRARYA PLOADLIBRARY;//structtypedef struct _UNICODE_STRING&#123; USHORT Length; //0x0 USHORT MaximumLength; //0x2 PWSTR Buffer; //0x4&#125;UNICODE_STRING;//0x0 bytes (sizeof)//0x28 bytes (sizeof)typedef struct _PEB_LDR_DATA&#123; DWORD Length; //0x0 BYTE Initialized; //0x4 VOID* SsHandle; //0x8 LIST_ENTRY InLoadOrderModuleList; //0xc LIST_ENTRY InMemoryOrderModuleList; //0x14 LIST_ENTRY InInitializationOrderModuleList; //0x1c VOID* EntryInProgress; //0x24&#125;PEB_LDR_DATA; typedef struct _LDR_DATA_TABLE_ENTRY&#123; LIST_ENTRY InLoadOrderLinks; //0x0 LIST_ENTRY InMemoryOrderLinks; //0x8 LIST_ENTRY InInitializationOrderLinks; //0x10 VOID* DllBase; //0x18 VOID* EntryPoint; //0x1c DWORD SizeOfImage; //0x20 UNICODE_STRING FullDllName; //0x24 UNICODE_STRING BaseDllName; //0x2c DWORD Flags; //0x34 WORD LoadCount; //0x38 WORD TlsIndex; //0x3a union &#123; LIST_ENTRY HashLinks; //0x3c struct &#123; VOID* SectionPointer; //0x3c DWORD CheckSum; //0x40 &#125;; &#125;; union &#123; DWORD TimeDateStamp; //0x44 VOID* LoadedImports; //0x44 &#125;; VOID* EntryPointActivationContext; //0x48 VOID* PatchInformation; //0x4c&#125;LDR_DATA_TABLE_ENTRY; int strcmp(char* buf1,char* buf2)&#123;\twhile(*buf1 &amp;&amp; *buf2 &amp;&amp; *buf1 == *buf2)&#123; buf1++; buf2++;\t&#125;\tif (*buf1 == *buf2)\t&#123; return 1;\t&#125;\treturn 0;&#125;void ToShellcode()&#123;\tLDR_DATA_TABLE_ENTRY *pPLD = NULL,*pBeg = NULL;\tPGETPROCADDRESS = NULL;\tPLOADLIBRARY = NULL;\tPMESSAGEBOX = NULL;\tWORD *pFirst = NULL,*pLast = NULL;\tDWORD ret = 0,i=0;\tDWORD dwKernelBase = 0;\tchar szKerner32[] = &#123;&#x27;k&#x27;,0,&#x27;e&#x27;,0,&#x27;r&#x27;,0,&#x27;n&#x27;,0,&#x27;e&#x27;,0,&#x27;l&#x27;,0,&#x27;3&#x27;,0,&#x27;2&#x27;,0,&#x27;.&#x27;,0,&#x27;d&#x27;,0,&#x27;l&#x27;,0,&#x27;l&#x27;,0,0,0&#125;;\tchar szUser32[] = &#123;&#x27;U&#x27;,&#x27;S&#x27;,&#x27;E&#x27;,&#x27;R&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;.&#x27;,&#x27;d&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,0&#125;; char szGetProAddress[] = &#123;&#x27;G&#x27;,&#x27;e&#x27;,&#x27;t&#x27;,&#x27;P&#x27;,&#x27;r&#x27;,&#x27;o&#x27;,&#x27;c&#x27;,&#x27;A&#x27;,&#x27;d&#x27;,&#x27;d&#x27;,&#x27;r&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;s&#x27;,0&#125;;\tchar szLoadLibrary[] = &#123;&#x27;L&#x27;,&#x27;o&#x27;,&#x27;a&#x27;,&#x27;d&#x27;,&#x27;L&#x27;,&#x27;i&#x27;,&#x27;b&#x27;,&#x27;r&#x27;,&#x27;a&#x27;,&#x27;r&#x27;,&#x27;y&#x27;,&#x27;A&#x27;,0&#125;;\tchar szMessageBox[] = &#123;&#x27;M&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;s&#x27;,&#x27;a&#x27;,&#x27;g&#x27;,&#x27;e&#x27;,&#x27;B&#x27;,&#x27;o&#x27;,&#x27;x&#x27;,&#x27;A&#x27;,0&#125;;\tchar lpText[] = &#123;0xD7,0xA2,0xC8,0xEB,0xB3,0xC9,0xB9,0xA6,0x00&#125;;\tchar lpCaption[]= &#123;&#x27;s&#x27;,&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;c&#x27;,&#x27;o&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;T&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;t&#x27;,0&#125;;\t__asm&#123; mov eax,fs:[0x30] //PEB mov eax,[eax+0xc] //PEB-&gt;Ldr add eax,0x0c //LDR_DATA_TABLE_ENTRY InLoadOrderModuleList mov pBeg,eax mov eax,[eax] mov pPLD,eax\t&#125;\t/*\tif (strcmp(szMessageBox,name))\t&#123; printf(&quot;%d:--%s--%x &quot;,t+1,name,funAddress); PMESSAGEBOX = (MESSAGEBOX)funAddress;\t&#125;*/\t//kernel32.dll\twhile (pPLD != pBeg)\t&#123; pLast = (WORD*)pPLD-&gt;BaseDllName.Buffer; pFirst = (WORD*)szKerner32; while(!pLast &amp;&amp; *pLast == *pFirst)&#123; pLast++; pFirst++; &#125; if (*pLast == *pFirst) &#123; dwKernelBase = (DWORD)pPLD-&gt;DllBase; break; &#125; pPLD = (LDR_DATA_TABLE_ENTRY*)pPLD-&gt;InLoadOrderLinks.Flink;\t&#125;\tPIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)dwKernelBase;\tPIMAGE_NT_HEADERS pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\tPIMAGE_FILE_HEADER pPEHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTHeader + 4);\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + IMAGE_SIZEOF_FILE_HEADER);\tDWORD dataDirectorySize = sizeof(pOptionHeader-&gt;DataDirectory) / sizeof(IMAGE_DATA_DIRECTORY);\tPIMAGE_DATA_DIRECTORY pDataDirectory = (PIMAGE_DATA_DIRECTORY)pOptionHeader-&gt;DataDirectory;\tPIMAGE_EXPORT_DIRECTORY pExportTable = (PIMAGE_EXPORT_DIRECTORY)(dwKernelBase + pDataDirectory-&gt;VirtualAddress);\tLPVOID funNameBase = (LPVOID)(dwKernelBase + pExportTable-&gt;AddressOfNames);\tLPVOID funAddressBase = (LPVOID)(dwKernelBase + pExportTable-&gt;AddressOfFunctions);\tfor (DWORD t = 0;t&lt;pExportTable-&gt;NumberOfNames;t++)\t&#123; DWORD funAddress = dwKernelBase + *(PDWORD)((DWORD)funAddressBase+(t*4)); char* name = (char*)(dwKernelBase + *(PDWORD)((DWORD)funNameBase+(t*4))); //printf(&quot;name:%s &quot;,name); if (strcmp(szGetProAddress,name)) &#123; printf(&quot;%d:--%s--%x &quot;,t+1,name,funAddress); PGETPROCADDRESS = (GETPROCADDRESS)funAddress; &#125;else if (strcmp(szLoadLibrary,name)) &#123; printf(&quot;%d:--%s--%x &quot;,t+1,name,funAddress); PLOADLIBRARY = (LOADLIBRARYA)funAddress; &#125;\t&#125;\t//getchar();\tHMODULE hmodule = PLOADLIBRARY((LPCSTR)szUser32);\tPMESSAGEBOX = (MESSAGEBOXA)PGETPROCADDRESS(hmodule,szMessageBox);\tPMESSAGEBOX(0,lpText,lpCaption,MB_OK);\treturn;&#125;int main(int argc, char* argv[])&#123;\tToShellcode();\tprintf(&quot;Hello World! &quot;);\treturn 0;&#125;","tags":["shellcode","恶意代码"],"categories":["逆向"]},{"title":"保护模式","path":"/p/6c15571f/","content":"保护模式介绍什么是保护模式？x86 CPU的3个模式：实模式、保护模式和虚拟8086模式。 为什么不直接讲x64的？x86是由Intel推出的一种复杂指令集,能够生产支持这种指令集CPU公司主要是Intel和AMD. AMD在1999年的时候，拓展了这套指令集，称为x86-64,后改名为AMD64,Intel也兼容了这个产品，称为Intel 64.但AMD64和Intel64几乎是一样的，所以在很多资料中统称为x64.这套指令集是对x86的拓展，向下兼容的. 保护模式有什么特点？段的机制 页的机制 学习保护模式有什么用？真正理解内核是如何运作的 段寄存器结构1、什么是段寄存器？当我们用汇编读写某一个地址时： 1mov dword ptr ds:[0x123456] eax我们真正读写的地址是： 1ds.base + 0x123456 ES CS SS DS FS GS LDTR TR 共8个 2、段寄存器的结构 3、段寄存器的读写3.1 读段寄存器12345比如：MOV AX,ES 只能读16位的可见部分读写LDTR的指令为：SLDT/LLDT读写TR的指令为：STR/LTR 3.2 写段寄存器1比如：MOV DS,AX 写时是写96位 段寄存器属性探测1、段寄存器成员简介 段寄存器 Selector Attribute Base Limit ES 0023 可读、可写 0 0xFFFFFFFF CS 001B 可读、可执行 0 0xFFFFFFFF SS 0023 可读、可写 0 0xFFFFFFFF DS 0023 可读、可写 0 0xFFFFFFFF FS 003B 可读、可写 0x7FFDE000 0xFFF GS - - - - 2、探测Attribute1234567int var = 0; __asm &#123; mov ax,ss\t//cs不行 cs是可读 可执行 但不可写 mov ds,ax mov dword ptr ds:[var],eax &#125; 3、探测Base12345678910int var = 1; __asm &#123; mov ax,fs mov gs,ax mov eax,gs:[0]\t//不要用DS 否则编译不过去 mov dword ptr ds:[var],eax //mov edx,dword ptr ds:[0x7FFDF000]&#125; 4、探测Limit12345678910int var = 1; __asm &#123; mov ax,fs mov gs,ax mov eax,gs:[0]\t//不要用DS 否则编译不过去 mov dword ptr ds:[var],eax //mov edx,dword ptr ds:[0x7FFDF000]&#125; 段描述符与段选择子段描述符分类GDT(全局描述符表) LDT(局部描述符表) 当我们执行类似MOV DS,AX指令时，CPU会查表，根据AX的值来决定查找GDT还是LDT,查找表的什么位置，查出多少数据. 段描述符 段选择子段选择子是一个16位的段描述符，该描述符指向了定义该段的段描述符. RPL：请求特权级别 TI： 12TI=0 查GDT表TI=1 查LDT表 Index：处理器将索引值乘以8在加上GDT或者LDT的Base地址，就是要加载的段描述符 加载段描述符至段寄存器除了MOV指令，我们还可以使用LES、LSS、LDS、LFS、LGS指令修改寄存器 CS不能通过上述的指令进行修改，CS为代码段，CS的改变会导致EIP的改变，要改CS，必须要保证CS与EIP一起改，后面会讲 12345char buffer[6]; __asm &#123; les ecx,fword ptr ds:[buffer] //高2个字节给es，低四个字节给ecx\t&#125; [!NOTE] 注意：RPL&lt;&#x3D;DPL(在数值上) 段描述符属性P位和G位1、P位 123P = 1 段描述符有效P = 0 段描述符无效 2、G位（当前上限） G &#x3D; 0 Limit单位是字节 1Limit = 000 FFFFF 前面加000 G &#x3D; 1 Limit单位是4G 1Limit = FFFFF FFF 后面加FFF S位和TYPE域1、S位 S &#x3D; 1 代码段或者数据段描述符 S &#x3D; 0 系统段描述符 2、TYPE域 分析举例 数据段（DS）说明Access 访问位，表示该位最后一次被操作系统清零后，该段是否被访问过.每当处理器将该段选择符置入某个段寄存器时，就将该位置1. Write 是否可写 E 扩展方向 （向上拓展红色部分图一，向下拓展红色部分图二） 代码段（CS）说明A 访问位 R 可读位 C 一致位 123C = 1 一致代码段C = 0 非一致代码段 系统段（SS）描述符当S&#x3D;0时，该段描述符为系统描述符.系统描述符有分为以下类型 DB位DB位：当前实际地址最多大小 1、CS段 1D = 1 采用32位寻址方式 整个地址空间是4G 12D = 0 采用16位寻址方式\t前缀67 改变寻址方式 整个地址空间是64K 2、SS段 123D = 1 隐式堆栈访问指令（如：PUSH POP CALL） 使用32位堆栈指针寄存器ESP D = 0 隐式堆栈访问指令（如：PUSH POP CALL） 使用16位堆栈指针寄存器SP 3、向下拓展的数据段 1D = 1 段上线为4GB 1D = 0 段上线为64KB 段权限检查CPU分级 如何查看程序处于几环?CPL(Current Privilege Level) ：当前特权级 CS和SS中存储的段选择子后2位 例如：23 &#x3D;&#x3D; 0010 0011 2b &#x3D;&#x3D; 0010 1011 11&#x3D;&#x3D;3 那么在三环 DPL(Descriptor Privilege Level) 描述符特权级别 DPL存储在段描述符中，规定了访问该段所需要的特权级别是什么. 通俗的理解：如果你想访问我，那么你应该具备什么特权. 举例说明： 123mov DS,AX 如果AX指向的段DPL = 0 但当前程序的CPL = 3 这行指令是不会成功的 RPL(Request Privilege Level) 请求特权级别RPL是针对段选择子而言的，每个段的选择子都有自己的RPL 举例说明： 123Mov ax,0008\t与\tMov ax,000B //段选择子 Mov ds,ax Mov ds,ax //将段描述指向的是同一个段描述符,但RPL是不一样的. 数据段的权限检查12345比如当前程序处于0环，也就是说CPL=0Mov ax,000B\t//1011 RPL = 3Mov ds,ax\t//ax指向的段描述符的DPL = 0 数据段的权限检查： 1CPL &lt;= DPL 并且 RPL &lt;= DPL (数值上的比较) 注意：代码段和系统段描述符中的检查方式并不一样 总结12345CPL CPU当前的权限级别DPL 如果你想访问我，你应该具备什么样的权限RPL 用什么权限去访问一个段 代码跨段执行流程段寄存器:ES,CS,SS,DS,FS,GS,LDTR,TR 段寄存器读写：除CS外，其他的段寄存器都可以通过MOV,LES,LSS,LDS,LFS,LGS指令进行修改 1、代码间的跳转(段间跳转 非调用门之类的)段间跳转，有2种情况，即要跳转的段是一致代码段还是非一致代码段，也就是看C等于0还是1 同时修改CS与EIP的指令 JMP FAR &#x2F; CALL FAR &#x2F; RETF &#x2F; INT &#x2F;IRETED [!NOTE] 注意：只改变EIP的指令 JMP &#x2F; CALL &#x2F; JCC &#x2F; RET 2、执行流程CPU如何执行这行代码? JMP 0x20:0x004183D7 (1) 段选择子拆分 12340x20 对应二进制形式 0000 0000 0010 0000\tRPL = 00 TI = 0Index = 4 (2) 查表得到段描述符 12345TI = 0 所以查GDT表 Index = 4 找到对应的段描述符四种情况可以跳转：代码段、调用门、TSS任务段、任务门 (3) 权限检查 123如果是非一致代码段，要求:CPL == DPL 并且 RPL &lt;= DPL 如果是一致代码段，要求:CPL &gt;= DPL (4) 加载段描述符 1通过上面的权限检查后，CPU会将段描述符加载到CS段寄存器中. (5) 代码执行 1CPU将 CS.Base + Offset 的值写入EIP 然后执行CS:EIP处的代码，段间跳转结束. 3、总结 对于一致代码段:也就是共享的段 特权级高的程序不允许访问特权级低的数据：核心态不允许访问用户态的数据 特权级低的程序可以访问到特权级高的数据，但特权级不会改变：用户态还是用户态 对于普通代码段：也就是非一致代码段 只允许同级访问 绝对禁止不同级别的访问：核心态不是用户态，用户态也不是核心态. 直接对代码段进行JMP 或者 CALL的操作，无论目标是一致代码段还是非一致代码段，CPL都不会发生改变.如果要提升CPL的权限，只能通过调用门. 3、实验3.1 构造段描述符找一个非一致代码段描述符,复制一份，写入到GDT表中 1234567891011kd&gt; r gdtrgdtr=8003f000kd&gt; dq 8003f0008003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffb00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab8003f030 ffc093df`f0000001 0040f300`00000fff8003f040 0000f200`0400ffff 00000000`000000008003f050 80008954`b1000068 80008954`b16800688003f060 00009302`2f40ffff 0000920b`80003fff8003f070 ff0092ff`700003ff 80009a40`0000ffff 将 00cffb00&#96;0000ffff 数据写如某个P位为0的位置 1kd&gt; eq 8003f048 00cffb00`0000ffff(用内核工具查看新增是否成功） 3.2 OD中进行测试在OD中，执行跨段跳转 JMP FAR 004B:0041840D 成功的话，CS段寄存器就会修改成4B 3.3 修改段描述符的权限级别,并再次在OD中进行测试将00cffb00`0000ffff 改为00cf9b00`0000ffff在OD中，执行跨段跳转 JMP FAR 004B:0041840D 3.4 将该段描述符的属性更改为一致代码段.将00cffb00`0000ffff 改为00cf9f00`0000ffff在OD中，执行跨段跳转 JMP FAR 004B:0041840D 如果是一致代码段，要求:CPL &gt;&#x3D; DPL (当前同样可以访问) CPL:3 DPL:0 4、总结1、为了对数据进行保护，普通代码段是禁止不同级别进行访问的。用户态的代码不能访问内核的数据，同样，内核态的代码也不能访问用户态的数据. 2、如果想提供一些通用的功能，而且这些功能并不会破坏内核数据，那么可以选择一致代码段，这样低级别的程序可以在不提升CPL权限等级的情况下即可以访问. 3、如果想访问普通代码段，只有通过“调用门”等提示CPL权限，才能访问。 长调用与短调用我们通过JMP FAR可以实现段间的跳转，如果要实现跨段的调用就必须要学习CALL FAR，也就是长调用. CALL FAR比JMP FAR要复杂，JMP并不影响堆栈,但CALL指令会影响. 1、短调用指令格式：CALL 立即数&#x2F;寄存器&#x2F;内存 发生改变的寄存器：ESP EIP 2、长调用(跨段不提权)指令格式：CALL CS:EIP(EIP是废弃的) 发生改变的寄存器：ESP EIP CS 3、长调用(跨段并提权)指令格式：CALL CS:EIP(EIP是废弃的) 发生改变的寄存器：ESP EIP CS SS 4、总结 跨段调用时，一旦有权限切换，就会切换堆栈. CS的权限一旦改变，SS的权限也要随着改变，CS与SS的等级必须一样. JMP FAR 只能跳转到同级非一致代码段，但CALL FAR可以通过调用门提权，提升CPL的权限. 调用门1、调用门执行流程指令格式：CALL CS:EIP(EIP是废弃的) 执行步骤： 根据CS的值 查GDT表，找到对应的段描述符 这个描述符是一个调用门. 在调用门描述符中存储另一个代码段段的选择子. 选择子指向的段 段.Base + 偏移地址 就是真正要执行的地址. 2、门描述符 3、构造一个调用门（无参 提权）1234567891011第一步：构造大概的值DPL:3环 == 110000 0000 0000 0000 1110 1100(调用门固定值) 0000 0000 == 0000ec000000 0000 0000 1000 0000 0000 0000 0000 == 000800000000ec00`00080000第二步：拿到方法地址4010000040ec00`00081000第三步：eq 80b99048 0040ec00`00081000第四步：运行程序 3.1 代码测试步骤一：代码测试，并观察堆栈与寄存器的变化记录执行前的寄存器值：SS ESP CS 执行前： 执行后： 1234567eax=00000048 ebx=7ffd9000 ecx=00000000 edx=00000001 esi=00000000 edi=0012fe5ceip=00401000 esp=a69f5ca0 ebp=0012fe5c iopl=0 nv up ei pl nz na pe nccs=0008 ss=0010 ds=0023 es=0023 fs=0030 gs=0000 efl=00000206 变化： 12345CS:1b-&gt;08 ESP:12fd7c-&gt;a682bca0(高地址)SS:23-&gt;10 堆栈： 步骤二：在测试代码中加入特权指令并读取高2G内存 测试代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950BYTE GDT[6] = &#123;0&#125;;DWORD dwH2Gvalue;void _declspec(naked) getRegister()&#123;\t__asm&#123; pushad pushfd mov eax,0x80b9900c mov ebx,[eax] mov dwH2Gvalue,ebx sgdt GDT //获取GDT表地址 popfd popad retf\t&#125;&#125;void printfRegister()&#123;\tDWORD GDT_ADDR = *(PDWORD)(&amp;GDT[2]);\tWORD GDT_LIMIT = *(PWORD)(&amp;GDT[0]);\tprintf(&quot;%x %x %x &quot;,dwH2Gvalue,GDT_ADDR,GDT_LIMIT);&#125;int testfun1()&#123;\t__asm&#123; mov ebx,ebx mov ebx,ebx\t&#125;\tchar buf[6];\t*(DWORD*)&amp;buf[0] = 0x12345678;\t*(WORD*)&amp;buf[4] = 0x48;\t__asm&#123; call fword ptr[buf]\t&#125;\tprintfRegister();\tgetchar();\treturn 0;&#125;int _tmain(int argc, _TCHAR* argv[])&#123;\ttestfun1();\treturn 0;&#125; 4、构造一个调用门（有参 提权）调用门描述符： 0040EC03&#96;00081030 （三个参数） 1kd&gt;eq 8003f048 0040EC03`00081030 测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// demo03.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &lt;windows.h&gt;DWORD x,y,z;void _declspec(naked) getRegister()&#123;\t__asm&#123; pushad pushfd mov eax,[esp+0x24+0x8+0x8] mov dword ptr ds:[x],eax mov eax,[esp+0x24+0x8+0x4] mov dword ptr ds:[y],eax mov eax,[esp+0x24+0x8+0x0] mov dword ptr ds:[z],eax popfd popad retf 0xc\t&#125;&#125;void printfRegister()&#123;\tprintf(&quot;%x %x %x &quot;,x,y,z);&#125;int testfun1()&#123; char buf[6];\t*(DWORD*)&amp;buf[0] = 0x12345678;\t*(WORD*)&amp;buf[4] = 0x68;\t__asm&#123; push 1 push 2 push 3 call fword ptr[buf]\t&#125;\tprintfRegister();\tgetchar();\treturn 0;&#125;int _tmain(int argc, _TCHAR* argv[])&#123;\ttestfun1();\treturn 0;&#125; 成功获取到3个传入的参数 5、总结 当通过门，权限不变的时候，只会PUSH两个值：CS和返回地址新的CS的值由调用门决定 当通过门，权限改变的时候，会PUSH四个值：SS、ESP、CS和返回地址 新的CS的值由调用门决定 新的SS和ESP由TSS提供 通过门调用时，要执行哪行代码有调用门决定，但使用RETF返回时，由堆栈中压入的值决定，这就是说，进门时只能按指定路线走，出门时可以翻墙(只要改变堆栈里面的值就可以想去哪去哪) 可不可以再建个门出去呢?也就是用Call 当然可以了 前门进 后门出 中断门使用场景 系统调用 调试 1、IDTIDT即中断描述符表,同GDT一样，IDT也是由一系列描述符组成的，每个描述符占8个字节。但要注意的是，IDT表中的第一个元素不是NULL。在windbg中查看IDT表的基址和长度 2、IDT表的构成IDT表可以包含3种门描述符： 任务门描述符 中断门描述符 陷阱门描述符 3、中断门描述符结构 当8-12位的值是01110则是一个中断门 4、构造一个中断门1aaa 陷阱门1、陷阱门描述符结构 当8-12位的值是01111则是一个陷阱门 2、构造一个陷阱门1sss 3、陷阱门与中断门的区别中断门执行时，将IF位（中断标志）清零,但陷阱门不会。 任务段在调用门、中断门与陷阱门中，一旦出现权限切换，那么就会有堆栈的切换。而且，由于CS的CPL发生改变，也导致了SS也必须要切换。 切换时，会有新的ESP和SS(CS是由中断门或者调用门指定)这2个值从哪里来的呢？TSS (Task-state segment )，任务状态段. 1、TSS的结构 大小104字节 2、TSS的作用不要把TSS与“任务切换”联系到一起 TSS的意义就在于可以同时换掉”一堆”寄存器 3、TR段寄存器CPU如何找到TSS呢? 通过TR段寄存器 4、TSS段描述符(TSS Descriptor) 5、TR寄存器读写 将TSS段描述符加载到TR寄存器 指令：LTR 说明： 用LTR指令去装载的话仅仅是改变TR寄存器的值(96位) 并没有真正改变TSS LTR指令只能在系统层使用 加载后TSS段描述符会状态位会发生改变 调试踩坑1、32位的系统就得用老版本的32位windbg，不要用windbg perview 暂时不知道怎么解决 2、windbg老版本遇到寄存器内容无法显示 WingDbg.dll插件放windbg相同目录下 1!wingdbg.fix 下载地址：https://github.com/mbikovitsky/WingDbg","tags":["滴水中级","win逆向"],"categories":["逆向"]},{"title":"github actions 云编译","path":"/p/2d289b78/","content":"如何使用Github Actions 如果你想要编译别人的软件，在github上。 1、fork项目到自己仓库 2、点击当前项目的Action功能 3、新建一个工作流New workflow 4、选择你当前项目是什么语言，c、java、go等。 之后就会生成一个yml文件给你编辑 你把下面的模板粘贴进去修改一下就直接编译即可 如果原项目由github&#x2F;workflows那就直接用他的，没有则可以用下面这个模板 go项目编译1234567891011121314151617181920212223242526272829303132333435363738394041# This workflow will build a golang project# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-goname: Goon: push: branches: [ &quot;main&quot; ] pull_request: branches: [ &quot;main&quot; ]jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - name: Set up Go uses: actions/setup-go@v4 with: go-version: &#x27;1.20&#x27; - uses: goreleaser/goreleaser-action@v4 with: args: &quot;release --rm-dist --snapshot&quot; version: 1.23.0 env: GITHUB_TOKEN: &quot;$&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;&quot; path: ./ # 可根据你的项目结构选择编译产物路径 - name: Zip files run: zip -r dist/VcenterKiller_archive.zip dist/VcenterKiller* #编译后的名字 ，在虚拟机默认文件会在dist目录下 - name: Upload binaries to release uses: svenstaro/upload-release-action@v2 with: repo_token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; file: dist/VcenterKiller* tag: $&#123;&#123; github.ref &#125;&#125; overwrite: true file_glob: true draft: false #编译完成后 会自动发布到release java项目编译-maven1234567891011121314151617181920212223242526272829303132333435363738394041# This workflow will build a Java project with Maven, and cache/restore any dependencies to improve the workflow execution time# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-java-with-maven# This workflow uses actions that are not certified by GitHub.# They are provided by a third-party and are governed by# separate terms of service, privacy policy, and support# documentation.name: Java CI with Mavenon: push: branches: [ &quot;main&quot; ] pull_request: branches: [ &quot;main&quot; ]jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - name: Set up JDK 8 uses: actions/setup-java@v4 with: java-version: &#x27;8&#x27; distribution: &#x27;temurin&#x27; cache: maven - name: Build with Maven run: | mvn package assembly:single - name: Upload binaries to release - name: Upload binaries to release uses: svenstaro/upload-release-action@v2 with: repo_token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; file: &#123;路径&#125;/&#123;项目名&#125;* tag: $&#123;&#123; github.ref &#125;&#125; overwrite: true file_glob: true draft: false #编译完成后 会自动发布到release java项目编译-gradle123456789101112131415161718192021222324252627282930313233343536373839404142434445# This workflow uses actions that are not certified by GitHub.# They are provided by a third-party and are governed by# separate terms of service, privacy policy, and support# documentation.# This workflow will build a Java project with Gradle and cache/restore any dependencies to improve the workflow execution time# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-java-with-gradlename: Java CI with Gradleon: push: branches: [ &quot;main&quot; ] pull_request: branches: [ &quot;main&quot; ]jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - name: Set up JDK 8 uses: actions/setup-java@v4 with: java-version: &#x27;8&#x27; distribution: &#x27;temurin&#x27; # Configure Gradle for optimal use in GitHub Actions, including caching of downloaded dependencies. # See: https://github.com/gradle/actions/blob/main/setup-gradle/README.md - name: Setup Gradle uses: gradle/actions/setup-gradle@af1da67850ed9a4cedd57bfd976089dd991e2582 # v4.0.0 with: gradle-version: &#x27;8.7&#x27; - name: Build with Gradle Wrapper run: ./gradlew shadowJar - name: Upload binaries to release uses: svenstaro/upload-release-action@v2 with: repo_token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; file: build/libs/&#123;项目名&#125;* #这里需要修改 tag: $&#123;&#123; github.ref &#125;&#125; overwrite: true file_glob: true draft: false #编译完成后 会自动发布到release 具体保存得看构建的时候日志问题 rust项目编译123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209name: Release - Distribute binarieson: # If we want to make release using github interface. # release: # types: [published] # If we want to make release by pushing new tag. workflow_dispatch: push: tags: - &#x27;[0-9]+.[0-9]+.[0-9]+&#x27; pull_request: branches: - master paths: - &#x27;Cargo.toml&#x27; - &#x27;Cargo.lock&#x27; - &#x27;.github/workflows/test.yml&#x27;env: BIN_NAME: legba PROJECT_NAME: legba REPO_NAME: Legba/Legba BREW_TAP: Legba/homebrew-tapjobs: build: name: Build runs-on: $&#123;&#123; matrix.os &#125;&#125; strategy: fail-fast: false # don&#x27;t fail other jobs if one fails matrix: # aarch64-linux is failing due to python3 missing issues during tests. I&#x27;m removing it for now. # build: [x86_64-linux, aarch64-linux, x86_64-macos, aarch64-macos, x86_64-windows, x86_64-win-gnu] build: [x86_64-linux, x86_64-macos, aarch64-macos, x86_64-windows, x86_64-win-gnu] include: # - build: aarch64-linux # os: ubuntu-20.04 # rust: stable # target: aarch64-unknown-linux-gnu # cross: true - build: aarch64-macos os: macos-latest rust: stable target: aarch64-apple-darwin cross: true - build: x86_64-linux os: ubuntu-20.04 rust: stable target: x86_64-unknown-linux-gnu cross: false - build: x86_64-macos os: macos-latest rust: stable target: x86_64-apple-darwin cross: false - build: x86_64-windows os: windows-2019 rust: stable target: x86_64-pc-windows-msvc cross: false - build: x86_64-win-gnu os: windows-2019 rust: stable-x86_64-gnu target: x86_64-pc-windows-gnu cross: false steps: - name: Set Git config (windows only) if: contains(matrix.os, &#x27;windows&#x27;) # Windows is missing some dependencies run: | git config --global pack.windowMemory &quot;100m&quot; git config --global pack.packSizeLimit &quot;100m&quot; git config --global pack.threads &quot;1&quot; git config --global pack.deltaCacheSize &quot;512m&quot; #- name: Windows Install dependencies # if: contains(matrix.os, &#x27;windows&#x27;) # run: | # powershell.exe -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command &quot;iex ((New-Object System.Net.WebClient).DownloadString(&#x27;https://chocolatey.org/install.ps1&#x27;))&quot; # SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin&quot; # choco install openssl -y - name: Install dependencies #(按实际情况修改) if: contains(matrix.build, &#x27;x86_64-linux&#x27;) # Windows is missing some dependencies run: sudo apt-get update &amp;&amp; sudo apt-get install -y gcc-aarch64-linux-gnu python3 - name: Install python 3.10 uses: actions/setup-python@v5 with: python-version: &#x27;3.10&#x27; - name: Checkout sources uses: actions/checkout@v4 with: submodules: true - name: Install $&#123;&#123; matrix.rust &#125;&#125; toolchain uses: actions-rs/toolchain@v1 with: profile: minimal toolchain: $&#123;&#123; matrix.rust &#125;&#125; target: $&#123;&#123; matrix.target &#125;&#125; override: true - name: Run cargo test uses: actions-rs/cargo@v1 with: use-cross: $&#123;&#123; matrix.cross &#125;&#125; command: test args: --release --locked --target $&#123;&#123; matrix.target &#125;&#125; - name: Build release binary uses: actions-rs/cargo@v1 with: use-cross: $&#123;&#123; matrix.cross &#125;&#125; command: build args: --release --locked --target $&#123;&#123; matrix.target &#125;&#125; - name: Calculate tag name # if: contains(matrix.build, &#x27;linux&#x27;) shell: bash run: | name=dev if [[ $&#123;GITHUB_REF&#125; =~ refs/tags/[0-9]+.[0-9]+.[0-9]+ ]]; then name=$&#123;GITHUB_REF#refs/tags/&#125; fi echo &quot;TAG=$name&quot; &gt;&gt; $GITHUB_ENV id: tagname - name: Build and package artifacts shell: bash run: | mkdir dist if [[ &quot;$&#123;&#123; matrix.build &#125;&#125;&quot; =~ &quot;windows&quot; ]]; then cp &quot;target/$&#123;&#123; matrix.target &#125;&#125;/release/$BIN_NAME.exe&quot; &quot;dist/&quot; else cp &quot;target/$&#123;&#123; matrix.target &#125;&#125;/release/$BIN_NAME&quot; &quot;dist/&quot; fi if [[ &quot;$&#123;&#123; matrix.build &#125;&#125;&quot; =~ &quot;linux&quot; ]]; then cargo install cargo-deb cargo deb --target $&#123;&#123; matrix.target &#125;&#125; --deb-version $&#123;TAG&#125; cp &quot;target/$&#123;&#123; matrix.target &#125;&#125;/debian/legba_$&#123;TAG&#125;_amd64.deb&quot; &quot;dist/&quot; || true fi - uses: actions/upload-artifact@v4.3.4 with: name: bins-$&#123;&#123; matrix.build &#125;&#125; path: dist package: name: Package needs: [build] runs-on: ubuntu-latest steps: - name: Checkout sources uses: actions/checkout@v4 with: submodules: false - uses: actions/download-artifact@v4 with: path: dist - name: Calculate tag name # if: contains(matrix.build, &#x27;linux&#x27;) shell: bash run: | name=dev if [[ $&#123;GITHUB_REF&#125; =~ refs/tags/[0-9]+.[0-9]+.[0-9]+ ]]; then name=$&#123;GITHUB_REF#refs/tags/&#125; fi echo &quot;TAG=$name&quot; &gt;&gt; $GITHUB_ENV id: tagname - name: Build archive shell: bash run: | set -ex rm -rf tmp mkdir tmp for dir in dist/bins-* ; do platform=$&#123;dir#&quot;dist/bins-&quot;&#125; unset exe if [[ $platform =~ &quot;win&quot; ]]; then exe=&quot;.exe&quot; fi pkgname=$PROJECT_NAME-$TAG-$platform mkdir tmp/$pkgname cp $dir/$BIN_NAME$exe dist/ || true mv $dir/$BIN_NAME$exe tmp/$pkgname chmod +x tmp/$pkgname/$BIN_NAME$exe if [[ $platform =~ &quot;linux&quot; ]]; then mv &quot;$dir/legba_$&#123;TAG&#125;_amd64.deb&quot; dist/ || true fi tar cJf dist/$pkgname.tar.xz -C tmp $pkgname 7z a dist/$pkgname.zip tmp/$pkgname done - name: Upload binaries to release if: (github.event_name == &#x27;push&#x27; &amp;&amp; startsWith(github.ref, &#x27;refs/tags/&#x27;)) || github.event_name == &#x27;release&#x27; uses: svenstaro/upload-release-action@v2 with: repo_token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; file: dist/* file_glob: true tag: $&#123;&#123; github.ref &#125;&#125; overwrite: true","tags":["github actions"],"categories":["开发"]},{"title":"Hello World","path":"/p/4a17b156/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"友链","path":"/friends/index.html","content":"http://www.xiaodi8.com/http://www.xiaodi8.com/"}]